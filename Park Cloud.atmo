{
  "name": "Park Cloud",
  "createVersion": "2017-08-12",
  "description": "New Project",
  "lastModified": "2018-12-27T18:56:25.349Z",
  "created": "2018-12-27T18:56:25.349Z",
  "meta": {
    "projectTypeName": "NXP Rapid IoT",
    "projectTypeId": "NxpRpk"
  },
  "planes": {
    "NXP Rapid IoT": {
      "type": "mcuxpresso",
      "compilerVersion": "latest",
      "variants": [
        "NxpRpk"
      ],
      "meta": {},
      "elements": [
        {
          "name": "Interval",
          "type": "EmbeddedInterval",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_INTERVAL_Handle_t intervalHandle;\n    ATMO_INTERVAL_AddAbilityInterval(\n\t\tATMO_PROPERTY(Interval, instance), \n\t\tATMO_ABILITY(Interval, interval), \n\t\tATMO_PROPERTY(Interval, time), \n\t\t&intervalHandle\n\t);\n\t\n\treturn ATMO_Status_Success;\n\t",
              "interval": "\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "interval": false
            },
            "instance": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1",
            "time": "60000"
          },
          "meta": {
            "editorX": 104,
            "editorY": 67,
            "lastTrigger": "interval"
          },
          "triggers": {
            "triggered": [],
            "interval": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQuality_TVOC",
                "targetAbility": "readTVOC"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AirQuality_CO2",
                "targetAbility": "readCO2"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Pressure",
                "targetAbility": "readPressure"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Temperature",
                "targetAbility": "readTemperature"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "Humidity",
                "targetAbility": "readHumidity"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "AmbientLight",
                "targetAbility": "readAmbientLight"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BatteryInfo",
                "targetAbility": "trigger"
              },
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "MPL3115Pressure",
                "targetAbility": "readAltitude"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "interval": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "interval",
              "triggers": [
                "interval"
              ]
            }
          ]
        },
        {
          "name": "BLE_TVOC",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\t&ATMO_VARIABLE(BLE_TVOC, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_TVOC, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_TVOC, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_TVOC, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_TVOC, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_TVOC, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_TVOC, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_TVOC, writeDataType), ATMO_PROPERTY(BLE_TVOC, readDataType), ATMO_PROPERTY(BLE_TVOC, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\t&ATMO_VARIABLE(BLE_TVOC, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_TVOC, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_TVOC, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\tATMO_VARIABLE(BLE_TVOC, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_TVOC, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_TVOC, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\tATMO_VARIABLE(BLE_TVOC, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_TVOC, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f9",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 602,
            "editorY": 46,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "AirQuality_TVOC",
          "type": "EmbeddedCCS811",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(AirQuality_TVOC, operatingMode);\n\tconfig.address = ATMO_PROPERTY(AirQuality_TVOC, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(AirQuality_TVOC, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTVOC": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readCO2": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTVOC": true,
              "readCO2": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x5A",
            "operatingMode": "1"
          },
          "meta": {
            "editorX": 299,
            "editorY": 45,
            "lastTrigger": "TVOCRead"
          },
          "triggers": {
            "triggered": [],
            "TVOCRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_TVOC",
                "targetAbility": "setValue"
              }
            ],
            "CO2Read": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTVOC": false,
            "readCO2": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTVOC",
              "triggers": [
                "TVOCRead"
              ]
            },
            {
              "name": "readCO2",
              "triggers": [
                "CO2Read"
              ]
            }
          ]
        },
        {
          "name": "AirQuality_CO2",
          "type": "EmbeddedCCS811",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(AirQuality_CO2, operatingMode);\n\tconfig.address = ATMO_PROPERTY(AirQuality_CO2, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(AirQuality_CO2, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTVOC": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readCO2": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTVOC": false,
              "readCO2": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x5A",
            "operatingMode": "1"
          },
          "meta": {
            "editorX": 299,
            "editorY": 117,
            "lastTrigger": "CO2Read"
          },
          "triggers": {
            "triggered": [],
            "TVOCRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_CO2",
                "targetAbility": "setValue"
              }
            ],
            "CO2Read": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_CO2",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTVOC": false,
            "readCO2": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTVOC",
              "triggers": [
                "TVOCRead"
              ]
            },
            {
              "name": "readCO2",
              "triggers": [
                "CO2Read"
              ]
            }
          ]
        },
        {
          "name": "BLE_CO2",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\t&ATMO_VARIABLE(BLE_CO2, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_CO2, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_CO2, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_CO2, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_CO2, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_CO2, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_CO2, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_CO2, writeDataType), ATMO_PROPERTY(BLE_CO2, readDataType), ATMO_PROPERTY(BLE_CO2, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\t&ATMO_VARIABLE(BLE_CO2, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_CO2, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_CO2, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\tATMO_VARIABLE(BLE_CO2, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_CO2, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_CO2, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\tATMO_VARIABLE(BLE_CO2, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_CO2, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fa",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 602,
            "editorY": 116,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "Pressure",
          "type": "EmbeddedMPL3115",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_MPL3115_Config_t config;\n\tconfig.address = ATMO_PROPERTY(Pressure, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(Pressure, i2cInstance);\n\tconfig.MPLsettings.mode = MPL_MODE_PRESSURE;\n\tconfig.MPLsettings.oversample = MPL_OS_0;\t\t\t// oversampling = 1\n\tconfig.MPLsettings.autoAcquisitionTime = MPL_ST_0;\t// Auto acquisition time = 1s\n\tconfig.MPLsettings.pressureOffset = ATMO_PROPERTY(Pressure, pressureOffset);\t// Offset pressure correction = 4*-128 = -512Pa (8 bits signed integer)\n\tconfig.MPLsettings.altitudeOffset = ATMO_PROPERTY(Pressure, altitudeOffset);\t// Offset altitude correction = 128m (signed 8 bits integer)\n\tconfig.MPLsettings.tempOffset = ATMO_PROPERTY(Pressure, tempOffset);\t\t\t// Offset temperature correction -8C (0.0625C/LSB)\n\tconfig.MPLsettings.fifoMode = FIFO_DISABLED;\t\t// FIFO mode disabled\n\tconfig.MPLsettings.fifoWatermark = 5;\t\t\t\t// 6 bits to set the number of FIFO samples required to trigger a watermark interrupt.\n\tconfig.MPLsettings.fifoINTpin = FIFO_INT1;\t\t\t// set pin INT1 as output for FIFO interrupt\n\n\treturn ( ATMO_MPL3115_Init(&config) == ATMO_MPL3115_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_MPL3115_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_MPL3115_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_MPL3115_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readAltitude": "    uint32_t altitudeMeters;\n    if(ATMO_MPL3115_GetAltitude(&altitudeMeters) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)altitudeMeters);\n    return ATMO_Status_Success;",
              "readPressure": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)pressurePa);\n    return ATMO_Status_Success;",
              "readPressureKpa": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)(pressurePa/1000));\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readAltitude": false,
              "readPressure": false,
              "readPressureKpa": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x60",
            "pressureOffset": "0",
            "altitudeOffset": "0",
            "tempOffset": "0"
          },
          "meta": {
            "editorX": 298,
            "editorY": 199,
            "lastTrigger": "pressureRead"
          },
          "triggers": {
            "triggered": [],
            "altitudeRead": [],
            "pressureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Pressure",
                "targetAbility": "setValue"
              }
            ],
            "pressureReadKpa": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readAltitude": false,
            "readPressure": false,
            "readPressureKpa": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readAltitude",
              "triggers": [
                "altitudeRead"
              ]
            },
            {
              "name": "readPressure",
              "triggers": [
                "pressureRead"
              ]
            },
            {
              "name": "readPressureKpa",
              "triggers": [
                "pressureReadKpa"
              ]
            }
          ]
        },
        {
          "name": "BLE_Pressure",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\t&ATMO_VARIABLE(BLE_Pressure, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Pressure, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Pressure, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Pressure, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Pressure, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Pressure, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Pressure, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Pressure, writeDataType), ATMO_PROPERTY(BLE_Pressure, readDataType), ATMO_PROPERTY(BLE_Pressure, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\t&ATMO_VARIABLE(BLE_Pressure, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Pressure, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Pressure, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\tATMO_VARIABLE(BLE_Pressure, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Pressure, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Pressure, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\tATMO_VARIABLE(BLE_Pressure, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Pressure, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fc",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 600,
            "editorY": 199,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "Temperature",
          "type": "EmbeddedENS210",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(Temperature, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(Temperature, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(Temperature, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTemperature": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readHumidity": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTemperature": false,
              "readHumidity": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x43",
            "tempCalibrationOffset": -7
          },
          "meta": {
            "editorX": 299,
            "editorY": 289,
            "lastTrigger": "temperatureRead"
          },
          "triggers": {
            "triggered": [],
            "temperatureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Temperature",
                "targetAbility": "setValue"
              }
            ],
            "humidityRead": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTemperature": false,
            "readHumidity": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTemperature",
              "triggers": [
                "temperatureRead"
              ]
            },
            {
              "name": "readHumidity",
              "triggers": [
                "humidityRead"
              ]
            }
          ]
        },
        {
          "name": "BLE_Temperature",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\t&ATMO_VARIABLE(BLE_Temperature, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Temperature, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Temperature, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Temperature, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Temperature, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Temperature, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Temperature, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Temperature, writeDataType), ATMO_PROPERTY(BLE_Temperature, readDataType), ATMO_PROPERTY(BLE_Temperature, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\t&ATMO_VARIABLE(BLE_Temperature, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Temperature, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Temperature, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\tATMO_VARIABLE(BLE_Temperature, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Temperature, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Temperature, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\tATMO_VARIABLE(BLE_Temperature, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Temperature, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fb",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 600,
            "editorY": 289,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "Humidity",
          "type": "EmbeddedENS210",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(Humidity, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(Humidity, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(Humidity, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readTemperature": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;",
              "readHumidity": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readTemperature": false,
              "readHumidity": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x43",
            "tempCalibrationOffset": -7
          },
          "meta": {
            "editorX": 303,
            "editorY": 384,
            "lastTrigger": "humidityRead"
          },
          "triggers": {
            "triggered": [],
            "temperatureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Humidity",
                "targetAbility": "setValue"
              }
            ],
            "humidityRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Humidity",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readTemperature": false,
            "readHumidity": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readTemperature",
              "triggers": [
                "temperatureRead"
              ]
            },
            {
              "name": "readHumidity",
              "triggers": [
                "humidityRead"
              ]
            }
          ]
        },
        {
          "name": "BLE_Humidity",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\t&ATMO_VARIABLE(BLE_Humidity, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Humidity, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Humidity, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Humidity, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Humidity, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Humidity, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Humidity, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Humidity, writeDataType), ATMO_PROPERTY(BLE_Humidity, readDataType), ATMO_PROPERTY(BLE_Humidity, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\t&ATMO_VARIABLE(BLE_Humidity, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Humidity, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Humidity, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\tATMO_VARIABLE(BLE_Humidity, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Humidity, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Humidity, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\tATMO_VARIABLE(BLE_Humidity, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Humidity, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fd",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 600,
            "editorY": 387,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "AmbientLight",
          "type": "EmbeddedTSL2572",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(AmbientLight, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(AmbientLight, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readAmbientLight": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readAmbientLight": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x39"
          },
          "meta": {
            "editorX": 300,
            "editorY": 489,
            "lastTrigger": "ambientLightRead"
          },
          "triggers": {
            "triggered": [],
            "ambientLightRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Light",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readAmbientLight": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readAmbientLight",
              "triggers": [
                "ambientLightRead"
              ]
            }
          ]
        },
        {
          "name": "BLE_Light",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\t&ATMO_VARIABLE(BLE_Light, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Light, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Light, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Light, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Light, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Light, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Light, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Light, writeDataType), ATMO_PROPERTY(BLE_Light, readDataType), ATMO_PROPERTY(BLE_Light, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\t&ATMO_VARIABLE(BLE_Light, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Light, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Light, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\tATMO_VARIABLE(BLE_Light, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Light, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Light, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\tATMO_VARIABLE(BLE_Light, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Light, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fe",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 600,
            "editorY": 491,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "BatteryInfo",
          "type": "EmbeddedFunction",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\tuint8_t batteryPercentLevel = 0;\n\tuint8_t batteryChargingState = 0;\n\tBatterySensor_GetState(&batteryPercentLevel, &batteryChargingState);\n\tATMO_CreateValueUnsignedInt(out, batteryPercentLevel);\n\treturn ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "trigger": true
            }
          },
          "meta": {
            "editorX": 298,
            "editorY": 589,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Battery",
                "targetAbility": "setValue"
              }
            ]
          },
          "interruptAbilities": {
            "trigger": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            }
          ]
        },
        {
          "name": "BLE_Battery",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\t&ATMO_VARIABLE(BLE_Battery, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Battery, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Battery, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Battery, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Battery, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Battery, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Battery, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Battery, writeDataType), ATMO_PROPERTY(BLE_Battery, readDataType), ATMO_PROPERTY(BLE_Battery, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\t&ATMO_VARIABLE(BLE_Battery, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Battery, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Battery, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\tATMO_VARIABLE(BLE_Battery, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Battery, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Battery, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\tATMO_VARIABLE(BLE_Battery, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Battery, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336ff",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 600,
            "editorY": 590,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        },
        {
          "name": "Backlight",
          "type": "EmbeddedNxpRpkBacklight",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "rpk"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n    Backlight_SetLevel(ATMO_PROPERTY(Backlight, initialSetting));\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightOff": "\n    Backlight_SetLevel(BLIGHT_LEVEL_OFF);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightLow": "\n    Backlight_SetLevel(BLIGHT_LEVEL_LOW);\n\treturn ATMO_Status_Success;\n\t",
              "setBacklightMedium": "\n    Backlight_SetLevel(BLIGHT_LEVEL_MEDIUM);\n\treturn ATMO_Status_Success;\n    ",
              "setBacklightHigh": "\n    Backlight_SetLevel(BLIGHT_LEVEL_HIGH);\n\treturn ATMO_Status_Success;\n\t"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setBacklightOff": false,
              "setBacklightLow": false,
              "setBacklightMedium": false,
              "setBacklightHigh": false
            },
            "initialSetting": "BLIGHT_LEVEL_OFF"
          },
          "meta": {
            "editorX": 101,
            "editorY": 188,
            "lastTrigger": "triggered"
          },
          "triggers": {
            "triggered": [],
            "backlightSet": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setBacklightOff": false,
            "setBacklightLow": false,
            "setBacklightMedium": false,
            "setBacklightHigh": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setBacklightOff",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightLow",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightMedium",
              "triggers": [
                "backlightSet"
              ]
            },
            {
              "name": "setBacklightHigh",
              "triggers": [
                "backlightSet"
              ]
            }
          ]
        },
        {
          "name": "MPL3115Pressure",
          "type": "EmbeddedMPL3115",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\tATMO_MPL3115_Config_t config;\n\tconfig.address = ATMO_PROPERTY(MPL3115Pressure, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(MPL3115Pressure, i2cInstance);\n\tconfig.MPLsettings.mode = MPL_MODE_PRESSURE;\n\tconfig.MPLsettings.oversample = MPL_OS_0;\t\t\t// oversampling = 1\n\tconfig.MPLsettings.autoAcquisitionTime = MPL_ST_0;\t// Auto acquisition time = 1s\n\tconfig.MPLsettings.pressureOffset = ATMO_PROPERTY(MPL3115Pressure, pressureOffset);\t// Offset pressure correction = 4*-128 = -512Pa (8 bits signed integer)\n\tconfig.MPLsettings.altitudeOffset = ATMO_PROPERTY(MPL3115Pressure, altitudeOffset);\t// Offset altitude correction = 128m (signed 8 bits integer)\n\tconfig.MPLsettings.tempOffset = ATMO_PROPERTY(MPL3115Pressure, tempOffset);\t\t\t// Offset temperature correction -8C (0.0625C/LSB)\n\tconfig.MPLsettings.fifoMode = FIFO_DISABLED;\t\t// FIFO mode disabled\n\tconfig.MPLsettings.fifoWatermark = 5;\t\t\t\t// 6 bits to set the number of FIFO samples required to trigger a watermark interrupt.\n\tconfig.MPLsettings.fifoINTpin = FIFO_INT1;\t\t\t// set pin INT1 as output for FIFO interrupt\n\n\treturn ( ATMO_MPL3115_Init(&config) == ATMO_MPL3115_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n",
              "setEnabled": "ATMO_MPL3115_SetEnabled(true);\nreturn ATMO_Status_Success;",
              "setDisabled": "ATMO_MPL3115_SetEnabled(false);\nreturn ATMO_Status_Success;",
              "setEnabledDisabled": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_MPL3115_SetEnabled(enabled);\nreturn ATMO_Status_Success;",
              "readAltitude": "    uint32_t altitudeMeters;\n    if(ATMO_MPL3115_GetAltitude(&altitudeMeters) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)altitudeMeters);\n    return ATMO_Status_Success;",
              "readPressure": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)pressurePa);\n    return ATMO_Status_Success;",
              "readPressureKpa": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)(pressurePa/1000));\n    return ATMO_Status_Success;"
            },
            "variables": {},
            "embeddedPropertyConversions": {},
            "codeUserChanged": {
              "setup": false,
              "setEnabled": false,
              "setDisabled": false,
              "setEnabledDisabled": false,
              "readAltitude": false,
              "readPressure": false,
              "readPressureKpa": false
            },
            "i2cInstance": 1,
            "i2cAddress": "0x60",
            "pressureOffset": "0",
            "altitudeOffset": "0",
            "tempOffset": "0"
          },
          "meta": {
            "editorX": 379,
            "editorY": 241,
            "lastTrigger": "altitudeRead"
          },
          "triggers": {
            "triggered": [],
            "altitudeRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Altitude",
                "targetAbility": "setValue"
              }
            ],
            "pressureRead": [
              {
                "mapping": {},
                "targetOrder": [],
                "targetElement": "BLE_Altitude",
                "targetAbility": "setValue"
              }
            ],
            "pressureReadKpa": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setEnabled": false,
            "setDisabled": false,
            "setEnabledDisabled": false,
            "readAltitude": false,
            "readPressure": false,
            "readPressureKpa": false
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setEnabled",
              "triggers": []
            },
            {
              "name": "setDisabled",
              "triggers": []
            },
            {
              "name": "setEnabledDisabled",
              "triggers": []
            },
            {
              "name": "readAltitude",
              "triggers": [
                "altitudeRead"
              ]
            },
            {
              "name": "readPressure",
              "triggers": [
                "pressureRead"
              ]
            },
            {
              "name": "readPressureKpa",
              "triggers": [
                "pressureReadKpa"
              ]
            }
          ]
        },
        {
          "name": "BLE_Altitude",
          "type": "EmbeddedBLECharacteristicCustom",
          "variants": [
            "embedded",
            "triggers",
            "abilities",
            "properties",
            "variables",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\t&ATMO_VARIABLE(BLE_Altitude, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Altitude, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Altitude, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Altitude, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Altitude, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Altitude, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Altitude, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Altitude, writeDataType), ATMO_PROPERTY(BLE_Altitude, readDataType), ATMO_PROPERTY(BLE_Altitude, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\t&ATMO_VARIABLE(BLE_Altitude, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Altitude, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Altitude, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\tATMO_VARIABLE(BLE_Altitude, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Altitude, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Altitude, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\tATMO_VARIABLE(BLE_Altitude, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Altitude, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f7",
            "read": true,
            "write": false,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 515,
            "editorY": 239,
            "lastTrigger": "written"
          },
          "triggers": {
            "triggered": [],
            "written": [],
            "subscibed": [],
            "unsubscribed": []
          },
          "interruptAbilities": {
            "trigger": false,
            "setup": false,
            "setValue": "valueSet",
            "written": true,
            "subscibed": true,
            "unsubscribed": true
          },
          "abilities": [
            {
              "name": "trigger",
              "triggers": [
                "triggered"
              ]
            },
            {
              "name": "setup",
              "triggers": []
            },
            {
              "name": "setValue",
              "triggers": []
            },
            {
              "name": "written",
              "triggers": [
                "written"
              ]
            },
            {
              "name": "subscibed",
              "triggers": [
                "subscibed"
              ]
            },
            {
              "name": "unsubscribed",
              "triggers": [
                "unsubscribed"
              ]
            }
          ]
        }
      ],
      "libraries": {
        "ens210": {
          "libName": "ens210",
          "description": "AMS ENS210 Humidity and Temperature Sensor",
          "type": "Humidity, Temperature Sensor",
          "icon": "",
          "manufacturer": "AMS",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/products/en/development-boards-kits-programmers/evaluation-boards-sensors/795?k=AMS%20ens210"
              },
              "cartData": {
                "part": "ENS210-QF_EK_ST-ND",
                "partid": "6490748",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "ENS210TemperatureHumidity",
              "type": "EmbeddedENS210",
              "icon": "EmbeddedTempHumidity.svg",
              "defaultAbility": "readTemperature",
              "defaultTrigger": "temperatureRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/amsens210element.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "\tATMO_ENS210_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.tempCalibrationOffset = ATMO_PROPERTY(undefined, tempCalibrationOffset);\n\n\treturn ( ATMO_ENS210_Init(&config) == ATMO_ENS210_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_ENS210_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_ENS210_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTemperature",
                  "triggers": [
                    "temperatureRead"
                  ],
                  "code": "    float tempC;\n    \n    if(ATMO_ENS210_GetTemperatureFloat(&tempC) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, tempC);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readHumidity",
                  "triggers": [
                    "humidityRead"
                  ],
                  "code": "    float humidityPct;\n\n    if(ATMO_ENS210_GetHumidityFloat(&humidityPct) == ATMO_ENS210_Status_Success)\n    {\n        ATMO_CreateValueFloat(out, humidityPct);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x43"
                },
                {
                  "name": "tempCalibrationOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedENS210": "AMS ENS210",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "readTemperature": "Read Temperature (C)",
                  "temperatureRead": "Temperature Read",
                  "readHumidity": "Read Humidity (%rh)",
                  "humidityRead": "Humidity Read",
                  "tempCalibrationOffset": "Temperature Calibration Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ens210.h": "#ifndef _ATMO_ENS210_H_\n#define _ATMO_ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_ENS210_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_ENS210_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_ENS210_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_ENS210_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_ENS210_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_ENS210_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    int16_t tempCalibrationOffset;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n} ATMO_ENS210_Config_t;\n\n/**\n * Initialize ENS210 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config);\n\n/**\n * Enable/Disable ENS210 Driver\n *\n * @param[in] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of ENS210 driver\n *\n * @param[out] enabled\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperatureCelsius\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius);\n\n/**\n * Get Humidity\n * \n * @param[out] humidityPct\n */\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct);\n\n#endif\n",
                "ens210_internal.h": "/*\n*********************************************************************************\n * Copyright 2018 by ams AG                                                     *\n *                                                                              *\n * Redistribution and use in source and binary forms, with or without           *\n * modification, *are permitted provided that the following conditions are met: *\n *  1. Redistributions of source code must retain the above copyright notice,   *\n * this list of conditions and the following disclaimer.                        *\n *                                                                              *\n *  2. Redistributions in binary form must reproduce the above copyright notice,*\n *  this list of conditions and the following disclaimer in the documentation   *\n *  and/or other materials provided with the distribution.                      *\n *  3. Neither the name of the copyright holder nor the names of its            *\n * contributors may be used to endorse or promote products derived from this    *\n * software without specific prior written permission.                          *\n *                                                                              *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  *\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    *\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   *\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE    *\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          *\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         *\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     *\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      *\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      *\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   *\n * POSSIBILITY OF SUCH DAMAGE.                                                  *\n ********************************************************************************\n*/\n\n\n#ifndef __ENS210_H_\n#define __ENS210_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*! @addtogroup ens210   ENS210 Driver API\n * This module provides the API to operate an ENS210 relative humidity and temperature sensor with I2C interface.\n *\n * Basic steps to operate the sensor are as follows:\n * -# Set Run mode (#ENS210_SensRun_Set)\n * -# Start measurement (#ENS210_SensStart_Set)\n * -# Wait for measurement to complete\n * -# Read measurement (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get)\n *\n * Please refer to ENS210 Reference Driver and Porting Guide for more details on platform porting. In this module, names\n * T and H have been used to refer to temperature and relative humidity respectively to comply with ENS210 datasheet\n * naming convention.\n *\n * Example 1 - Sample application code to measure temperature and relative humidity without error checking\n * -------------------------------------------------------------------------------------------------------\n * @code\n * uint32_t T_Raw, H_Raw;\n * int32_t T_mCelsius, T_mFahrenheit, T_mKelvin, H_Percent;\n *\n * //Set runmode, start measurement, wait, read measurement (for both T and H)\n * ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * ENS210_SensStart_Set(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START);\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n * ENS210_THVal_Get(&T_Raw,&H_Raw);\n *\n * //Convert the raw temperature to milli Kelvin\n * T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n * //Convert the raw temperature to milli Celsius\n * T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n * //Convert the raw temperature to milli Fahrenheit\n * T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n * printf(\"T crc ok = %s\\n\", ENS210_IsCrcOk(T_Raw)  ? \"yes\" : \"no\");\n * printf(\"T valid = %s \\n\", ENS210_IsDataValid(T_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"T = %ld mK %ld mC %ld mF \\n\", T_mKelvin, T_mCelsius, T_mFahrenheit);\n *\n * //Convert the raw relative humidity to milli %\n * H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n * printf(\"H crc ok = %s\\n\", ENS210_IsCrcOk(H_Raw)  ? \"yes\" : \"no\");\n * printf(\"H valid = %s \\n\", ENS210_IsDataValid(H_Raw) ? \"yes\" : \"no\");\n * //Update the int32_t format specifier (%ld) based on platform word-size\n * printf(\"H = %ld m%%\\n\", H_Percent);\n *\n * @endcode\n *\n *\n * Example 2 - Sample application code to measure relative humidity with error checking\n * ------------------------------------------------------------------------------------\n * @code\n * uint32_t H_Raw;\n * int32_t H_Percent;\n * int status;\n * bool i2cOk;\n *\n * i2cOk = true; //Start accumulating I2C transaction errors\n *\n * status = ENS210_SensRun_Set(ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * status = ENS210_SensStart_Set(ENS210_SENSSTART_H_START);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * WaitMsec(ENS210_T_H_CONVERSION_TIME_MS);\n *\n * status = ENS210_HVal_Get(&H_Raw);\n * i2cOk &= status==I2C_RESULT_OK;\n *\n * if( !i2cOk ) {\n *     printf(\"H i2c error\\n\")\n * } else if( !ENS210_IsCrcOk(H_Raw) ) {\n *     printf(\"H crc error\\n\")\n * } else if( !ENS210_IsDataValid(H_Raw) ) {\n *     printf(\"H data invalid\\n\")\n * } else {\n *     //Convert the raw relative humidity to milli %\n *     H_Percent = ENS210_ConvertRawToPercentageH(H_Raw,1000);\n *     //Update the int32_t format specifier (%ld) based on platform word-size\n *     printf(\"H = %ld m%%\\n\", H_Percent);\n * }\n *\n * @endcode\n *\n * @{\n */\n/*****************************************************************************\n * Types/enumerations/variables\n ****************************************************************************/\n\n/*! @brief Status return codes. */\ntypedef enum ens210_status_ {\n    ens210_success = 0,             /*!< Function returned successfully. */\n    ens210_I2C_error = 1,           /*!< I2C Error. */\n    ens210_invalid_ID = 2,          /*!< Invalid ID. */\n    ens210_Tdata_CRC_error = 3,     /*!< CRC error for temperature data. */\n    ens210_Hdata_CRC_error = 4,     /*!< CRC error for humidity data. */\n    ens210_T_invalid_data = 5,      /*!< Temperature Data is invalid. */\n    ens210_H_invalid_data = 6,      /*!< Humidity Data is invalid. */\n    ens210_wrong_parameter = 7,     /*!< Wrong Parameter entered. */\n    ens210_noinit = 8               /*!< ENS210 was not initialized. */\n} ens210_status_t;\n\n/*! @brief Measurement mode of Sensor */\nenum measurement_mode {\n    mode_TH = 0,        /*!< ENS210 set to measure both temperature and humidity. */\n    mode_Tonly = 1,     /*!< ENS210 set to measure temperature only. */\n    mode_Honly = 2      /*!< ENS210 set to measure humidity only. */\n};\n\n/*! ENS210 os-free driver version info */\n#define ENS210_OSFREE_DRIVER_VERSION            2\n\n/*! ENS210 T and H conversion time in milliseconds. Refer to ENS210 data sheet for timing information. */\n#define ENS210_T_H_CONVERSION_TIME_MS           130\n\n/*! ENS210 T conversion time in milliseconds */\n#define ENS210_T_CONVERSION_TIME_MS             110\n\n/*! ENS210 Booting time in milliseconds. */\n#define ENS210_BOOTING_TIME_MS                  10\n\n/*! ENS210 Reset time in milliseconds. */\n#define ENS210_RESET_WAIT_TIME_MS               10\n\n/*! ENS210 I2C slave address */\n#define ENS210_I2C_SLAVE_ADDRESS                (uint8_t)0x43\n\n/*! ENS210 SysCtrl register: Low power enable */\n#define ENS210_SYSCTRL_LOWPOWER_ENABLE          (1 << 0)\n/*! ENS210 SysCtrl register: Low power disable */\n#define ENS210_SYSCTRL_LOWPOWER_DISABLE         (0 << 0)\n/*! ENS210 SysCtrl register: Reset enable */\n#define ENS210_SYSCTRL_RESET_ENABLE             (1 << 7)\n/*! ENS210 SysCtrl register: Reset disable */\n#define ENS210_SYSCTRL_RESET_DISABLE            (0 << 7)\n\n/*! ENS210 SysStat register: Standby or Booting mode */\n#define ENS210_SYSSTAT_MODE_STANDBY             (0 << 0)\n/*! ENS210 SysStat register: Active mode */\n#define ENS210_SYSSTAT_MODE_ACTIVE              (1 << 0)\n\n\n/*! ENS210 SensRun register: temperature single shot mode */\n#define ENS210_SENSRUN_T_MODE_SINGLE_SHOT       (0 << 0)\n/*! ENS210 SensRun register: temperature continuous mode */\n#define ENS210_SENSRUN_T_MODE_CONTINUOUS        (1 << 0)\n/*! ENS210 SensRun register: relative humidity single shot mode */\n#define ENS210_SENSRUN_H_MODE_SINGLE_SHOT       (0 << 1)\n/*! ENS210 SensRun register: relative humidity continuous mode */\n#define ENS210_SENSRUN_H_MODE_CONTINUOUS        (1 << 1)\n\n/*! ENS210  SensStart register: T sensor start */\n#define ENS210_SENSSTART_T_START                (1 << 0)\n/*! ENS210  SensStart register: H sensor start */\n#define ENS210_SENSSTART_H_START                (1 << 1)\n\n/*! ENS210  SensStop register: T sensor stop */\n#define ENS210_SENSSTOP_T_STOP                  (1 << 0)\n/*! ENS210  SensStop register: H sensor stop */\n#define ENS210_SENSSTOP_H_STOP                  (1 << 1)\n\n/*! ENS210  SensStat register: T sensor idle */\n#define ENS210_SENSSTAT_T_STAT_IDLE             (0 << 0)\n/*! ENS210  SensStat register: T sensor active */\n#define ENS210_SENSSTAT_T_STAT_ACTIVE           (1 << 0)\n/*! ENS210  SensStat register: H sensor idle */\n#define ENS210_SENSSTAT_H_STAT_IDLE             (0 << 1)\n/*! ENS210  SensStat register: H sensor active */\n#define ENS210_SENSSTAT_H_STAT_ACTIVE           (1 << 1)\n\n/* wrapper for the I2C write, I2C read and wait functions needed by the sensor driver */\n/* it is expected that the I2C_Read and I2C_Write functions return 0 if the I2C transaction is successful */\ntypedef struct _ens210_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);  /*!< External I2C read function */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);  /*!< External I2C write function */\n    void      (*WaitMsec)(uint32_t millisec); /*!< Wait function in milliseconds */\n} ens210_IoFunc_t, *pens210_IoFunc_t;\n\n/*! @brief    ENS210 ID block structure */\ntypedef struct ENS210_Ids_s\n{\n    uint16_t    partId;             /*!< Part ID */\n    uint8_t     uId[8];             /*!< Unique Identifier 8 bytes */\n} ENS210_Ids_t;\n\n/*! @brief Structure of measurement data. */\ntypedef struct ens210_meas_data_s\n{\n    int32_t T_Celsius;              /*!< Temperature in Celsius */\n    int32_t T_Fahrenheit;           /*!< Temperature in Fahrenheit */\n    int32_t T_Kelvin;               /*!< Temperature in Kelvin */\n    int32_t T_mCelsius;             /*!< Temperature in milliCelsius */\n    int32_t T_mFahrenheit;          /*!< Temperature in milliFahrenheit */\n    int32_t T_mKelvin;              /*!< Temperature in milliKelvin */\n    int32_t H_Percent;              /*!< Relative Humidity to % */\n    int32_t H_mPercent;             /*!< Relative Humidity to milli% */\n} ens210_meas_data_t;\n\n/****************************************************************************\n * Function Prototypes\n ****************************************************************************/\n\n/*!\n * @brief   Initialize ENS210 driver.\n * @param   pIoFunc     :   Pointer to a structure of external functions or values\n */\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc);\n\n/*!\n * @brief   De-initialize ENS210 driver.\n */\nvoid ENS210_Deinit_Driver();\n\n/*!\n * @brief   Initialize ENS210 hardware.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_Init_Hw(void);\n\n/*!\n * @brief   Set ENS210 SysCtrl register; enabling reset and/or low power.\n * @param   sysCtrl     :   Mask composed of  ENS210_SYSCTRL_xxx macros.\n * @return  The return status value (0 for success)\n *  */\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysCtrl register.\n * @param   sysCtrl     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl);\n\n/*!\n * @brief   Get ENS210 SysStat register.\n * @param   sysStat     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat);\n\n/*!\n * @brief   Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\n * @param   sensRun     :   Mask composed of ENS210_SENSRUN_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun);\n\n/*!\n * @brief   Get ENS210 SensRun register.\n * @param   sensRun     :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun);\n\n/*!\n * @brief   Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\n * @param   sensStart   :  Mask composed of ENS210_SENSSTART_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart);\n\n/*!\n * @brief   Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\n * @param   sensStop    :   Mask composed of ENS210_SENSSTOP_xxx macros.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop);\n\n/*!\n * @brief   Get ENS210 SensStat register.\n * @param   sensStat    :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n */\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat);\n\n/*!\n * @brief   Get ENS210 TVal register; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of the register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * Use ENS210_ConvertRawToXXX to convert raw data to standard units.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_TVal_Get(uint32_t *traw);\n\n/*!\n * @brief   Get ENS210 HVal register; raw measurement data as well as CRC and valid indication.\n * @param   hraw         :   Pointer to receive value of register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_HVal_Get(uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 TVal and HVal registers; raw measurement data as well as CRC and valid indication.\n * @param   traw         :   Pointer to receive value of TVal register. Must not be null.\n * @param   hraw         :   Pointer to receive value of HVal register. Must not be null.\n * @return  The return status value (0 for success)\n * @note\n * Use ENS210_IsCrcOk and ENS210_IsDataValid before using the measurement data.\\n\n * If the return indicates I2C failure, the value of the out parameter is undefined.\n */\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw);\n\n/*!\n * @brief   Get ENS210 Part ID and UID.\n * @param   ids         :   Pointer to receive ids. Must not be null.\n * @return  The return status value (0 for success)\n * @note    If this function returns an error, it is suggested to reset the device to bring it to a known state.\n */\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids);\n\n/*!\n * @brief   Get ENS210 temperature and humidity measurements\n * @param   meas_mode    :   Measurement mode\n * @param   results      :   Pointer to the result structure\n * @return  The return status value (0 for success)\n * @note\n * mode = 0: temperature and humidity\\n\n * mode = 1: temperature only\\n\n * mode = 2: humidity only\n */\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results);\n\n/*!\n * @}\n */\n\n#endif /* __ENS210_H_ */\n\n"
              },
              "objects": {
                "ens210.c": "#include \"ens210.h\"\n#include \"ens210_internal.h\"\n\ntypedef struct {\n    ATMO_ENS210_Config_t config;\n    bool configured;\n} ATMO_ENS210_Priv_Config;\n\nstatic ATMO_ENS210_Priv_Config _ATMO_ENS210_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_ENS210_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool _ATMO_ENS210_Enabled = true;\n\nstatic uint8_t ATMO_ENS210_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t ATMO_ENS210_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_ENS210_config.config.i2cDriverInstance, _ATMO_ENS210_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_Init(ATMO_ENS210_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_ENS210_SetConfiguration(config);\n    }\n    else\n    {\n        _ATMO_ENS210_config.configured = false;\n    }\n\n    ens210_IoFunc_t io;\n    io.I2C_Read = ATMO_ENS210_I2CRead_Simple;\n    io.I2C_Write = ATMO_ENS210_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    ENS210_Init_Driver(&io);\n    ENS210_Init_Hw();\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetEnabled(bool enabled)\n{\n    _ATMO_ENS210_Enabled = enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetEnabled(bool *enabled)\n{\n    *enabled = _ATMO_ENS210_Enabled;\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_SetConfiguration(const ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_ENS210_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n    memcpy( &_ATMO_ENS210_config.config, config, sizeof(ATMO_ENS210_Config_t) );\n    _ATMO_ENS210_config.configured = true;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetConfiguration(ATMO_ENS210_Config_t *config)\n{\n    if( config == NULL || !_ATMO_ENS210_config.configured )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_ENS210_config.config, sizeof(ATMO_ENS210_Config_t));\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = results.T_Celsius + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidity(int32_t *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_Percent;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetTemperatureFloat(float *temperatureCelsius)\n{\n    if(!_ATMO_ENS210_Enabled || !_ATMO_ENS210_config.configured)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Tonly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *temperatureCelsius = (results.T_mCelsius / 1000.0) + _ATMO_ENS210_config.config.tempCalibrationOffset;\n\n    return ATMO_ENS210_Status_Success;\n}\n\nATMO_ENS210_Status_t ATMO_ENS210_GetHumidityFloat(float *humidityPct)\n{\n    if(!_ATMO_ENS210_Enabled)\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    ens210_meas_data_t results;\n    if( ENS210_Measure(mode_Honly, &results) != 0 )\n    {\n        return ATMO_ENS210_Status_Fail;\n    }\n\n    *humidityPct = results.H_mPercent / 1000.0;\n\n    return ATMO_ENS210_Status_Success;\n}",
                "ens210_internal.c": "/*\n*********************************************************************************\n * Copyright 2018 by ams AG                                                     *\n *                                                                              *\n * Redistribution and use in source and binary forms, with or without           *\n * modification, *are permitted provided that the following conditions are met: *\n *  1. Redistributions of source code must retain the above copyright notice,   *\n * this list of conditions and the following disclaimer.                        *\n *                                                                              *\n *  2. Redistributions in binary form must reproduce the above copyright notice,*\n *  this list of conditions and the following disclaimer in the documentation   *\n *  and/or other materials provided with the distribution.                      *\n *  3. Neither the name of the copyright holder nor the names of its            *\n * contributors may be used to endorse or promote products derived from this    *\n * software without specific prior written permission.                          *\n *                                                                              *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  *\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    *\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   *\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE    *\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          *\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         *\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     *\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      *\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      *\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   *\n * POSSIBILITY OF SUCH DAMAGE.                                                  *\n ********************************************************************************\n*/\n\n/**\n * @file\n * This is the source file for the temperature and humidity sensor ENS210 driver.\n */\n\n#include \"ens210_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/*****************************************************************************\n * Private macros and functions\n ****************************************************************************/\n/* Register addresses */\n#define ENS210_REG_PART_ID     0x00\n#define ENS210_REG_UID         0x04\n#define ENS210_REG_SYS_CTRL    0x10\n#define ENS210_REG_SYS_STAT    0x11\n#define ENS210_REG_SENS_RUN    0x21\n#define ENS210_REG_SENS_START  0x22\n#define ENS210_REG_SENS_STOP   0x23\n#define ENS210_REG_SENS_STAT   0x24\n#define ENS210_REG_T_VAL       0x30\n#define ENS210_REG_H_VAL       0x33\n\n/** Mask to extract 16-bit data from raw T and H values */\n#define ENS210_T_H_MASK        0xFFFFU\n\n/** Simplification macro, implementing integer division with simple rounding to closest number\n *  It supports both positive and negative numbers, but ONLY positive divisors */\n#define IDIV(n,d)              ((n)>0 ? ((n)+(d)/2)/(d) : ((n)-(d)/2)/(d))\n\n#define CRC7WIDTH              7     //7 bits CRC has polynomial of 7th order (has 8 terms)\n#define CRC7POLY               0x89  //The 8 coefficients of the polynomial\n#define CRC7IVEC               0x7F  //Initial vector has all 7 bits high\n\n#define DATA7WIDTH             17\n#define DATA7MASK              ((1UL << DATA7WIDTH) - 1)  //0b 1 1111 1111 1111 1111\n#define DATA7MSB               (1UL << (DATA7WIDTH - 1))  //0b 1 0000 0000 0000 0000\n\n/** When the ENS210 is soldered a correction on T needs to be applied (see application note).\n *  Typically the correction is 50mK. Units for raw T is 1/64K. */\n#define ENS210_TRAW_SOLDERCORRECTION  (50*64/1000)\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\n\nstatic ens210_IoFunc_t sENS210_Func;\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\n\n/*****************************************************************************\n * Private functions prototypes\n ****************************************************************************/\n\n/*\n * @brief   Compute the CRC7 results.\n * @param   val   :   the value\n * @return  The CRC7 computed result\n */\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val);\n\n/*\n * @brief   Verify the CRC of the raw temperature or relative humidity.\n * @param   raw         :  Raw temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Success,  False - Failure.\n * @note    This function can be used on raw T as well as raw H data (since they use the same format and CRC).\n */\nstatic bool ENS210_IsCrcOk(uint32_t raw);\n\n/*\n * @brief   Verify data validity of the raw temperature or relative humidity.\n * @param   raw         :  Raw  temperature or relative humidity value to be verified (#ENS210_TVal_Get, #ENS210_HVal_Get, #ENS210_THVal_Get).\n * @return  True - Valid,  False - Invalid.\n */\nstatic bool ENS210_IsDataValid(uint32_t raw);\n\n/*\n * @brief   Converts a raw temperature value into Kelvin.\n *          The output value is in Kelvin multiplied by parameter \"multiplier\".\n * @param   traw        :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier  :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Kelvin.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Celsius.\n *          The output value is in Celsius multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor.\n * @return  The temperature value in 1/multiplier Celsius.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw temperature value into Fahrenheit.\n *          The output value is in Fahrenheit multiplied by parameter \"multiplier\".\n * @param   traw         :   The temperature value in the raw format (#ENS210_TVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted temperature\n * @return  The temperature value in 1/multiplier Fahrenheit.\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier);\n\n/*\n * @brief   Converts a raw relative humidity value into human readable format.\n * @param   hraw         :   The relative humidity value in the raw format (#ENS210_HVal_Get, #ENS210_THVal_Get).\n * @param   multiplier   :   The multiplication factor of the converted relative humidity.\n * @return  The converted relative humidity value\n * @note    The multiplier should be between 1 and 1024 (inclusive) to avoid overflows.\n * @note    Typical values for multiplier are 1, 10, 100, 1000, or powers of 2.\n */\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier);\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\n//Compute the CRC-7 of 'val' (which should only have 17 bits)\nstatic uint32_t ENS210_ComputeCRC7(uint32_t val)\n{\n    //Setup polynomial\n    uint32_t pol= CRC7POLY;\n\n    //Align polynomial with data\n    pol = pol << (DATA7WIDTH-CRC7WIDTH-1);\n\n    //Loop variable (indicates which bit to test, start with highest)\n    uint32_t bit = DATA7MSB;\n\n    //Make room for CRC value\n    val = val << CRC7WIDTH;\n    bit = bit << CRC7WIDTH;\n    pol = pol << CRC7WIDTH;\n\n    //Insert initial vector\n    val |= CRC7IVEC;\n\n    //Apply division until all bits done\n    while( bit & (DATA7MASK<<CRC7WIDTH) )\n    {\n        if( bit & val )\n        {\n            val ^= pol;\n        }\n        bit >>= 1;\n        pol >>= 1;\n    }\n    return val;\n}\n\n//Verify the CRC\nstatic bool ENS210_IsCrcOk(uint32_t raw)\n{\n    uint32_t crc, data;\n\n    assert(raw <= 0xffffffUL);\n\n    //Extract 7-bit CRC(Bit-17 to Bit-23)\n    crc =  (raw >> 17) & 0x7F;\n\n    //Get the raw T/H and data valid indication.\n    data =  raw & 0x1ffff;\n\n    return ENS210_ComputeCRC7(data) == crc;\n}\n\n//Check the Data Valid Bit\nstatic bool ENS210_IsDataValid(uint32_t raw)\n{\n    assert(raw <= 0xffffffUL);\n\n    //Bit-16 is data valid bit. It will be set if data is valid\n    return (raw & (1UL << 16)) != 0;\n}\n\n//Convert raw temperature to Kelvin\n//The output value is in Kelvin multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToKelvin(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*K\n    //where m is the multiplier, R the raw value and K is temperature in Kelvin.\n    //K=R/64 (since raw has format 10.6).\n    //m*K =  m*R/64\n    return IDIV(t*multiplier, 64);\n}\n\n//Convert raw temperature to Celsius\n//The output value is in Celsius multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToCelsius(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*C\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use C=K-273.15 and K=R/64 (since raw has format 10.6).\n    //m*C = m*(K-273.15) = m*K - 27315*m/100 = m*R/64 - 27315*m/100\n\n    return IDIV(t*multiplier, 64) - IDIV(27315L*multiplier, 100);\n}\n\n//Convert raw temperature to Fahrenheit\n//The output value is in Fahrenheit multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToFahrenheit(uint32_t traw, int multiplier)\n{\n    int32_t t;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw temperature\n    t = traw & ENS210_T_H_MASK;\n\n    //Compensate for soldering effect\n    t-= ENS210_TRAW_SOLDERCORRECTION;\n\n    //We must compute and return m*F\n    //where m is the multiplier, R the raw value and K, C, F temperature in various units.\n    //We use F=1.8*(K-273.15)+32 and K=R/64 (since raw has format 10.6).\n\n    //m*F = m*(1.8*(K-273.15)+32) = m*(1.8*K-273.15*1.8+32) = 1.8*m*K-459.67*m = 9*m*K/5 - 45967*m/100 = 9*m*R/320 - 45967*m/100\n    return IDIV(9*multiplier*t, 320) - IDIV(45967L*multiplier, 100);\n\n    //The first multiplication stays below 32 bits (tRaw:16, multiplier:11, 9:4)\n    //The second  multiplication stays below 32 bits (multiplier:10, 45967:16)\n}\n\n//Convert raw relative humidity to readable format\n//The output value is in % multiplied by parameter \"multiplier\"\nstatic int32_t ENS210_ConvertRawToPercentageH(uint32_t hraw, int multiplier)\n{\n    int32_t h;\n\n    assert((1 <= multiplier) && (multiplier <= 1024));\n\n    //Get the raw relative humidity\n    h = hraw & ENS210_T_H_MASK;\n\n    //As raw format is 7.9, to obtain the relative humidity, it must be divided by 2^9\n    return IDIV(h*multiplier, 512);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n// wrap the low level function (I2C write, I2C read, WaitMsec) required by ENS210 driver\n// this function does not initialize the HW\nvoid ENS210_Init_Driver(ens210_IoFunc_t* pIoFunc){\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sENS210_Func = *pIoFunc;\n    initDriverDone = true;\n}\n\n// De-initialize the driver\nvoid ENS210_Deinit_Driver(){\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\n// Initialize ENS210 hardware\nens210_status_t ENS210_Init_Hw(void)\n{\n    ens210_status_t status = ens210_success;\n\n    if (!initDriverDone) return ens210_noinit;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    //Reset the sensor\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_RESET_ENABLE | ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_status;\n\n    //Wait for ENS210 to complete reset\n    sENS210_Func.WaitMsec(ENS210_RESET_WAIT_TIME_MS);\n\n    //Set the run mode of sensors\n    status = ENS210_SensRun_Set(ENS210_SENSRUN_T_MODE_SINGLE_SHOT | ENS210_SENSRUN_H_MODE_SINGLE_SHOT);\n    if (status != ens210_success) goto return_status;\n\n    return_status:\n    if (status != ens210_success) initHwDone = false;\n    return status;\n}\n\n//Set ENS210 SysCtrl register; enabling reset and/or low power\nens210_status_t ENS210_SysCtrl_Set(uint8_t sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL, sysCtrl};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sysCtrl & ~(ENS210_SYSCTRL_LOWPOWER_ENABLE | ENS210_SYSCTRL_RESET_ENABLE)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof (wBuf));\n}\n\n//Get ENS210 SysCtrl register\nens210_status_t ENS210_SysCtrl_Get(uint8_t *sysCtrl)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_CTRL};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysCtrl != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysCtrl, sizeof (*sysCtrl));\n}\n\n//Get ENS210 SysStat register.\nens210_status_t ENS210_SysStat_Get(uint8_t *sysStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SYS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sysStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof (wBuf), sysStat, sizeof (*sysStat));\n}\n\n//Set ENS210 SensRun register; set the run mode single shot/continuous for T and H sensors.\nens210_status_t ENS210_SensRun_Set(uint8_t sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN, sensRun};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensRun & ~(ENS210_SENSRUN_T_MODE_CONTINUOUS | ENS210_SENSRUN_H_MODE_CONTINUOUS)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensRun register\nens210_status_t ENS210_SensRun_Get(uint8_t *sensRun)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_RUN};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensRun != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensRun, sizeof *sensRun);\n}\n\n//Set ENS210 SensStart register; starts the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStart_Set(uint8_t sensStart)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_START, sensStart};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStart & ~(ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Set ENS210 SensStop register; stops the measurement for T and/or H sensors.\nens210_status_t ENS210_SensStop_Set(uint8_t sensStop)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STOP, sensStop};\n\n    if (!initHwDone) return ens210_noinit;\n    assert((sensStop & ~(ENS210_SENSSTOP_T_STOP | ENS210_SENSSTOP_H_STOP)) == 0);\n\n    return (ens210_status_t)sENS210_Func.I2C_Write(wBuf, sizeof wBuf);\n}\n\n//Get ENS210 SensStat register.\nens210_status_t ENS210_SensStat_Get(uint8_t *sensStat)\n{\n    uint8_t wBuf[] = {ENS210_REG_SENS_STAT};\n\n    if (!initHwDone) return ens210_noinit;\n    assert(sensStat != NULL);\n\n    return (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, sensStat, sizeof *sensStat);\n}\n\n//Get ENS210 TVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_TVal_Get(uint32_t *traw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(traw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n\n    return status;\n}\n\n//Get ENS210 HVal register; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_HVal_Get(uint32_t *hraw)\n{\n    uint8_t rBuf[3];\n    uint8_t wBuf[] = {ENS210_REG_H_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(hraw != NULL);\n\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *hraw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n\n    return status;\n}\n\n//Get ENS210 TVal and Hval registers; raw measurement data as well as CRC and valid indication\nens210_status_t ENS210_THVal_Get(uint32_t *traw, uint32_t *hraw)\n{\n    uint8_t rBuf[6];\n    uint8_t wBuf[] = {ENS210_REG_T_VAL};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert((traw != NULL) && (hraw != NULL));\n\n    // Read 6 bytes starting from ENS210_REG_T_VAL\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n\n    *traw = ((uint32_t)rBuf[2]) << 16 | ((uint32_t)rBuf[1]) << 8 | (uint32_t)rBuf[0];\n    *hraw = ((uint32_t)rBuf[5]) << 16 | ((uint32_t)rBuf[4]) << 8 | (uint32_t)rBuf[3];\n\n    return status;\n}\n\n// Get ENS210 Part ID and UID.\nens210_status_t ENS210_Ids_Get(ENS210_Ids_t *ids)\n{\n    uint8_t rBuf[12];\n    uint8_t wBuf[] = {ENS210_REG_PART_ID};\n    ens210_status_t status;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(ids != NULL);\n\n    // Special procedure needed to read ID's: put device in high power (see datasheet)\n    // Set the system in Active mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_DISABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Wait for sensor to go to active mode\n    sENS210_Func.WaitMsec(ENS210_BOOTING_TIME_MS);\n\n    // Get the id's\n    status = (ens210_status_t)sENS210_Func.I2C_Read(wBuf, sizeof wBuf, rBuf, sizeof rBuf);\n    if (status != ens210_success) goto return_error_status;\n\n    // Copy id's (hw gives partid in little-endian format)\n    ids->partId = ((uint32_t)rBuf[1]) << 8 | ((uint32_t)rBuf[0]) << 0;\n    memcpy(&ids->uId[0], &rBuf[4], 8);\n\n    // Go back to low power mode\n    status = ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    if (status != ens210_success) goto return_error_status;\n\n    // Signal success\n    return status;\n\n    return_error_status:\n    // Make an attempt to restore low-power\n    ENS210_SysCtrl_Set(ENS210_SYSCTRL_LOWPOWER_ENABLE);\n    // Return original I2C error\n    return status;\n}\n\nens210_status_t ENS210_Measure(uint8_t meas_mode, ens210_meas_data_t *results){\n    ens210_status_t status;\n    uint8_t meas_status;\n    uint32_t T_Raw = 0, H_Raw = 0;\n    uint32_t conversion_time_ms = 0;\n    uint8_t start_meas = 0;\n\n    if (!initHwDone) return ens210_noinit;\n    assert(results != NULL);\n\n    switch (meas_mode){\n    case mode_TH :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START | ENS210_SENSSTART_H_START;\n        break;\n    case mode_Tonly :\n        conversion_time_ms = ENS210_T_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_T_START;\n        break;\n    case mode_Honly :\n        conversion_time_ms = ENS210_T_H_CONVERSION_TIME_MS;\n        start_meas = ENS210_SENSSTART_H_START;\n        break;\n    default :\n        return ens210_wrong_parameter;\n        break;\n    }\n\n    //check that the previous measurement is completed\n    status = ENS210_SensStat_Get(&meas_status);\n    if (status != ens210_success){\n        return status;\n    }\n    if(meas_status != 0){\n        // trying to start a measurement too early!\n        sENS210_Func.WaitMsec(conversion_time_ms);\n    }\n\n    //Start the measurement\n    status = ENS210_SensStart_Set(start_meas);\n    if(status != ens210_success){\n        //Start of measurement failed.\n        return status;\n    }\n\n    // wait for the measurement to be completed\n    sENS210_Func.WaitMsec(conversion_time_ms);\n\n    if (meas_mode == mode_TH){\n        //Get the temperature and humidity raw value\n        status = ENS210_THVal_Get(&T_Raw, &H_Raw);\n    }\n    else if (meas_mode == mode_Tonly){\n        status = ENS210_TVal_Get(&T_Raw);\n    }\n    else if (meas_mode == mode_Honly){\n        status = ENS210_HVal_Get(&H_Raw);\n    }\n    if(status != ens210_success){\n        //Getting T and/or H values failed\n        return status;\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Tonly)){\n        // Verify the temperature raw value\n        if(!ENS210_IsCrcOk(T_Raw))    {\n            return ens210_Tdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(T_Raw)){\n            return ens210_T_invalid_data;\n        }\n        else {\n            //Convert the raw temperature value to Kelvin\n            results->T_Kelvin = ENS210_ConvertRawToKelvin(T_Raw, 1);\n            //Convert the raw temperature value to Celsius\n            results->T_Celsius = ENS210_ConvertRawToCelsius(T_Raw, 1);\n            //Convert the raw temperature value to Fahrenheit\n            results->T_Fahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1);\n            //Convert the raw temperature value to milli Kelvin\n            results->T_mKelvin = ENS210_ConvertRawToKelvin(T_Raw, 1000);\n            //Convert the raw temperature value to milli Celsius\n            results->T_mCelsius = ENS210_ConvertRawToCelsius(T_Raw, 1000);\n            //Convert the raw temperature value to milli Fahrenheit\n            results->T_mFahrenheit = ENS210_ConvertRawToFahrenheit(T_Raw, 1000);\n        }\n    }\n\n    if ((meas_mode == mode_TH) || (meas_mode == mode_Honly)){\n        //Verify the relative humidity raw value\n        if(!ENS210_IsCrcOk(H_Raw)){\n            return ens210_Hdata_CRC_error;\n        }\n        else if(!ENS210_IsDataValid(H_Raw)){\n            return ens210_H_invalid_data;\n        }\n        else {\n            //Convert the raw relative humidity to %\n            results->H_Percent = ENS210_ConvertRawToPercentageH(H_Raw, 1);\n            //Convert the raw relative humidity to milli%\n            results->H_mPercent = ENS210_ConvertRawToPercentageH(H_Raw, 1000);\n        }\n    }\n    return ens210_success;\n}\n"
              }
            }
          },
          "md5": "d97ca19d1cd700a109c7d89b10b1919b"
        },
        "ccs811": {
          "libName": "ccs811",
          "manufacturer": "AMS",
          "description": "Indoor Air Quality (IAQ) Sensor",
          "type": "Digital Gas Sensor",
          "icon": "",
          "image": "ccs811.jpg",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/short/j21j7h"
              },
              "cartData": {
                "part": "CCS811-LG_EK_ST-ND",
                "partid": "6568935",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "CCS811AirQuality",
              "type": "EmbeddedCCS811",
              "icon": "EmbeddedAirQuality.svg",
              "defaultAbility": "readTVOC",
              "defaultTrigger": "TVOCRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/amsccs811element.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "\tATMO_CCS811_Config_t config;\n\tconfig.operatingMode = ATMO_PROPERTY(undefined, operatingMode);\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_CCS811_Init(&config) == ATMO_CCS811_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_CCS811_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_CCS811_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readTVOC",
                  "triggers": [
                    "TVOCRead"
                  ],
                  "code": "    uint16_t tvoc;\n\n    if(ATMO_CCS811_GetTVOC(&tvoc) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueUnsignedInt(out, (unsigned int)tvoc);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n    \n    return ATMO_Status_Success;"
                },
                {
                  "name": "readCO2",
                  "triggers": [
                    "CO2Read"
                  ],
                  "code": "    uint16_t co2;\n    \n    if(ATMO_CCS811_GetCO2(&co2) == ATMO_CCS811_Status_Success)\n    {\n        ATMO_CreateValueInt(out, (int)co2);\n    }\n    else\n    {\n        ATMO_CreateValueVoid(out);\n    }\n  \n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x5A"
                },
                {
                  "name": "operatingMode",
                  "input": "number",
                  "value": "1"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedCCS811": "AMS CCS811",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "readTVOC": "Read TVOC (ppb)",
                  "readCO2": "Read CO2 (ppm)",
                  "TVOCRead": "TVOC Read",
                  "CO2Read": "CO2 Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "ccs811.h": "#ifndef _ATMO_CCS811_H_\r\n#define _ATMO_CCS811_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\n\r\ntypedef enum {\r\n    ATMO_CCS811_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_CCS811_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_CCS811_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_CCS811_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_CCS811_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_CCS811_Status_t;\r\n\r\ntypedef struct {\r\n\t//Mode 0 = Idle\r\n\t//Mode 1 = read every 1s\r\n\t//Mode 2 = every 10s\r\n\t//Mode 3 = every 60s\r\n\t//Mode 4 = RAW mode\r\n\tuint8_t operatingMode;\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_CCS811_Config_t;\r\n\r\n\r\n/**\r\n * Initialize CCS811 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable CCS811 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of CCS811 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config);\r\n\r\n/**\r\n * Set environmental data for more accurate readings\r\n *\r\n * @param[in] humidity - Pct from 0.0 to 100.0\r\n * @param[in] temperature - Degrees C\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnvironmentalData(float humidity, float temperature);\r\n\r\n/**\r\n * Get Total Volatile Organic Compounds (TVOC) Reading\r\n *\r\n * @param[out] tvoc - TVOC reading in PPB\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc);\r\n\r\n/**\r\n * Get total CO2 Reading in ppm\r\n *\r\n * @param[out] CO2\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2);\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality);\r\n\r\n\r\n#endif\r\n",
                "ccs811_internal.h": "/******************************************************************************\r\nDerivative Work of\r\nSparkFunCCS811.cpp\r\nCCS811 Arduino library\r\nMarshall Taylor @ SparkFun Electronics\r\nNathan Seidle @ SparkFun Electronics\r\nApril 4, 2017\r\nhttps://github.com/sparkfun/CCS811_Air_Quality_Breakout\r\nhttps://github.com/sparkfun/SparkFun_CCS811_Arduino_Library\r\nThis code is released under the [MIT License](http://opensource.org/licenses/MIT).\r\nPlease review the LICENSE.md file included with this example https://github.com/sparkfun/SparkFun_CCS811_Arduino_Library/blob/master/LICENSE.md .\r\nIf you have any questions or concerns with licensing, please contact techsupport@sparkfun.com.\r\nThe MIT License (MIT)\r\nCopyright (c) 2015 SparkFun Electronics\r\nCopyright (c) 2018 NXP\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\nDistributed as-is; no warranty is given.\r\n******************************************************************************/\r\n\r\n#ifndef CCS811_H_\r\n#define CCS811_H_\r\n\r\n/*!\r\n * @addtogroup ccs811 CCS811 air quality sensor\r\n * This module provides the API to control and monitor the CCS811 air quality sensor through an I2C interface.\r\n *\r\n * The basic steps to operate the CCS811 are as follows:\r\n * -# Initialize the driver with callback functions (#CCS811_Init_Driver)\r\n * -# Initialize the hardware (#CCS811_Init_Hw)\r\n * -# Check data availability (#CCS811_dataAvailable)\r\n * -# Trigger all data acquisition (#CCS811_readAlgorithmResults)\r\n * -# Read the relevant data (for example #CCS811_getCO2)\r\n * -# If the CCS811 is not needed anymore, de-initialize the driver (#CCS811_Deinit_Driver). The CCS811 will\r\n * be switched off. It allows to eventually release shared resources.\r\n *\r\n * Example - Sample application code to set CCS811 without error management\r\n * ------------------------------------------------------------------------\r\n * @code\r\n * \\#include \"CCS811.h\"\r\n *\r\n * CCS811_fct_t ccs811_fct;\r\n * uint8_t ready;\r\n * uint16_t uCO2;\r\n *\r\n * ccs811_fct.connect_hw = Ccs811_Connect;       // callback function to activate CCS811 hardware resource\r\n * ccs811_fct.disconnect_hw = Ccs811_Disconnect; // callback function to deactivate CCS811 hardware resource\r\n * ccs811_fct.I2C_Read = I2c_Read;               // callback function for I2C read\r\n * ccs811_fct.I2C_Write = I2c_Write;             // callback function for I2C write\r\n * ccs811_fct.WaitMsec = WaitMs;                 // wait callback function (in ms)\r\n *\r\n * CCS811_Init_Driver(&ccs811_fct);\r\n * CCS811_Init_Hw();\r\n * // check new data availability\r\n * CCS811_dataAvailable(&ready);\r\n * if (ready == 1) {\r\n *     CCS811_readAlgorithmResults();\r\n *     uCO2 = CCS811_getCO2();\r\n *     printf(\"The current CO2 value is: %d\\n\", uCO2);\r\n * }\r\n * [..]\r\n * // if the CCS811 is not needed anymore, the driver can be de-initialized\r\n * printf(\"Deinitialize CCS811 (it will be turned off)\\n\");\r\n * CCS811_Deinit_Driver();\r\n *\r\n * @endcode\r\n * @{\r\n */\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include <stdbool.h>\r\n\r\n#define CCS811_I2C_ADDRESS              0x5A\r\n\r\n/* Register addresses */\r\n#define CCS811_STATUS                   0x00\r\n#define CCS811_MEAS_MODE                0x01\r\n#define CCS811_ALG_RESULT_DATA          0x02\r\n#define CCS811_RAW_DATA                 0x03\r\n#define CCS811_ENV_DATA                 0x05\r\n#define CCS811_NTC                      0x06\r\n#define CCS811_THRESHOLDS               0x10\r\n#define CCS811_BASELINE                 0x11\r\n#define CCS811_HW_ID                    0x20\r\n#define CCS811_HW_VERSION               0x21\r\n#define CCS811_FW_BOOT_VERSION          0x23\r\n#define CCS811_FW_APP_VERSION           0x24\r\n#define CCS811_ERROR_ID                 0xE0\r\n#define CCS811_APP_START                0xF4\r\n#define CCS811_SW_RESET                 0xFF\r\n#define CCS811_INTERRUPT_DRIVEN         0x8\r\n#define CCS811_THRESHOLDS_ENABLED       0x4\r\n\r\n/*! @brief Status return codes. */\r\ntypedef enum _CCS811_status\r\n{\r\n    CCS811_SUCCESS,        /*!< Success */\r\n    CCS811_ID_ERROR,       /*!< Bad hardware identifier */\r\n    CCS811_I2C_ERROR,      /*!< I2C read/write error */\r\n    CCS811_INTERNAL_ERROR, /*!< Internal hardware error */\r\n    CCS811_NOINIT_ERROR,   /*!< Hardware or driver not initialized */\r\n    CCS811_GENERIC_ERROR   /*!< Generic error (settings not allowed) */\r\n} CCS811_status;\r\n\r\n/*! @brief Structure of external functions or values. */\r\ntypedef struct _CCS811_fct_t\r\n{\r\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize); /*!< External I2C read function */\r\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize); /*!< External I2C write function */\r\n    void (*WaitMsec)(uint32_t tms); /*!< Wait function in milliseconds */\r\n} CCS811_fct_t, *ptCCS811_fct_t;\r\n\r\n/*!\r\n * @brief Initialize CCS811 driver.\r\n *\r\n * @param FCT Pointer to a structure of external functions or values\r\n */\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT);\r\n\r\n/*!\r\n * @brief De-initialize CCS811 driver.\r\n *\r\n */\r\nvoid CCS811_Deinit_Driver();\r\n\r\n/*!\r\n * @brief Initialize CCS811 hardware.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_Init_Hw(void);\r\n\r\n/*!\r\n * @brief Read algorithm results.\r\n * @note Update the total volatile organic compounds (TVOC) in parts per billion (PPB) and the CO2 value.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readAlgorithmResults(void);\r\n\r\n/*!\r\n * @brief Check if error bit is set.\r\n *\r\n * @param  StatusError Pointer to error status bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError);\r\n\r\n/*!\r\n * @brief Check if data is available.\r\n * @note Based on DATA_READ flag in the status register.\r\n *\r\n * @param  value Pointer to available data bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_dataAvailable(uint8_t* value);\r\n\r\n/*!\r\n * @brief Check if APP_VALID is set.\r\n * @note Based on APP_VALID flag in the status register.\r\n *\r\n * @param  value Pointer to APP_VALID bit value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_appValid(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the error register value.\r\n * @note Based on ERROR_ID register.\r\n *\r\n * @param  value Pointer to error value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value);\r\n\r\n/*!\r\n * @brief Get the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  baseline Pointer to baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline);\r\n\r\n/*!\r\n * @brief Set the baseline value.\r\n * @note It is used for telling sensor what 'clean' air is.\r\n * @note Put the sensor in clean air and record this value.\r\n *\r\n * @param  input Baseline value\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setBaseline(uint16_t input);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupts.\r\n * @note It clears/sets the nINT signal.\r\n *\r\n * @param  fct Interrupt mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setInterrupts(uint8_t fct);\r\n\r\n/*!\r\n * @brief Enable or disable the interrupt thresholds.\r\n *\r\n * @param  fct Threshold mode (0 for disable, 1 for enable)\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setThresholds(uint8_t fct);\r\n\r\n/*!\r\n * @brief Set the drive mode.\r\n * @note\r\n * Mode 0 = Idle\\n\r\n * Mode 1 = read every 1s\\n\r\n * Mode 2 = every 10s\\n\r\n * Mode 3 = every 60s\\n\r\n * Mode 4 = RAW mode\r\n *\r\n * @param  mode Drive mode\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setDriveMode(uint8_t mode);\r\n\r\n/*!\r\n * @brief Set environmental data.\r\n * @note\r\n * Given a temperature and humidity, use these data for better compensation.\r\n *\r\n * @param  relativeHumidity Relative humidity, value within [0,100]\r\n * @param  temperature Temperature (Celsius), value within [-25,+50]\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature);\r\n\r\n/*!\r\n * @brief Set ref resistance.\r\n *\r\n * @param  input Ref resistance\r\n */\r\nvoid CCS811_setRefResistance(float input);\r\n\r\n/*!\r\n * @brief Read NTC.\r\n *\r\n * @return Status value (0 for success)\r\n */\r\nCCS811_status CCS811_readNTC(void);\r\n\r\n/*!\r\n * @brief Get Total Volatile Organic Compound (TVOC) value.\r\n *\r\n * @return TVOC value (0ppb to 1187ppb)\r\n */\r\nuint16_t CCS811_getTVOC(void);\r\n\r\n/*!\r\n * @brief Get the equivalent CO2 value.\r\n *\r\n * @return eCO2 value (400ppm to 8192ppm)\r\n */\r\nuint16_t CCS811_getCO2(void);\r\n\r\n/*!\r\n * @brief Get resistance value.\r\n *\r\n * @return Resistance value\r\n */\r\nfloat CCS811_getResistance(void);\r\n\r\n/*!\r\n * @brief Get temperature value.\r\n *\r\n * @return Temperature value (Celsius)\r\n */\r\nfloat CCS811_getTemperature(void);\r\n\r\n/*! @}*/\r\n\r\n#endif /* CCS811_H_ */\r\n"
              },
              "objects": {
                "ccs811.c": "#include \"ccs811.h\"\r\n#include \"ccs811_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n#define CCS811_TVOC_MAX_PPB (1187)\r\n\r\n\r\ntypedef struct {\r\n    ATMO_CCS811_Config_t config;\r\n    bool configured;\r\n} ATMO_CCS811_Priv_Config;\r\n\r\nstatic ATMO_CCS811_Priv_Config _ATMO_CCS811_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool _ATMO_CCS811_Enabled = true;\r\n\r\nstatic uint8_t ATMO_CCS811_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t ATMO_CCS811_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_CCS811_config.config.i2cDriverInstance, _ATMO_CCS811_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_Init(ATMO_CCS811_Config_t *config)\r\n{\r\n\r\n    CCS811_fct_t io;\r\n    io.I2C_Read = ATMO_CCS811_I2CRead_Simple;\r\n    io.I2C_Write = ATMO_CCS811_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    CCS811_Init_Driver(&io);\r\n\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n        _ATMO_CCS811_config.configured = false;\r\n    }\r\n\r\n    if( CCS811_Init_Hw() != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    // The configuration has to be set before the Init_HW routine is called\r\n    // But the Init_HW routine resets the device\r\n    // So, we need to just set the configuration one more time after this reset\r\n    if( config )\r\n    {\r\n        ATMO_CCS811_SetConfiguration(config);\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetEnabled(bool enabled)\r\n{\r\n    _ATMO_CCS811_Enabled = enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = _ATMO_CCS811_Enabled;\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_SetConfiguration(const ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    memcpy( &_ATMO_CCS811_config.config, config, sizeof(ATMO_CCS811_Config_t) );\r\n    _ATMO_CCS811_config.configured = true;\r\n\r\n    if( CCS811_setDriveMode(config->operatingMode) != CCS811_SUCCESS )\r\n    {\r\n    \treturn ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetConfiguration(ATMO_CCS811_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_CCS811_config.configured )\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_CCS811_config.config, sizeof(ATMO_CCS811_Config_t));\r\n\r\n    return ATMO_CCS811_Status_Success;\r\n}\r\n\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetTVOC(uint16_t *tvoc)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*tvoc = CCS811_getTVOC();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\nATMO_CCS811_Status_t ATMO_CCS811_GetCO2(uint16_t *co2)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n\r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*co2 = CCS811_getCO2();\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n\r\n/**\r\n * Get air quality in percentage based on TVOC reading\r\n *\r\n * @param[out] airQuality\r\n */\r\nATMO_CCS811_Status_t ATMO_CCS811_GetAirQuality(float *airQuality)\r\n{\r\n    if(!_ATMO_CCS811_Enabled)\r\n    {\r\n        return ATMO_CCS811_Status_Fail;\r\n    }\r\n    \r\n\tif( CCS811_readAlgorithmResults() != CCS811_SUCCESS )\r\n\t{\r\n\t\treturn ATMO_CCS811_Status_Fail;\r\n\t}\r\n\r\n\t*airQuality = (CCS811_getTVOC() * 100.0) / CCS811_TVOC_MAX_PPB;\r\n\r\n\treturn ATMO_CCS811_Status_Success;\r\n}\r\n",
                "ccs811_internal.c": "/******************************************************************************\r\nDerivative Work of\r\nSparkFunCCS811.cpp\r\nCCS811 Arduino library\r\nMarshall Taylor @ SparkFun Electronics\r\nNathan Seidle @ SparkFun Electronics\r\n\r\nApril 4, 2017\r\n\r\nhttps://github.com/sparkfun/CCS811_Air_Quality_Breakout\r\nhttps://github.com/sparkfun/SparkFun_CCS811_Arduino_Library\r\n\r\nThis code is released under the [MIT License](http://opensource.org/licenses/MIT).\r\n\r\nPlease review the LICENSE.md file included with this example https://github.com/sparkfun/SparkFun_CCS811_Arduino_Library/blob/master/LICENSE.md .\r\nIf you have any questions or concerns with licensing, please contact techsupport@sparkfun.com.\r\n\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2015 SparkFun Electronics\r\nCopyright (c) 2018 NXP\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\r\nto deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\nand/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\nDistributed as-is; no warranty is given.\r\n******************************************************************************/\r\n\r\n//CCS811.h for additional topology notes.\r\n\r\n#include \"ccs811_internal.h\"\r\n#include <math.h>\r\n#include <stdbool.h>\r\n#include <assert.h>\r\n\r\n/*****************************************************************************\r\n * Variables\r\n ****************************************************************************/\r\nstatic CCS811_fct_t FCT_CCS811;\r\nstatic bool initDriverDone = false;\r\nstatic bool initHwDone = false;\r\n\r\n/* air quality values obtained from the sensor */\r\nstatic float refResistance;\r\nstatic float resistance = 10000;\r\nstatic uint16_t tVOC = 0;\r\nstatic uint16_t CO2 = 0;\r\nstatic uint16_t vrefCounts = 0;\r\nstatic uint16_t ntcCounts = 0;\r\nstatic float temperature = 0;\r\n\r\n/*****************************************************************************\r\n * Static functions\r\n ****************************************************************************/\r\n\r\n/*\r\n * @brief Read a CCS811 register.\r\n *\r\n * @param  Address of the register to read\r\n * @param  Pointer to the read value\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_readRegister(uint8_t offset, uint8_t* outputPointer)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, 1);\r\n}\r\n\r\n/*\r\n * @brief Read several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to read\r\n * @param  Pointer to the read values\r\n * @param  Number of consecutive registers to read\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiReadRegister(uint8_t offset, uint8_t *outputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    return FCT_CCS811.I2C_Read(cmd, 1, outputPointer, length);\r\n}\r\n\r\n/*\r\n * @brief Write to a CCS811 register.\r\n *\r\n * @param  Address of the register to write to\r\n * @param  Value to write\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_writeRegister(uint8_t offset, uint8_t dataToWrite)\r\n{\r\n\r\n    uint8_t cmd[2];\r\n\r\n    cmd[0] = offset;\r\n    cmd[1] = dataToWrite;\r\n\r\n    return FCT_CCS811.I2C_Write(cmd, 2);\r\n}\r\n\r\n/*\r\n * @brief Write to several CCS811 registers.\r\n *\r\n * @param  Start address of the registers to write to\r\n * @param  Pointer to the values to be written\r\n * @param  Number of consecutive registers to write to\r\n * @return Status value of I2C read function (0 for success)\r\n */\r\nstatic uint8_t CCS811_multiWriteRegister(uint8_t offset, uint8_t *inputPointer, uint8_t length)\r\n{\r\n    uint8_t cmd[length+1];\r\n    cmd[0] = offset;\r\n    for( uint32_t i = 0; i < length; i++ ) //This waits > 1ms @ 80MHz clock\r\n    {\r\n        cmd[1+i] = inputPointer[i];\r\n    }\r\n    return FCT_CCS811.I2C_Write(cmd, length+1);\r\n}\r\n\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\nvoid CCS811_Init_Driver(ptCCS811_fct_t FCT)\r\n{\r\n    assert((FCT != NULL) &&\r\n            (FCT->I2C_Read != NULL) &&\r\n            (FCT->I2C_Write != NULL) &&\r\n            (FCT->WaitMsec != NULL));\r\n    FCT_CCS811 = *FCT;\r\n    initDriverDone = true;\r\n}\r\n\r\nvoid CCS811_Deinit_Driver()\r\n{\r\n    /* Deinit driver */\r\n    initDriverDone = false;\r\n    initHwDone = false;\r\n}\r\n\r\nCCS811_status CCS811_Init_Hw(void)\r\n{\r\n    uint8_t data[4] = {0x11,0xE5,0x72,0x8A}; /* reset key */\r\n    uint8_t status;\r\n    uint8_t val = 0;\r\n    CCS811_status error_status = CCS811_SUCCESS;\r\n\r\n    if (!initDriverDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* trick to allow calling internal public functions */\r\n    initHwDone = true;\r\n\r\n    /* check HW ID */\r\n    if (CCS811_readRegister( CCS811_HW_ID,  &val) != 0)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (val != 0x81)\r\n    {\r\n        error_status = CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* reset the device */\r\n    if (CCS811_multiWriteRegister(CCS811_SW_RESET, data, 4)!=0)\r\n    {\r\n        error_status =  CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    FCT_CCS811.WaitMsec(10);\r\n\r\n    if (CCS811_checkForStatusError(&status) == CCS811_I2C_ERROR)\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n    if (status == true) return CCS811_INTERNAL_ERROR;\r\n\r\n    error_status = CCS811_appValid(&val);\r\n    if (error_status != CCS811_SUCCESS) goto return_status;\r\n    if (val == 0)\r\n    {\r\n        error_status =  CCS811_INTERNAL_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* write 0 byte to this register to start app */\r\n    //if (CCS811_writeRegister(CCS811_APP_START, 0)!=0) return CCS811_I2C_ERROR;\r\n    val = CCS811_APP_START;\r\n    if (FCT_CCS811.I2C_Write(&val, 1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    /* read every second */\r\n    if (CCS811_setDriveMode(1))\r\n    {\r\n        error_status = CCS811_I2C_ERROR;\r\n        goto return_status;\r\n    }\r\n\r\n    return_status:\r\n    if (error_status != CCS811_SUCCESS) initHwDone = false;\r\n    return error_status;\r\n}\r\n\r\nCCS811_status CCS811_readAlgorithmResults(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_ALG_RESULT_DATA, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    /* data ordered: co2MSB, co2LSB, tvocMSB, tvocLSB */\r\n    CO2 = ((uint16_t)data[0] << 8) | data[1];\r\n    tVOC = ((uint16_t)data[2] << 8) | data[3];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_checkForStatusError(uint8_t* StatusError)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(StatusError != NULL);\r\n\r\n    /* read the status bit */\r\n    if (CCS811_readRegister(CCS811_STATUS, StatusError )!=0) return CCS811_I2C_ERROR;\r\n    *StatusError = *StatusError & 1 << 0; // bit ERROR\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_dataAvailable(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 3)>>3; // bit DATA_READY\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_appValid(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    if (CCS811_readRegister(CCS811_STATUS, value )!=0) return CCS811_I2C_ERROR;\r\n    *value = (*value &  1 << 4)>>4; // bit APP_VALID\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getErrorRegister(uint8_t* value)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(value != NULL);\r\n\r\n    *value=0xFF;\r\n    if (CCS811_readRegister(CCS811_ERROR_ID, value )!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_getBaseline(unsigned int* baseline)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n    assert(baseline != NULL);\r\n\r\n    uint8_t data[2];\r\n    if (CCS811_multiReadRegister(CCS811_BASELINE,data, 2)!=0) return CCS811_I2C_ERROR;\r\n\r\n    *baseline = ((uint16_t)data[0] << 8) | data[1];\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setBaseline(uint16_t input)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[2];\r\n    data[0] = (input >> 8) & 0x00FF;\r\n    data[1] = input & 0x00FF;\r\n\r\n    if (CCS811_multiWriteRegister(CCS811_BASELINE, data, 2)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setInterrupts(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_INTERRUPT_DRIVEN); /* clear INTERRUPT bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_INTERRUPT_DRIVEN); /* set INTERRUPT bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setThresholds(uint8_t fct)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value )!=0) return CCS811_I2C_ERROR;\r\n    if (fct == 0)\r\n    {\r\n        value &= ~(CCS811_THRESHOLDS_ENABLED); /* clear THRESHOLDS bit */\r\n    }\r\n    else\r\n    {\r\n        value |= (CCS811_THRESHOLDS_ENABLED); /* set THRESHOLDS bit */\r\n    }\r\n\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setDriveMode(uint8_t mode)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    if (mode > 4) mode = 4; /* sanitize input */\r\n\r\n    uint8_t value;\r\n    if (CCS811_readRegister(CCS811_MEAS_MODE, &value)!=0) return CCS811_I2C_ERROR;\r\n    value &= ~(0b00000111 << 4); /* clear DRIVE_MODE bits */\r\n    value |= (mode << 4); /* mask in mode */\r\n    if (CCS811_writeRegister(CCS811_MEAS_MODE, value)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nCCS811_status CCS811_setEnvironmentalData(float relativeHumidity, float temperature)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    /* check for invalid temperatures */\r\n    if ((temperature < -25) || (temperature > 50)) return CCS811_GENERIC_ERROR;\r\n\r\n    /* check for invalid humidity */\r\n    if ((relativeHumidity < 0) || (relativeHumidity > 100)) return CCS811_GENERIC_ERROR;\r\n\r\n    uint32_t rH = relativeHumidity * 1000; /* 42.348 becomes 42348 */\r\n    uint32_t temp = temperature * 1000; /* 23.2 becomes 23200 */\r\n\r\n    uint8_t envData[4];\r\n\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[0] = ((rH % 1000) / 100) > 7 ? (rH / 1000 + 1) << 1 : (rH / 1000) << 1;\r\n    envData[1] = 0; /* support only increments of 0.5 so bits 7-0 will always be zero */\r\n    if (((rH % 1000) / 100) > 2 && (((rH % 1000) / 100) < 8))\r\n    {\r\n        envData[0] |= 1; /* set 9th bit of fractional to indicate 0.5% */\r\n    }\r\n\r\n    temp += 25000; /* add the 25C offset */\r\n    /* split value into 7-bit integer and 9-bit fractional */\r\n    envData[2] = ((temp % 1000) / 100) > 7 ? (temp / 1000 + 1) << 1 : (temp / 1000) << 1;\r\n    envData[3] = 0;\r\n    if (((temp % 1000) / 100) > 2 && (((temp % 1000) / 100) < 8))\r\n    {\r\n        envData[2] |= 1;  /* set 9th bit of fractional to indicate 0.5C */\r\n    }\r\n    if (CCS811_multiWriteRegister(CCS811_ENV_DATA, envData, 4)!=0) return CCS811_I2C_ERROR;\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nvoid CCS811_setRefResistance(float input)\r\n{\r\n    refResistance = input;\r\n}\r\n\r\nCCS811_status CCS811_readNTC(void)\r\n{\r\n    if (!initHwDone) return CCS811_NOINIT_ERROR;\r\n\r\n    uint8_t data[4];\r\n    if (CCS811_multiReadRegister(CCS811_NTC, data, 4)!=0) return CCS811_I2C_ERROR;\r\n\r\n    vrefCounts = ((uint16_t)data[0] << 8) | data[1];\r\n    ntcCounts = ((uint16_t)data[2] << 8) | data[3];\r\n    resistance = ((float)ntcCounts * refResistance / (float)vrefCounts);\r\n\r\n    temperature = log((long)resistance);\r\n    temperature = 1 / (0.001129148 + (0.000234125 * temperature) + (0.0000000876741 * temperature * temperature * temperature));\r\n    temperature = temperature - 273.15;  /* convert from Kelvin to Celsius */\r\n\r\n    return CCS811_SUCCESS;\r\n}\r\n\r\nuint16_t CCS811_getTVOC(void)\r\n{\r\n    return tVOC;\r\n}\r\n\r\nuint16_t CCS811_getCO2(void)\r\n{\r\n    return CO2;\r\n}\r\n\r\nfloat CCS811_getResistance(void)\r\n{\r\n    return resistance;\r\n}\r\n\r\nfloat CCS811_getTemperature(void)\r\n{\r\n    return temperature;\r\n}\r\n\r\n"
              }
            }
          },
          "md5": "37d6cc21798c08dddea5c64100300931"
        },
        "fxos8700": {
          "libName": "fxos8700",
          "manufacturer": "NXP Semiconductors",
          "description": "FXOS8700 Accelerometer/Magnetometer",
          "type": "Accelerometer + Magnetometer",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/adafruit-industries-llc/3463/1528-2130-ND/7064490"
              },
              "cartData": {
                "part": " 1528-2130-ND",
                "partid": "3463",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "gpio"
          ],
          "elements": [
            {
              "name": "FXOS8700AccelerometerMagnetometer",
              "type": "EmbeddedFXOS8700",
              "icon": "EmbeddedAccelerometerMagnetometer.svg",
              "defaultAbility": "getAccelData",
              "defaultTrigger": "accelDataRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/nxpfxos8700element.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "hidden": true,
                  "code": "\tATMO_FXOS8700_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.int1En = ATMO_PROPERTY(undefined, interrupt1Enabled);\n    config.int2En = ATMO_PROPERTY(undefined, interrupt2Enabled);\n    config.int1Pin = ATMO_PROPERTY(undefined, interrupt1Gpio);\n    config.int2Pin = ATMO_PROPERTY(undefined, interrupt2Gpio);\n\n    switch(ATMO_PROPERTY(undefined, motionDetectType))\n    {\n        case FXOS8700_NoDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_FreefallDetect:\n        {\n            config.freefallEnabled = true;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_MotionDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = true;\n            config.tapDetectionEnabled = false;\n            break;\n        }\n        case FXOS8700_TapDetect:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;\n            config.tapDetectionEnabled = true;\n            break; \n        }\n        default:\n        {\n            config.freefallEnabled = false;\n            config.motionEnabled = false;  \n            config.tapDetectionEnabled = false;\n            break;\n        }\n    }\n\n    ATMO_FXOS8700_SetMotionDetectedAbilityHandle(ATMO_ABILITY(undefined, detectMotion));\n    ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(ATMO_ABILITY(undefined, detectFreefall));\n    ATMO_FXOS8700_SetTapDetectedAbilityHandle(ATMO_ABILITY(undefined, detectTap));\n\tATMO_FXOS8700_Init(&config);\n\n    return ATMO_Status_Success;\n\t"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_FXOS8700_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_FXOS8700_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_FXOS8700_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "getAccelData",
                  "triggers": [
                    "accelDataRead"
                  ],
                  "code": "    ATMO_3dFloatVector_t data;\r\n\r\n    if( ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success )\r\n    {\r\n        ATMO_CreateValueVoid(out);\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &data);\r\n\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "getAccelX",
                  "triggers": [
                    "accelXRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.x);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getAccelY",
                  "triggers": [
                    "accelYRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.y);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getAccelZ",
                  "triggers": [
                    "accelZRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetAccelData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.z);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getMagData",
                  "triggers": [
                    "magDataRead"
                  ],
                  "code": "    ATMO_3dFloatVector_t data;\r\n\r\n    if( ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success )\r\n    {\r\n        ATMO_CreateValueVoid(out);\r\n        return ATMO_Status_Fail;\r\n    }\r\n\r\n    ATMO_CreateValue3dVectorFloat(out, &data);\r\n\r\n    return ATMO_Status_Success;"
                },
                {
                  "name": "getMagX",
                  "triggers": [
                    "magXRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.x);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getMagY",
                  "triggers": [
                    "magYRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.y);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getMagZ",
                  "triggers": [
                    "magZRead"
                  ],
                  "code": "\tATMO_3dFloatVector_t data;\n\n\tif(ATMO_FXOS8700_GetMagData(&data) != ATMO_FXOS8700_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.z);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "detectTap",
                  "triggers": [
                    "tapDetected"
                  ],
                  "hidden": true,
                  "code": "\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "detectMotion",
                  "triggers": [
                    "motionDetected"
                  ],
                  "hidden": true,
                  "code": "\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "detectFreefall",
                  "triggers": [
                    "freefallDetected"
                  ],
                  "hidden": true,
                  "code": "\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "enableFreefallDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_EnableFreefallDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                },
                {
                  "name": "enableMotionDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_EnableMotionDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                },
                {
                  "name": "enableTapDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_EnableTapDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                },
                {
                  "name": "disableDetection",
                  "triggers": [],
                  "code": "if(ATMO_FXOS8700_DisableAllDetection() == ATMO_FXOS8700_Status_Success)\n{\n    return ATMO_Status_Success;\n}\n\nreturn ATMO_Status_Fail;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interrupt1Enabled",
                  "input": "checkbox",
                  "value": false
                },
                {
                  "name": "interrupt2Enabled",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "interrupt1Gpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interrupt2Gpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "motionDetectType",
                  "input": "select",
                  "inputOptions": [
                    "FXOS8700_NoDetect",
                    "FXOS8700_FreefallDetect",
                    "FXOS8700_MotionDetect",
                    "FXOS8700_TapDetect"
                  ],
                  "value": "FXOS8700_NoDetect"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x1E"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedFXOS8700": "NXP FXOS8700",
                  "FXOS8700_NoDetect": "No Detection",
                  "FXOS8700_FreefallDetect": "Detect Freefall",
                  "FXOS8700_MotionDetect": "Detect Motion",
                  "FXOS8700_TapDetect": "Detect Tap",
                  "motionDetectType": "Motion Detection Type",
                  "i2cInstance": "I2C Driver Instance",
                  "gpioInstance": "GPIO Driver Instance",
                  "interrupt1Enabled": "Interrupt 1 Enabled",
                  "interrupt1Gpio": "Interrupt 1 GPIO Pin",
                  "interrupt2Enabled": "Interrupt 2 Enabled",
                  "interrupt2Gpio": "Interrupt 2 GPIO Pin",
                  "tapDetectEnabled": "Tap Detection Enabled",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "getAccelData": "Get Accelerometer Data",
                  "accelDataRead": "Accelerometer Data Read",
                  "getMagData": "Get Magnetometer Data",
                  "magDataRead": "Magnetometer Data Read",
                  "detectTap": "Detect Tap",
                  "detectMotionFreefall": "Detect Motion/Freefall",
                  "tapDetected": "Tap Detected",
                  "motionDetected": "Motion Detected",
                  "freefallDetected": "Freefall Detected",
                  "EmbeddedAccelerometerMagnetometer": "Accelerometer Magnetometer",
                  "getAccelX": "Get Accelerometer X Value",
                  "getAccelY": "Get Accelerometer Y Value",
                  "getAccelZ": "Get Accelerometer Z Value",
                  "getMagX": "Get Magnetometer X Value",
                  "getMagY": "Get Magnetometer Y Value",
                  "getMagZ": "Get Magnetometer Z Value",
                  "accelXRead": "Accelerometer X Value Read",
                  "accelYRead": "Accelerometer Y Value Read",
                  "accelZRead": "Accelerometer Z Value Read",
                  "magXRead": "Magnetometer X Value Read",
                  "magYRead": "Magnetometer Y Value Read",
                  "magZRead": "Magnetometer Z Value Read",
                  "disableDetection": "Disable All Detection",
                  "enableFreefallDetection": "Enable Freefall Detection",
                  "enableMotionDetection": "Enable Motion Detection",
                  "enableTapDetection": "Enable Tap Detection"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "fxos8700.h": "#ifndef _ATMO_FXOS8700_H_\n#define _ATMO_FXOS8700_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n#include \"../gpio/gpio.h\"\n\ntypedef enum {\n    ATMO_FXOS8700_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_FXOS8700_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_FXOS8700_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_FXOS8700_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_FXOS8700_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_FXOS8700_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    ATMO_DriverInstanceHandle_t gpioDriverInstance;\n    bool int1En;\n    ATMO_GPIO_Device_Pin_t int1Pin;\n    bool int2En;\n    ATMO_GPIO_Device_Pin_t int2Pin;\n    bool motionEnabled;\n    bool freefallEnabled;\n    bool tapDetectionEnabled;\n\n} ATMO_FXOS8700_Config_t;\n\ntypedef enum {\n\tFXOS8700_NoDetect,\n\tFXOS8700_FreefallDetect,\n\tFXOS8700_MotionDetect,\n    FXOS8700_TapDetect,\n} FXOS8700_Detect_t;\n\n/**\n * Initialize FXOS8700 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_Init(ATMO_FXOS8700_Config_t *config);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetConfiguration(const ATMO_FXOS8700_Config_t *config);\n\n/**\n * Enable/Disable FXOS8700 Driver\n *\n * @param[in] enabled\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of FXOS8700 driver\n *\n * @param[out] enabled\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetEnabled(bool *enabled);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetConfiguration(ATMO_FXOS8700_Config_t *config);\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetAccelData(ATMO_3dFloatVector_t *data);\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetMagData(ATMO_3dFloatVector_t *data);\n\n/**\n * Motion/Freefall detection\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedCallback(ATMO_Callback_t cb);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedCallback(ATMO_Callback_t cb);\n\n/**\n * Tap detection\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_IsTapDetected(bool *isTapDetected, bool *isDoubleTap);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedCallback(ATMO_Callback_t cb);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedAbilityHandle(unsigned int abilityHandle);\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedCallback(ATMO_Callback_t cb);\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableFreefallDetection();\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableMotionDetection();\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableTapDetection();\nATMO_FXOS8700_Status_t ATMO_FXOS8700_DisableAllDetection();\n\n#endif\n",
                "fxos8700_internal.h": "/*\n * The Clear BSD License\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\n * Copyright 2016-2017 NXP\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided\n * that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n#ifndef _FSL_FXOS_H_\n#define _FSL_FXOS_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n#define EN_FFMT_INTERRUPT\n#define EN_TAP_INTERRUPT\n\n\n#define SINGLE_TAP 1\n#define DOUBLE_TAP 1\n/*\n *  STATUS Register\n */\n#define FXOS8700_STATUS_00_REG 0x00\n            \n#define FXOS8700_ZYXOW_MASK 0x80\n#define FXOS8700_ZOW_MASK 0x40\n#define FXOS8700_YOW_MASK 0x20\n#define FXOS8700_XOW_MASK 0x10\n#define FXOS8700_ZYXDR_MASK 0x08\n#define FXOS8700_ZDR_MASK 0x04\n#define FXOS8700_YDR_MASK 0x02\n#define FXOS8700_XDR_MASK 0x01\n            \n/*          \n *  F_STATUS FIFO Status Register\n */         \n#define FXOS8700_F_STATUS_REG 0x00\n            \n#define FXOS8700_F_OVF_MASK 0x80\n#define FXOS8700_F_WMRK_FLAG_MASK 0x40\n#define FXOS8700_F_CNT5_MASK 0x20\n#define FXOS8700_F_CNT4_MASK 0x10\n#define FXOS8700_F_CNT3_MASK 0x08\n#define FXOS8700_F_CNT2_MASK 0x04\n#define FXOS8700_F_CNT1_MASK 0x02\n#define FXOS8700_F_CNT0_MASK 0x01\n#define FXOS8700_F_CNT_MASK 0x3F\n            \n/*          \n *  XYZ Data Registers\n */         \n#define FXOS8700_OUT_X_MSB_REG 0x01\n#define FXOS8700_OUT_X_LSB_REG 0x02\n#define FXOS8700_OUT_Y_MSB_REG 0x03\n#define FXOS8700_OUT_Y_LSB_REG 0x04\n#define FXOS8700_OUT_Z_MSB_REG 0x05\n#define FXOS8700_OUT_Z_LSB_REG 0x06\n            \n/*          \n *  F_SETUP FIFO Setup Register\n */         \n#define FXOS8700_F_SETUP_REG 0x09\n            \n#define FXOS8700_F_MODE1_MASK 0x80\n#define FXOS8700_F_MODE0_MASK 0x40\n#define FXOS8700_F_WMRK5_MASK 0x20\n#define FXOS8700_F_WMRK4_MASK 0x10\n#define FXOS8700_F_WMRK3_MASK 0x08\n#define FXOS8700_F_WMRK2_MASK 0x04\n#define FXOS8700_F_WMRK1_MASK 0x02\n#define FXOS8700_F_WMRK0_MASK 0x01\n#define FXOS8700_F_MODE_MASK 0xC0\n#define FXOS8700_F_WMRK_MASK 0x3F\n            \n#define FXOS8700_F_MODE_DISABLED 0x00\n#define FXOS8700_F_MODE_CIRCULAR (F_MODE0_MASK)\n#define FXOS8700_F_MODE_FILL (F_MODE1_MASK)\n#define FXOS8700_F_MODE_TRIGGER (F_MODE1_MASK + F_MODE0_MASK)\n            \n/*          \n *  TRIG_CFG FIFO Trigger Configuration Register\n */         \n#define FXOS8700_TRIG_CFG_REG 0x0A\n            \n#define FXOS8700_TRIG_TRANS_MASK 0x20\n#define FXOS8700_TRIG_LNDPRT_MASK 0x10\n#define FXOS8700_TRIG_PULSE_MASK 0x08\n#define FXOS8700_TRIG_FF_MT_MASK 0x04\n            \n/*          \n *  SYSMOD System Mode Register\n */         \n#define FXOS8700_SYSMOD_REG 0x0B\n            \n#define FXOS8700_FGERR_MASK 0x80 /* MMA8451 only */\n#define FXOS8700_FGT_4_MASK 0x40 /* MMA8451 only */\n#define FXOS8700_FGT_3_MASK 0x20 /* MMA8451 only */\n#define FXOS8700_FGT_2_MASK 0x10 /* MMA8451 only */\n#define FXOS8700_FGT_1_MASK 0x08 /* MMA8451 only */\n#define FXOS8700_FGT_0_MASK 0x04 /* MMA8451 only */\n#define FXOS8700_FGT_MASK 0x7C   /* MMA8451 only */\n#define FXOS8700_SYSMOD1_MASK 0x02\n#define FXOS8700_SYSMOD0_MASK 0x01\n#define FXOS8700_SYSMOD_MASK 0x03\n            \n#define FXOS8700_SYSMOD_STANDBY 0x00\n#define FXOS8700_SYSMOD_WAKE (SYSMOD0_MASK)\n#define FXOS8700_SYSMOD_SLEEP (SYSMOD1_MASK)\n            \n/*          \n *  INT_SOURCE System Interrupt Status Register\n */         \n#define FXOS8700_INT_SOURCE_REG 0x0C\n            \n#define FXOS8700_SRC_ASLP_MASK 0x80\n#define FXOS8700_SRC_FIFO_MASK 0x40\n#define FXOS8700_SRC_TRANS_MASK 0x20\n#define FXOS8700_SRC_LNDPRT_MASK 0x10\n#define FXOS8700_SRC_PULSE_MASK 0x08\n#define FXOS8700_SRC_FF_MT_MASK 0x04\n#define FXOS8700_SRC_DRDY_MASK 0x01\n            \n/*          \n *  WHO_AM_I Device ID Register\n */         \n#define FXOS8700_WHO_AM_I_REG 0x0D\n            \n/* Content */\n#define FXOS8700_kFXOS_WHO_AM_I_Device_ID 0xC7\n            \n/* XYZ_DATA_CFG Sensor Data Configuration Register */\n#define FXOS8700_XYZ_DATA_CFG_REG 0x0E\n            \n#define FXOS8700_HPF_OUT_MASK 0x10\n#define FXOS8700_FS1_MASK 0x02\n#define FXOS8700_FS0_MASK 0x01\n#define FXOS8700_FS_MASK 0x03\n            \n#define FXOS8700_FULL_SCALE_2G 0x00\n#define FXOS8700_FULL_SCALE_4G (FXOS8700_FS0_MASK)\n#define FXOS8700_FULL_SCALE_8G (FXOS8700_FS1_MASK)\n            \n/* HP_FILTER_CUTOFF High Pass Filter Register */\n#define FXOS8700_HP_FILTER_CUTOFF_REG 0x0F\n            \n#define FXOS8700_PULSE_HPF_BYP_MASK 0x20\n#define FXOS8700_PULSE_LPF_EN_MASK 0x10\n#define FXOS8700_SEL1_MASK 0x02\n#define FXOS8700_SEL0_MASK 0x01\n#define FXOS8700_SEL_MASK 0x03\n            \n/*          \n *  PL_STATUS Portrait/Landscape Status Register\n */         \n#define FXOS8700_PL_STATUS_REG 0x10\n            \n#define FXOS8700_NEWLP_MASK 0x80\n#define FXOS8700_LO_MASK 0x40\n#define FXOS8700_LAPO1_MASK 0x04\n#define FXOS8700_LAPO0_MASK 0x02\n#define FXOS8700_BAFRO_MASK 0x01\n#define FXOS8700_LAPO_MASK 0x06\n            \n/*          \n *  PL_CFG Portrait/Landscape Configuration Register\n */         \n#define FXOS8700_PL_CFG_REG 0x11\n            \n#define FXOS8700_DBCNTM_MASK 0x80\n#define FXOS8700_PL_EN_MASK 0x40\n            \n/*          \n *  PL_COUNT Portrait/Landscape Debounce Register\n */         \n#define FXOS8700_PL_COUNT_REG 0x12\n            \n/*          \n *  PL_BF_ZCMP Back/Front and Z Compensation Register\n */         \n#define FXOS8700_PL_BF_ZCOMP_REG 0x13\n            \n#define FXOS8700_BKFR1_MASK 0x80\n#define FXOS8700_BKFR0_MASK 0x40\n#define FXOS8700_ZLOCK2_MASK 0x04\n#define FXOS8700_ZLOCK1_MASK 0x02\n#define FXOS8700_ZLOCK0_MASK 0x01\n#define FXOS8700_BKFR_MASK 0xC0\n#define FXOS8700_ZLOCK_MASK 0x07\n            \n/*          \n *  PL_P_L_THS Portrait to Landscape Threshold Register\n */         \n#define FXOS8700_PL_P_L_THS_REG 0x14\n            \n#define FXOS8700_P_L_THS4_MASK 0x80\n#define FXOS8700_P_L_THS3_MASK 0x40\n#define FXOS8700_P_L_THS2_MASK 0x20\n#define FXOS8700_P_L_THS1_MASK 0x10\n#define FXOS8700_P_L_THS0_MASK 0x08\n#define FXOS8700_HYS2_MASK 0x04\n#define FXOS8700_HYS1_MASK 0x02\n#define FXOS8700_HYS0_MASK 0x01\n#define FXOS8700_P_L_THS_MASK 0xF8\n#define FXOS8700_HYS_MASK 0x07\n            \n/*          \n *  FF_MT_CFG Freefall and Motion Configuration Register\n */         \n#define FXOS8700_FF_MT_CFG_REG 0x15\n            \n#define FXOS8700_ELE_MASK 0x80\n#define FXOS8700_OAE_MASK 0x40\n#define FXOS8700_ZEFE_MASK 0x20\n#define FXOS8700_YEFE_MASK 0x10\n#define FXOS8700_XEFE_MASK 0x08\n            \n/*          \n *  FF_MT_SRC Freefall and Motion Source Registers\n */         \n#define FXOS8700_FF_MT_SRC_REG 0x16\n            \n#define FXOS8700_EA_MASK 0x80\n#define FXOS8700_ZHE_MASK 0x20\n#define FXOS8700_ZHP_MASK 0x10\n#define FXOS8700_YHE_MASK 0x08\n#define FXOS8700_YHP_MASK 0x04\n#define FXOS8700_XHE_MASK 0x02\n#define FXOS8700_XHP_MASK 0x01\n            \n/*          \n *  FF_MT_THS Freefall and Motion Threshold Registers\n *  TRANSIENT_THS Transient Threshold Register\n */         \n#define FXOS8700_FT_MT_THS_REG 0x17\n#define FXOS8700_TRANSIENT_THS_REG 0x1F\n            \n#define FXOS8700_DBCNTM_MASK 0x80\n#define FXOS8700_THS6_MASK 0x40\n#define FXOS8700_THS5_MASK 0x20\n#define FXOS8700_THS4_MASK 0x10\n#define FXOS8700_THS3_MASK 0x08\n#define FXOS8700_THS2_MASK 0x04\n#define FXOS8700_TXS1_MASK 0x02\n#define FXOS8700_THS0_MASK 0x01\n#define FXOS8700_THS_MASK 0x7F\n            \n/* FF_MT_COUNT Freefall Motion Count Registers */\n#define FXOS8700_FF_MT_COUNT_REG 0x18\n            \n/* TRANSIENT_CFG Transient Configuration Register */\n#define FXOS8700_TRANSIENT_CFG_REG 0x1D\n            \n#define FXOS8700_TELE_MASK 0x10\n#define FXOS8700_ZTEFE_MASK 0x08\n#define FXOS8700_YTEFE_MASK 0x04\n#define FXOS8700_XTEFE_MASK 0x02\n#define FXOS8700_HPF_BYP_MASK 0x01\n            \n/* TRANSIENT_SRC Transient Source Register */\n#define FXOS8700_TRANSIENT_SRC_REG 0x1E\n            \n#define FXOS8700_TEA_MASK 0x40\n#define FXOS8700_ZTRANSE_MASK 0x20\n#define FXOS8700_Z_TRANS_POL_MASK 0x10\n#define FXOS8700_YTRANSE_MASK 0x08\n#define FXOS8700_Y_TRANS_POL_MASK 0x04\n#define FXOS8700_XTRANSE_MASK 0x02\n#define FXOS8700_X_TRANS_POL_MASK 0x01\n            \n/* TRANSIENT_COUNT Transient Debounce Register */\n#define FXOS8700_TRANSIENT_COUNT_REG 0x20\n            \n/* PULSE_CFG Pulse Configuration Register */\n#define FXOS8700_PULSE_CFG_REG 0x21\n            \n#define FXOS8700_DPA_MASK 0x80\n#define FXOS8700_PELE_MASK 0x40\n#define FXOS8700_ZDPEFE_MASK 0x20\n#define FXOS8700_ZSPEFE_MASK 0x10\n#define FXOS8700_YDPEFE_MASK 0x08\n#define FXOS8700_YSPEFE_MASK 0x04\n#define FXOS8700_XDPEFE_MASK 0x02\n#define FXOS8700_XSPEFE_MASK 0x01\n            \n/* PULSE_SRC Pulse Source Register */\n#define FXOS8700_PULSE_SRC_REG 0x22\n            \n#define FXOS8700_PEA_MASK 0x80\n#define FXOS8700_AXZ_MASK 0x40\n#define FXOS8700_AXY_MASK 0x20\n#define FXOS8700_AXX_MASK 0x10\n#define FXOS8700_DPE_MASK 0x08\n#define FXOS8700_POLZ_MASK 0x04\n#define FXOS8700_POLY_MASK 0x02\n#define FXOS8700_POLX_MASK 0x01\n            \n/* PULSE_THS XYZ Pulse Threshold Registers */\n#define FXOS8700_PULSE_THSX_REG 0x23\n#define FXOS8700_PULSE_THSY_REG 0x24\n#define FXOS8700_PULSE_THSZ_REG 0x25\n            \n#define FXOS8700_PTHS_MASK 0x7F\n            \n/* PULSE_TMLT Pulse Time Window Register */\n#define FXOS8700_PULSE_TMLT_REG 0x26\n            \n/* PULSE_LTCY Pulse Latency Timer Register */\n#define FXOS8700_PULSE_LTCY_REG 0x27\n            \n/* PULSE_WIND Second Pulse Time Window Register */\n#define FXOS8700_PULSE_WIND_REG 0x28\n            \n/* ASLP_COUNT Auto Sleep Inactivity Timer Register */\n#define FXOS8700_ASLP_COUNT_REG 0x29\n            \n/* CTRL_REG1 System Control 1 Register */\n#define FXOS8700_CTRL_REG1 0x2A\n            \n#define FXOS8700_ASLP_RATE1_MASK 0x80\n#define FXOS8700_ASLP_RATE0_MASK 0x40\n#define FXOS8700_DR2_MASK 0x20\n#define FXOS8700_DR1_MASK 0x10\n#define FXOS8700_DR0_MASK 0x08\n#define FXOS8700_LNOISE_MASK 0x04\n#define FXOS8700_FREAD_MASK 0x02\n#define FXOS8700_ACTIVE_MASK 0x01\n#define FXOS8700_ASLP_RATE_MASK 0xC0\n#define FXOS8700_DR_MASK 0x38\n            \n#define FXOS8700_ASLP_RATE_20MS 0x00\n#define FXOS8700_ASLP_RATE_80MS (FXOS8700_ASLP_RATE0_MASK)\n#define FXOS8700_ASLP_RATE_160MS (FXOS8700_ASLP_RATE1_MASK)\n#define FXOS8700_ASLP_RATE_640MS (FXOS8700_ASLP_RATE1_MASK + FXOS8700_ASLP_RATE0_MASK)\n            \n#define FXOS8700_ASLP_RATE_50HZ (FXOS8700_ASLP_RATE_20MS)\n#define FXOS8700_ASLP_RATE_12_5HZ (FXOS8700_ASLP_RATE_80MS)\n#define FXOS8700_ASLP_RATE_6_25HZ (FXOS8700_ASLP_RATE_160MS)\n#define FXOS8700_ASLP_RATE_1_56HZ (FXOS8700_ASLP_RATE_640MS)\n            \n#define FXOS8700_HYB_ASLP_RATE_25HZ (FXOS8700_ASLP_RATE_20MS)\n#define FXOS8700_HYB_ASLP_RATE_6_25HZ (FXOS8700_ASLP_RATE_80MS)\n#define FXOS8700_HYB_ASLP_RATE_1_56HZ (FXOS8700_ASLP_RATE_160MS)\n#define FXOS8700_HYB_ASLP_RATE_0_8HZ (FXOS8700_ASLP_RATE_640MS)\n            \n#define FXOS8700_DATA_RATE_1250US 0x00\n#define FXOS8700_DATA_RATE_2500US (FXOS8700_DR0_MASK)\n#define FXOS8700_DATA_RATE_5MS (FXOS8700_DR1_MASK)\n#define FXOS8700_DATA_RATE_10MS (FXOS8700_DR1_MASK + FXOS8700_DR0_MASK)\n#define FXOS8700_DATA_RATE_20MS (FXOS8700_DR2_MASK)\n#define FXOS8700_DATA_RATE_80MS (FXOS8700_DR2_MASK + FXOS8700_DR0_MASK)\n#define FXOS8700_DATA_RATE_160MS (FXOS8700_DR2_MASK + FXOS8700_DR1_MASK)\n#define FXOS8700_DATA_RATE_640MS (FXOS8700_DR2_MASK + FXOS8700_DR1_MASK + FXOS8700_DR0_MASK)\n            \n#define FXOS8700_DATA_RATE_800HZ (FXOS8700_DATA_RATE_1250US)\n#define FXOS8700_DATA_RATE_400HZ (FXOS8700_DATA_RATE_2500US)\n#define FXOS8700_DATA_RATE_200HZ (FXOS8700_DATA_RATE_5MS)\n#define FXOS8700_DATA_RATE_100HZ (FXOS8700_DATA_RATE_10MS)\n#define FXOS8700_DATA_RATE_50HZ (FXOS8700_DATA_RATE_20MS)\n#define FXOS8700_DATA_RATE_12_5HZ (FXOS8700_DATA_RATE_80MS)\n#define FXOS8700_DATA_RATE_6_25HZ (FXOS8700_DATA_RATE_160MS)\n#define FXOS8700_DATA_RATE_1_56HZ (FXOS8700_DATA_RATE_640MS)\n            \n/* for hybrid (TO, Aug 2012) */\n#define FXOS8700_HYB_DATA_RATE_400HZ (FXOS8700_DATA_RATE_1250US)\n#define FXOS8700_HYB_DATA_RATE_200HZ (FXOS8700_DATA_RATE_2500US)\n#define FXOS8700_HYB_DATA_RATE_100HZ (FXOS8700_DATA_RATE_5MS)\n#define FXOS8700_HYB_DATA_RATE_50HZ (FXOS8700_DATA_RATE_10MS)\n#define FXOS8700_HYB_DATA_RATE_25HZ (FXOS8700_DATA_RATE_20MS)\n#define FXOS8700_HYB_DATA_RATE_6_25HZ (FXOS8700_DATA_RATE_80MS)\n#define FXOS8700_HYB_DATA_RATE_3_15HZ (FXOS8700_DATA_RATE_160MS)\n#define FXOS8700_HYB_DATA_RATE_0_8HZ (FXOS8700_DATA_RATE_640MS)\n            \n#define FXOS8700_ACTIVE (FXOS8700_ACTIVE_MASK)\n#define FXOS8700_STANDBY 0x00\n            \n/* CTRL_REG2 System Control 2 Register */\n#define FXOS8700_CTRL_REG2 0x2B\n            \n#define FXOS8700_ST_MASK 0x80\n#define FXOS8700_RST_MASK 0x40\n#define FXOS8700_SMODS1_MASK 0x10\n#define FXOS8700_SMODS0_MASK 0x08\n#define FXOS8700_SLPE_MASK 0x04\n#define FXOS8700_MODS1_MASK 0x02\n#define FXOS8700_MODS0_MASK 0x01\n#define FXOS8700_SMODS_MASK 0x18\n#define FXOS8700_MODS_MASK 0x03\n            \n#define FXOS8700_SMOD_NORMAL 0x00\n#define FXOS8700_SMOD_LOW_NOISE (FXOS8700_SMODS0_MASK)\n#define FXOS8700_SMOD_HIGH_RES (FXOS8700_SMODS1_MASK)\n#define FXOS8700_SMOD_LOW_POWER (FXOS8700_SMODS1_MASK + FXOS8700_SMODS0_MASK)\n            \n#define FXOS8700_MOD_NORMAL 0x00\n#define FXOS8700_MOD_LOW_NOISE (FXOS8700_MODS0_MASK)\n#define FXOS8700_MOD_HIGH_RES (FXOS8700_MODS1_MASK)\n#define FXOS8700_MOD_LOW_POWER (FXOS8700_MODS1_MASK + FXOS8700_MODS0_MASK)\n            \n/* CTRL_REG3 Interrupt Control Register */\n#define FXOS8700_CTRL_REG3 0x2C\n            \n#define FXOS8700_FIFO_GATE_MASK 0x80\n#define FXOS8700_WAKE_TRANS_MASK 0x40\n#define FXOS8700_WAKE_LNDPRT_MASK 0x20\n#define FXOS8700_WAKE_PULSE_MASK 0x10\n#define FXOS8700_WAKE_FF_MT_MASK 0x08\n#define FXOS8700_IPOL_MASK 0x02\n#define FXOS8700_PP_OD_MASK 0x01\n            \n/* CTRL_REG4 Interrupt Enable Register */\n#define FXOS8700_CTRL_REG4 0x2D\n            \n#define FXOS8700_INT_EN_ASLP_MASK 0x80\n#define FXOS8700_INT_EN_FIFO_MASK 0x40\n#define FXOS8700_INT_EN_TRANS_MASK 0x20\n#define FXOS8700_INT_EN_LNDPRT_MASK 0x10\n#define FXOS8700_INT_EN_PULSE_MASK 0x08\n#define FXOS8700_INT_EN_FF_MT_MASK 0x04\n#define FXOS8700_INT_EN_DRDY_MASK 0x01\n            \n/* CTRL_REG5 Interrupt Configuration Register */\n#define FXOS8700_CTRL_REG5 0x2E\n            \n#define FXOS8700_INT_CFG_ASLP_MASK 0x80\n#define FXOS8700_INT_CFG_FIFO_MASK 0x40\n#define FXOS8700_INT_CFG_TRANS_MASK 0x20\n#define FXOS8700_INT_CFG_LNDPRT_MASK 0x10\n#define FXOS8700_INT_CFG_PULSE_MASK 0x08\n#define FXOS8700_INT_CFG_FF_MT_MASK 0x04\n#define FXOS8700_INT_CFG_DRDY_MASK 0x01\n            \n/* XYZ Offset Correction Registers */\n#define FXOS8700_OFF_X_REG 0x2F\n#define FXOS8700_OFF_Y_REG 0x30\n#define FXOS8700_OFF_Z_REG 0x31\n            \n/* M_DR_STATUS Register */\n#define FXOS8700_M_DR_STATUS_REG 0x32\n            \n#define FXOS8700_ZYXOW_MASK 0x80\n#define FXOS8700_ZOW_MASK 0x40\n#define FXOS8700_YOW_MASK 0x20\n#define FXOS8700_XOW_MASK 0x10\n#define FXOS8700_ZYXDR_MASK 0x08\n#define FXOS8700_ZDR_MASK 0x04\n#define FXOS8700_YDR_MASK 0x02\n#define FXOS8700_XDR_MASK 0x01\n            \n/* MAG XYZ Data Registers */\n#define FXOS8700_M_OUT_X_MSB_REG 0x33\n#define FXOS8700_M_OUT_X_LSB_REG 0x34\n#define FXOS8700_M_OUT_Y_MSB_REG 0x35\n#define FXOS8700_M_OUT_Y_LSB_REG 0x36\n#define FXOS8700_M_OUT_Z_MSB_REG 0x37\n#define FXOS8700_M_OUT_Z_LSB_REG 0x38\n            \n/* MAG CMP Data Registers */\n#define FXOS8700_CMP_X_MSB_REG 0x39\n#define FXOS8700_CMP_X_LSB_REG 0x3A\n#define FXOS8700_CMP_Y_MSB_REG 0x3B\n#define FXOS8700_CMP_Y_LSB_REG 0x3C\n#define FXOS8700_CMP_Z_MSB_REG 0x3D\n#define FXOS8700_CMP_Z_LSB_REG 0x3E\n            \n/* MAG XYZ Offset Correction Registers */\n#define FXOS8700_M_OFF_X_MSB_REG 0x3F\n#define FXOS8700_M_OFF_X_LSB_REG 0x40\n#define FXOS8700_M_OFF_Y_MSB_REG 0x41\n#define FXOS8700_M_OFF_Y_LSB_REG 0x42\n#define FXOS8700_M_OFF_Z_MSB_REG 0x43\n#define FXOS8700_M_OFF_Z_LSB_REG 0x44\n            \n/* MAG MAX XYZ Registers */\n#define FXOS8700_MAX_X_MSB_REG 0x45\n#define FXOS8700_MAX_X_LSB_REG 0x46\n#define FXOS8700_MAX_Y_MSB_REG 0x47\n#define FXOS8700_MAX_Y_LSB_REG 0x48\n#define FXOS8700_MAX_Z_MSB_REG 0x49\n#define FXOS8700_MAX_Z_LSB_REG 0x4A\n            \n/* MAG MIN XYZ Registers */\n#define FXOS8700_MIN_X_MSB_REG 0x4B\n#define FXOS8700_MIN_X_LSB_REG 0x4C\n#define FXOS8700_MIN_Y_MSB_REG 0x4D\n#define FXOS8700_MIN_Y_LSB_REG 0x4E\n#define FXOS8700_MIN_Z_MSB_REG 0x4F\n#define FXOS8700_MIN_Z_LSB_REG 0x50\n            \n/* TEMP Registers */\n#define FXOS8700_TEMP_REG 0x51\n            \n/* M_THS CONFIG Registers */\n#define FXOS8700_M_THS_CFG_REG 0x52\n            \n/* M_THS SRC Registers */\n#define FXOS8700_M_THS_SRC_REG 0x53\n            \n/* MAG THRESHOLD XYZ Registers */\n#define FXOS8700_M_THS_X_MSB_REG 0x54\n#define FXOS8700_M_THS_X_LSB_REG 0x55\n#define FXOS8700_M_THS_Y_MSB_REG 0x56\n#define FXOS8700_M_THS_Y_LSB_REG 0x57\n#define FXOS8700_M_THS_Z_MSB_REG 0x58\n#define FXOS8700_M_THS_Z_LSB_REG 0x59\n            \n/* M_THS COUNT Registers */\n#define FXOS8700_M_THS_COUNT 0x5A\n            \n/* MAG CTRL_REG1 System Control 1 Register */\n#define FXOS8700_M_CTRL_REG1 0x5B\n            \n#define FXOS8700_M_ACAL_MASK 0x80\n#define FXOS8700_M_RST_MASK 0x40\n#define FXOS8700_M_OST_MASK 0x20\n#define FXOS8700_M_OSR2_MASK 0x10\n#define FXOS8700_M_OSR1_MASK 0x08\n#define FXOS8700_M_OSR0_MASK 0x04\n#define FXOS8700_M_HMS1_MASK 0x02\n#define FXOS8700_M_HMS0_MASK 0x01\n#define FXOS8700_M_OSR_MASK 0x1C\n#define FXOS8700_M_HMS_MASK 0x03\n            \n/* OSR Selections */\n#define FXOS8700_M_OSR_1_56_HZ 0x00\n#define FXOS8700_M_OSR_6_25_HZ FXOS8700_M_OSR0_MASK\n#define FXOS8700_M_OSR_12_5_HZ FXOS8700_M_OSR1_MASK\n#define FXOS8700_M_OSR_50_HZ   FXOS8700_M_OSR1_MASK + FXOS8700_M_OSR0_MASK\n#define FXOS8700_M_OSR_100_HZ  FXOS8700_M_OSR2_MASK\n#define FXOS8700_M_OSR_200_HZ  FXOS8700_M_OSR2_MASK + FXOS8700_M_OSR0_MASK\n#define FXOS8700_M_OSR_400_HZ  FXOS8700_M_OSR2_MASK + FXOS8700_M_OSR1_MASK\n#define FXOS8700_M_OSR_800_HZ  FXOS8700_M_OSR2_MASK + FXOS8700_M_OSR1_MASK + M_OSR0_MASK\n            \n/* Hybrid Mode Selection */\n#define FXOS8700_ACCEL_ACTIVE 0x00\n#define FXOS8700_MAG_ACTIVE FXOS8700_M_HMS0_MASK\n#define FXOS8700_HYBRID_ACTIVE (FXOS8700_M_HMS1_MASK | FXOS8700_M_HMS0_MASK)\n            \n/* MAG CTRL_REG2 System Control 2 Register */\n#define FXOS8700_M_CTRL_REG2 0x5C\n            \n#define FXOS8700_M_HYB_AUTOINC_MASK 0x20\n#define FXOS8700_M_MAXMIN_DIS_MASK 0x10\n#define FXOS8700_M_MAXMIN_DIS_THS_MASK 0x08\n#define FXOS8700_M_MAXMIN_RST_MASK 0x04\n#define FXOS8700_M_RST_CNT1_MASK 0x02\n#define FXOS8700_M_RST_CNT0_MASK 0x01\n            \n/* Mag Auto-Reset De-Gauss Frequency */\n#define FXOS8700_RST_ODR_CYCLE 0x00\n#define FXOS8700_RST_16_ODR_CYCLE FXOS8700_M_RST_CNT0_MASK\n#define FXOS8700_RST_512_ODR_CYCLE FXOS8700_M_RST_CNT1_MASK\n#define FXOS8700_RST_DISABLED FXOS8700_M_RST_CNT1_MASK + FXOS8700_M_RST_CNT0_MASK\n            \n/* MAG CTRL_REG3 System Control 3 Register */\n#define FXOS8700_M_CTRL_REG3 0x5D\n            \n#define FXOS8700_M_RAW_MASK 0x80\n#define FXOS8700_M_ASLP_OS_2_MASK 0x40\n#define FXOS8700_M_ASLP_OS_1_MASK 0x20\n#define FXOS8700_M_ASLP_OS_0_MASK 0x10\n#define FXOS8700_M_THS_XYZ_MASK 0x08\n#define FXOS8700_M_ST_Z_MASK 0x04\n#define FXOS8700_M_ST_XY1_MASK 0x02\n#define FXOS8700_M_ST_XY0_MASK 0x01\n#define FXOS8700_M_ASLP_OSR_MASK 0x70\n#define FXOS8700_M_ST_XY_MASK 0x03\n            \n/* OSR Selections */\n#define FXOS8700_M_ASLP_OSR_1_56_HZ 0x00\n#define FXOS8700_M_ASLP_OSR_6_25_HZ FXOS8700_M_ASLP_OS_0_MASK\n#define FXOS8700_M_ASLP_OSR_12_5_HZ FXOS8700_M_ASLP_OS_1_MASK\n#define FXOS8700_M_ASLP_OSR_50_HZ  FXOS8700_M_ASLP_OS_1_MASK + FXOS8700_M_ASLP_OS_0_MASK\n#define FXOS8700_M_ASLP_OSR_100_HZ FXOS8700_M_ASLP_OS_2_MASK\n#define FXOS8700_M_ASLP_OSR_200_HZ FXOS8700_M_ASLP_OS_2_MASK + FXOS8700_M_ASLP_OS_0_MASK\n#define FXOS8700_M_ASLP_OSR_400_HZ FXOS8700_M_ASLP_OS_2_MASK + FXOS8700_M_ASLP_OS_1_MASK\n#define FXOS8700_M_ASLP_OSR_800_HZ FXOS8700_M_ASLP_OS_2_MASK + FXOS8700_M_ASLP_OS_1_MASK + FXOS8700_M_ASLP_OS_0_MASK\n            \n/* MAG INT SOURCE Register */\n#define FXOS8700_M_INT_SOURCE 0x5E\n            \n#define FXOS8700_SRC_M_DRDY_MASK 0x04\n#define FXOS8700_SRC_M_VECM_MASK 0x02\n#define FXOS8700_SRC_M_THS_MASK 0x01\n            \n/* ACCEL VECTOR CONFIG Register */\n#define FXOS8700_A_VECM_CFG 0x5F\n            \n#define FXOS8700_A_VECM_INIT_CFG_MASK 0x40\n#define FXOS8700_A_VECM_INIT_EN_MASK 0x20\n#define FXOS8700_A_VECM_WAKE_EN_MASK 0x10\n#define FXOS8700_A_VECM_EN_MASK 0x08\n#define FXOS8700_A_VECM_UPDM_MASK 0x04\n#define FXOS8700_A_VECM_INITM_MASK 0x02\n#define FXOS8700_A_VECM_ELE_MASK 0x01\n            \n/* ACCEL VECTOR THS MSB AND LSB Register */\n#define FXOS8700_A_VECM_THS_MSB 0x60\n            \n#define FXOS8700_A_VECM_DBCNTM_MASK 0x80\n            \n#define FXOS8700_A_VECM_THS_LSB 0x61\n            \n/* ACCEL VECTOR CNT Register */\n#define FXOS8700_A_VECM_CNT 0x62\n            \n/* ACCEL INI8700TIAL XYZ VECTORS Register */\n#define FXOS8700_A_VECM_INITX_MSB 0x63\n#define FXOS8700_A_VECM_INITX_LSB 0x64\n#define FXOS8700_A_VECM_INITY_MSB 0x65\n#define FXOS8700_A_VECM_INITY_LSB 0x66\n#define FXOS8700_A_VECM_INITZ_MSB 0x67\n#define FXOS8700_A_VECM_INITZ_LSB 0x68\n            \n/* MAG VECTOR CONFIG Register */\n#define FXOS8700_M_VECM_CFG 0x69\n            \n#define FXOS8700_M_VECM_INIT_CFG_MASK 0x40\n#define FXOS8700_M_VECM_INIT_EN_MASK 0x20\n#define FXOS8700_M_VECM_WAKE_EN_MASK 0x10\n#define FXOS8700_M_VECM_EN_MASK 0x08\n#define FXOS8700_M_VECM_UPDM_MASK 0x04\n#define FXOS8700_M_VECM_INITM_MASK 0x02\n#define FXOS8700_M_VECM_ELE_MASK 0x01\n            \n/* MAG VECTOR THS MSB AND LSB Register */\n#define FXOS8700_M_VECM_THS_MSB 0x6A\n            \n#define FXOS8700_M_VECM_DBCNTM_MASK 0x80\n            \n#define FXOS8700_M_VECM_THS_LSB 0x6B\n            \n/* MAG VECTOR CNT Register */\n#define FXOS8700_M_VECM_CNT 0x6C\n            \n/* MAG INITIAL XYZ VECTORS Register */\n#define FXOS8700_M_VECM_INITX_MSB 0x6D\n#define FXOS8700_M_VECM_INITX_LSB 0x6E\n#define FXOS8700_M_VECM_INITY_MSB 0x6F\n#define FXOS8700_M_VECM_INITY_LSB 0x70\n#define FXOS8700_M_VECM_INITZ_MSB 0x71\n#define FXOS8700_M_VECM_INITZ_LSB 0x72\n            \n/* ACCEL FFMT THS X MSB AND LSB Register */\n#define FXOS8700_A_FFMT_THS_X_MSB 0x73\n            \n#define FXOS8700_A_FFMT_THS_XYZ_EN_MASK 0x80\n            \n#define FXOS8700_A_FFMT_THS_X_LSB 0x74\n            \n#define FXOS8700_A_FFMT_THS_X_LSB_MASK 0xFC\n            \n/* ACCEL FFMT THS Y MSB AND LSB Register */\n#define FXOS8700_A_FFMT_THS_Y_MSB 0x75\n            \n#define FXOS8700_A_FFMT_THS_Y_EN_MASK 0x80\n            \n#define FXOS8700_A_FFMT_THS_Y_LSB 0x76\n            \n#define FXOS8700_A_FFMT_THS_Y_LSB_MASK 0xFC\n            \n/* ACCEL FFMT THS Z MSB AND LSB Register */\n#define FXOS8700_A_FFMT_THS_Z_MSB 0x77\n            \n#define FXOS8700_A_FFMT_THS_Z_EN_MASK 0x80\n            \n#define FXOS8700_A_FFMT_THS_Z_LSB 0x78\n            \n#define FXOS8700_A_FFMT_THS_Z_LSB_MASK 0xFC\n            \n/* ACCEL TRANSIENT INIT Register */\n#define FXOS8700_A_TRAN_INIT_XYZ_MSB 0x79\n#define FXOS8700_A_TRAN_INIT_X_LSB 0x7A\n#define FXOS8700_A_TRAN_INIT_Y_LSB 0x7B\n#define FXOS8700_A_TRAN_INIT_Z_LSB 0x7C\n\n/*! @brief fxos8700cq configure definition. This structure should be global.*/\ntypedef struct _fxos8700_handle\n{\n\t  uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\n\t  uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\n\t  void      (*WaitMsec)(uint32_t millisec);\n} fxos8700_handle_t;\n\ntypedef struct _fxos8700cq_data\n{\n    uint8_t accelXMSB;\n    uint8_t accelXLSB;\n    uint8_t accelYMSB;\n    uint8_t accelYLSB;\n    uint8_t accelZMSB;\n    uint8_t accelZLSB;\n    uint8_t magXMSB;\n    uint8_t magXLSB;\n    uint8_t magYMSB;\n    uint8_t magYLSB;\n    uint8_t magZMSB;\n    uint8_t magZLSB;\n} fxos8700_data_t;\n\n/*!\n * @addtogroup fxos8700_common\n * @{\n */\n\ntypedef int32_t fxos8700_status_t;\n#define FXOS8700_Status_Success (0)\n#define FXOS8700_Status_Fail (1)\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/*!\n * @brief Verify and initialize fxos8700_handle ice: Hybrid mode with ODR=200Hz, Mag OSR=32, Acc OSR=Normal.\n * Interrupt for data ready can be set using #define EN_FXOS_DATAREADY_INTERRUPT\n *\n * @param fxos8700_handle The pointer to accel driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Read data from sensors, assumes hyb_autoinc_mode is set in M_CTRL_REG2\n *\n * @param fxos8700_handle The pointer to accel driver handle.\n * @param sensorData The pointer to the buffer to hold sensor data\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_ReadSensorData(fxos8700_handle_t *fxos8700_handle, fxos8700_data_t *sensorData);\n\n/*!\n * @brief Write value to register of sensor.\n *\n * @param handle The pointer to fxos8700cq driver handle.\n * @param reg Register address.\n * @param val Data want to write.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_WriteReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t val);\n\n/*!\n * @brief Read n bytes start at register from sensor.\n *\n * @param handle The pointer to fxos8700cq driver handle.\n * @param reg Register address.\n * @param val The pointer to address which store data.\n * @param bytesNumber Number of bytes receiver.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_ReadReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t *val, uint8_t bytesNumber);\n\n/*!\n * @brief Puts the FXOS8700CQ into Standby Mode\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_SetStandby(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Puts the FXOS8700CQ int Active Mode\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_SetActive(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Motion Detection on x and y axis with 0.5g Threshold. \n * NOTE: Motion Detect and FreeFall Detect shares the same hardware block so only one function can be initialized/used at a time. \n * Please refer to NXP Application Note AN4070: Motion and Freefall Detection Using the MMA8451, 2, 3Q\n * on how to configure the Motion Detection parameters. FXOS8700CQ shares the same registers and hardware blocks\n * as the MMA8451 so AN4070 is applicable for this sensor.\n *\n * Interrupts can be set with #define EN_FFMT_INTERRUPT. \n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_MotionDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Freefall Detection on z axis with 0.25g Threshold. \n * NOTE: Motion Detect and FreeFall Detect shares the same hardware block so only one function can be initialized/used at a time. \n * Please refer to NXP Application Note AN4070: Motion and Freefall Detection Using the MMA8451, 2, 3Q\n * on how to configure the Freefall Detection parameters. FXOS8700CQ shares the same registers and hardware blocks\n * as the MMA8451 so AN4070 is applicable for this sensor.\n *\n * Interrupts can be set with #define EN_FFMT_INTERRUPT. \n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_FreefallDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Tap Detection (also called Pulse Detection) \n * Pulse Thresholds: X:2g Y:2g Z:3g \n * Pulse Time Window: 6 counts\n * Pulse Latency Timer: 40 counts\n * Pulse 2nd Time Window: 15 counts\n *\n * Please refer to NXP Application Note AN4072: MMA8451, 2, 3Q Single/Double and Directional Tap Detection\n * on how to configure the Tap Detection parameters. FXOS8700CQ shares the same registers and hardware blocks\n * as the MMA8451 so AN4072 is applicable for this sensor.\n *\n * Interrupts can be set with #define EN_TAP_INTERRUPT. \n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_TapDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Disables either freefall or motion detection. \n * Disables the associated interrupts if enabled\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_FreefallMotion_DeInit(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Disables Tap Detection. \n * Disables the associated interrupts if enabled\n *\n * @param handle The pointer to fxos8700cq driver handle.\n *\n * @return FXOS8700_Status_Success if success or FXOS8700_Status_Fail if error.\n */\nfxos8700_status_t FXOS8700_TapDetect_DeInit(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Sets up Transient Detection on x,y,z axis with 0.25g Threshold and High-Pass Filter to 2 Hz (OSR= 200Hz,High Res)\n * Transient Detection is similar to Motion Detection except it only detects dynamic acceleration. It will not register\n * static acceleration such as gravity.\n *\n * Please refer to NXP Application Note AN4071: High-Pass Filtered Data and Transient Detection Using the MMA8451, 2, 3Q\n * on how to configure the Transient Detection parameters. It also lists when to use transient detection and when to use motion detection.\n * FXOS8700CQ shares the same registers and hardware blocks as the MMA8451 so AN4071 is applicable for this sensor.\n *\n * Interrupts can be set with \\#define EN_TRANS_INTERRUPT.\n * Interrupts when enabled goes to INT2 pin, set to INT1 pin using \\#define EN_TRANS_INT1_PIN\n *\n * @param fxos8700_handle The pointer to fxos8700cq driver handle.\n *\n * @return kStatus_Success if success or kStatus_Fail if error.\n */\nfxos8700_status_t FXOS8700_TransientDetect_Init(fxos8700_handle_t *fxos8700_handle);\n\n/*!\n * @brief Disables Transient detection.\n * Disables the associated interrupts if enabled\n *\n * @param fxos8700_handle The pointer to fxos8700cq driver handle.\n *\n * @return kStatus_Success if success or kStatus_Fail if error.\n */\nfxos8700_status_t FXOS8700_TransientDetect_DeInit(fxos8700_handle_t *fxos8700_handle);\n\n\n\n#if defined(__cplusplus)\n}\n#endif /* __cplusplus */\n\n#endif /* _FSL_FXOS_H_ */\n"
              },
              "objects": {
                "fxos8700.c": "#include \"fxos8700.h\"\n#include \"fxos8700_internal.h\"\n\ntypedef struct {\n    ATMO_FXOS8700_Config_t config;\n\n    unsigned int motionDetectedAbilityHandle;\n    ATMO_Callback_t motionDetectedCallback;\n    bool motionDetectedAbilityHandleRegistered;\n\n\tunsigned int freefallDetectedAbilityHandle;\n    ATMO_Callback_t freefallDetectedCallback;\n    bool freefallDetectedAbilityHandleRegistered;\n\n    unsigned int tapDetectedAbilityHandle;\n    ATMO_Callback_t tapDetectedCallback;\n    bool tapDetectedAbilityHandleRegistered;\n\n    unsigned int doubleTapDetectedAbilityHandle;\n    ATMO_Callback_t doubleTapDetectedCallback;\n    bool doubleTapDetectedAbilityHandleRegistered;\n\n    bool configured;\n} ATMO_FXOS8700_Priv_Config;\n\nstatic bool fxos8700Enabled = true;\n\nstatic ATMO_FXOS8700_Priv_Config _ATMO_FXOS8700_config = {0};\n\nstatic ATMO_I2C_Peripheral_t _ATMO_FXOS8700_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic fxos8700_handle_t handle;\n\nstatic uint8_t ATMO_FXOS8700_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_FXOS8700_config.config.i2cDriverInstance, _ATMO_FXOS8700_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t ATMO_FXOS8700_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_FXOS8700_config.config.i2cDriverInstance, _ATMO_FXOS8700_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic void ATMO_FXOS8700_INT_DoAbilityOrCallback(bool abilityRegistered, unsigned int abilityHandle, ATMO_Callback_t cb, void *data, uint32_t dataLen)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn;\n\t}\n\n\tATMO_Value_t value;\n\tATMO_InitValue(&value);\n\tif(data != NULL)\n\t{\n\t\tATMO_CreateValueBinary(&value, data, dataLen);\n\t}\n\n\tif(abilityRegistered)\n\t{\n\t\tATMO_AddAbilityExecute(abilityHandle, &value);\n\t}\n\n\tif(cb != NULL)\n\t{\n\t\tATMO_AddCallbackExecute(cb, &value);\n\t}\n\n\tATMO_FreeValue(&value);\n}\n\nstatic void ATMO_FXOS8700_INT_Callback(void *data)\n{\n\t// Read int src\n\tuint8_t src;\n\tif( FXOS8700_ReadReg(&handle, FXOS8700_INT_SOURCE_REG, &src, 1) == FXOS8700_Status_Success )\n\t{\n\t\tuint8_t tmp;\n\t\tif(src & FXOS8700_SRC_DRDY_MASK)\n\t\t{\n\t\t\t// Clear it by reading accelerometer data\n\t\t\tfxos8700_data_t sensorData;\n\t\t\tFXOS8700_ReadSensorData(&handle, &sensorData);\n\t\t\t//ATMO_FXOS8700_INT_DoAbilityOrCallback(_src, &sensorData, sizeof(sensorData));\n\t\t}\n\n\t\tif(src & FXOS8700_SRC_FF_MT_MASK)\n\t\t{\n\t\t\t// Clear it by reading ffmt register\n\t\t\tFXOS8700_ReadReg(&handle, FXOS8700_FF_MT_SRC_REG, &tmp, 1);\n\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.freefallDetectedAbilityHandleRegistered,\n\t\t\t\t\t_ATMO_FXOS8700_config.freefallDetectedAbilityHandle, _ATMO_FXOS8700_config.freefallDetectedCallback, NULL, 0);\n\t\t}\n\n\t\tif(src & FXOS8700_SRC_TRANS_MASK)\n\t\t{\n\t\t\t// Clear it by reading trans register\n\t\t\tFXOS8700_ReadReg(&handle, FXOS8700_TRANSIENT_SRC_REG, &tmp, 1);\n\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.motionDetectedAbilityHandleRegistered,\n\t\t\t_ATMO_FXOS8700_config.motionDetectedAbilityHandle, _ATMO_FXOS8700_config.motionDetectedCallback, NULL, 0);\t\n\t\t}\n\n\t\tif(src & FXOS8700_SRC_PULSE_MASK)\n\t\t{\n\t\t\t// Clear it by reading PULSE_SRC reg\n\t\t\tbool tapDetected, doubleTap = false;\n\t\t\tATMO_FXOS8700_IsTapDetected(&tapDetected, &doubleTap);\n\n\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.tapDetectedAbilityHandleRegistered,\n\t\t\t\t\t_ATMO_FXOS8700_config.tapDetectedAbilityHandle, _ATMO_FXOS8700_config.tapDetectedCallback, NULL, 0);\n\n\t\t\tif(doubleTap)\n\t\t\t{\n\t\t\t\tATMO_FXOS8700_INT_DoAbilityOrCallback(_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandleRegistered,\n\t\t\t\t\t\t_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandle, _ATMO_FXOS8700_config.doubleTapDetectedCallback, NULL, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic ATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableInterrupts()\n{\n\t// Cannot enable both motion and freefall detection\n\tif(_ATMO_FXOS8700_config.config.freefallEnabled && _ATMO_FXOS8700_config.config.motionEnabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfxos8700_status_t status = FXOS8700_Status_Success;\n\n\tif(_ATMO_FXOS8700_config.config.freefallEnabled)\n\t{\n\t\tstatus = FXOS8700_FreefallDetect_Init(&handle);\n\t}\n\telse\n\t{\n\t\tstatus = FXOS8700_MotionDetectFreefall_DeInit(&handle);\n\t}\n\n\tif(_ATMO_FXOS8700_config.config.motionEnabled && status == FXOS8700_Status_Success)\n\t{\n\t\tstatus = FXOS8700_TransientDetect_Init(&handle);\n\t}\n\telse\n\t{\n\t\tstatus = FXOS8700_TransientDetect_DeInit(&handle);\n\t}\n\n\tif(_ATMO_FXOS8700_config.config.tapDetectionEnabled && status == FXOS8700_Status_Success)\n\t{\n\t\tstatus = FXOS8700_TapDetect_Init(&handle);\n\t}\n\telse\n\t{\n\t\tstatus = FXOS8700_TapDetect_DeInit(&handle);\n\t}\n\n\treturn status == FXOS8700_Status_Success ? ATMO_FXOS8700_Status_Success : ATMO_FXOS8700_Status_Fail;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_Init(ATMO_FXOS8700_Config_t *config)\n{\n\thandle.I2C_Read = ATMO_FXOS8700_I2CRead_Simple;\n\thandle.I2C_Write = ATMO_FXOS8700_I2CWrite_Simple;\n\thandle.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_FXOS8700_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_FXOS8700_config.configured = false;\n    }\n\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetEnabled(bool enabled)\n{\n\tfxos8700Enabled = enabled;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetEnabled(bool *enabled)\n{\n\t*enabled = fxos8700Enabled;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetConfiguration(const ATMO_FXOS8700_Config_t *config)\n{\n    if( config == NULL || !fxos8700Enabled)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_FXOS8700_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n    memcpy( &_ATMO_FXOS8700_config.config, config, sizeof(ATMO_FXOS8700_Config_t) );\n    _ATMO_FXOS8700_config.configured = true;\n\n\tfxos8700_status_t status = FXOS8700_Init(&handle);\n\n\tif(status != FXOS8700_Status_Success)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n    // Register interrupt\n    if(config->int1En)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->int1Pin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_FXOS8700_INT_Callback);\n    }\n    if(config->int2En)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->int2Pin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_FXOS8700_INT_Callback);\n    }\n\n\n    return ATMO_FXOS8700_EnableInterrupts();\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetConfiguration(ATMO_FXOS8700_Config_t *config)\n{\n    if( config == NULL || !_ATMO_FXOS8700_config.configured )\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_FXOS8700_config.config, sizeof(ATMO_FXOS8700_Config_t));\n\n    return ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetAccelData(ATMO_3dFloatVector_t *data)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfxos8700_data_t rawData;\n\tif(FXOS8700_ReadSensorData(&handle, &rawData) != FXOS8700_Status_Success)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfloat dataScale = 0;\n\tuint8_t sensorRange = 0;\n\n\t    /* Get sensor range */\n    if (FXOS8700_ReadReg(&handle, FXOS8700_XYZ_DATA_CFG_REG, &sensorRange, 1) != FXOS8700_Status_Success)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n    if(sensorRange == 0x00)\n    {\n    \t/* 0.244 mg/LSB */\n        dataScale = 0.000244;\n    }\n    else if(sensorRange == 0x01)\n    {\n    \t/* 0.488 mg/LSB */\n        dataScale = 0.000488;\n    }\n    else if(sensorRange == 0x10)\n    {\n    \t/* 0.976 mg/LSB */\n        dataScale = 0.000976;\n    }\n\n\tdata->x =  ((float)((int16_t)(((rawData.accelXMSB*256) + (rawData.accelXLSB)))>> 2));\n\tdata->y =  ((float)((int16_t)(((rawData.accelYMSB*256) + (rawData.accelYLSB)))>> 2));\n\tdata->z =  ((float)((int16_t)(((rawData.accelZMSB*256) + (rawData.accelZLSB)))>> 2));\n\tdata->x *= dataScale;\n\tdata->y *= dataScale;\n\tdata->z *= dataScale;\n\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_GetMagData(ATMO_3dFloatVector_t *data)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfxos8700_data_t rawData;\n\tif(FXOS8700_ReadSensorData(&handle, &rawData) != FXOS8700_Status_Success)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\tfloat dataScale = 0;\n\tuint8_t sensorRange = 0;\n\n\t    /* Get sensor range */\n    if (FXOS8700_ReadReg(&handle, FXOS8700_XYZ_DATA_CFG_REG, &sensorRange, 1) != FXOS8700_Status_Success)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n\tdata->x =  (float)((int16_t)((rawData.magXMSB*256) + (rawData.magXLSB))) * 0.1;\n\tdata->y =  (float)((int16_t)((rawData.magYMSB*256) + (rawData.magYLSB))) * 0.1;\n\tdata->z =  (float)((int16_t)((rawData.magZMSB*256) + (rawData.magZLSB))) * 0.1;\n\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\t_ATMO_FXOS8700_config.freefallDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.freefallDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n\n}\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetFreefallDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.freefallDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\n\t_ATMO_FXOS8700_config.motionDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.motionDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n\n}\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetMotionDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.motionDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\n/**\n * Tap detection\n */\nATMO_FXOS8700_Status_t ATMO_FXOS8700_IsTapDetected(bool *isTapDetected, bool *isDoubleTap)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n    uint8_t tmp[1];\n    *isDoubleTap = false;\n\n    if(FXOS8700_ReadReg(&handle, FXOS8700_PULSE_SRC_REG, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return ATMO_FXOS8700_Status_Fail;\n    }\n\n\n    if ((tmp[0] & FXOS8700_PEA_MASK) == FXOS8700_PEA_MASK)\n    {\n        /* Check to see if it was a double tap */\n        if ((tmp[0] & FXOS8700_DPE_MASK) == FXOS8700_DPE_MASK)\n        {\n            *isDoubleTap = true;\n        }\n\n        *isTapDetected = true;\n    }\n    else\n    {\n    \t*isTapDetected = false;\n    }\n\n    return ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.tapDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.tapDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetTapDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.tapDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedAbilityHandle(unsigned int abilityHandle)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandle = abilityHandle;\n\t_ATMO_FXOS8700_config.doubleTapDetectedAbilityHandleRegistered = true;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_SetDoubleTapDetectedCallback(ATMO_Callback_t cb)\n{\n\tif(!fxos8700Enabled)\n\t{\n\t\treturn ATMO_FXOS8700_Status_Fail;\n\t}\n\t_ATMO_FXOS8700_config.doubleTapDetectedCallback = cb;\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableFreefallDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = true;\n\t_ATMO_FXOS8700_config.config.motionEnabled = false;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = false;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableMotionDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = false;\n\t_ATMO_FXOS8700_config.config.motionEnabled = true;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = false;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_EnableTapDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = false;\n\t_ATMO_FXOS8700_config.config.motionEnabled = false;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = true;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\nATMO_FXOS8700_Status_t ATMO_FXOS8700_DisableAllDetection()\n{\n\t_ATMO_FXOS8700_config.config.freefallEnabled = false;\n\t_ATMO_FXOS8700_config.config.motionEnabled = false;\n\t_ATMO_FXOS8700_config.config.tapDetectionEnabled = false;\n\tATMO_FXOS8700_EnableInterrupts();\n\treturn ATMO_FXOS8700_Status_Success;\n}\n\n\n",
                "fxos8700_internal.c": "/*\n * The Clear BSD License\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\n * Copyright 2016-2017 NXP\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided\n * that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"fxos8700_internal.h\"\n\n#define EN_FFMT_INTERRUPT 1\n\n/******************************************************************************\n * Code\n ******************************************************************************/\n\nfxos8700_status_t FXOS8700_SetStandby(fxos8700_handle_t *fxos8700_handle)\n{\n\tuint8_t tmp[1];\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp[0] & (uint8_t)~FXOS8700_ACTIVE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Read again to make sure we are in standby mode. */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if ((tmp[0] & FXOS8700_ACTIVE_MASK) == FXOS8700_ACTIVE_MASK)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\nfxos8700_status_t FXOS8700_SetActive(fxos8700_handle_t *fxos8700_handle)\n{\n\tuint8_t tmp[1];\n\n    /* Set Active Mode*/ \n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp[0] | (uint8_t)FXOS8700_ACTIVE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n     /* Read Control register again to ensure we are in active mode */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if ((tmp[0] & FXOS8700_ACTIVE_MASK) != FXOS8700_ACTIVE_MASK)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n\n}\n\nfxos8700_status_t FXOS8700_Init(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1] = {0};\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_WHO_AM_I_REG, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if (tmp[0] != FXOS8700_kFXOS_WHO_AM_I_Device_ID)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* go to standby */\n    FXOS8700_SetStandby(fxos8700_handle);\n\n    /* Disable the FIFO */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_F_SETUP_REG, FXOS8700_F_MODE_DISABLED) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef LPSLEEP_HIRES\n    /* enable auto-sleep, low power in sleep, high res in wake */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG2, FXOS8700_SLPE_MASK | FXOS8700_SMOD_LOW_POWER | FXOS8700_MOD_HIGH_RES) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#else\n\n    /* Accel OSR mode: High Resolution*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG2, FXOS8700_MOD_HIGH_RES) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#endif\n\n    /* set MSR OSR=7 ,set FXOS8700 to hybrid mode (both accel and mag on), One-shot magnetic reset is enabled*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_M_CTRL_REG1, (FXOS8700_M_RST_MASK | FXOS8700_M_OSR_MASK | FXOS8700_M_HMS_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Enable hyrid mode auto increment using M_CTRL_REG2 */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_M_CTRL_REG2, (FXOS8700_M_HYB_AUTOINC_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_AUTO_SLEEP\n    /* set auto-sleep wait period to 5s (=5/0.64=~8) */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_ASLP_COUNT_REG, 8) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#endif\n\n#ifdef EN_FXOS_DATAREADY_INTERRUPT\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n\n     if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_DRDY_MASK) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n\n     /* Set Data Ready Interrupt to route to INT1 */\n     if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n     if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_DRDY_MASK) != FXOS8700_Status_Success)\n     {\n         return FXOS8700_Status_Fail;\n     }\n\n#endif\n\n    /* default set to 4g mode */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_XYZ_DATA_CFG_REG, FXOS8700_FULL_SCALE_4G) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n\n    /* Setup the ODR for 200 Hz (Hybrid) and activate the accelerometer */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG1, (FXOS8700_HYB_DATA_RATE_200HZ | FXOS8700_ACTIVE_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Read Control register again to ensure we are in active mode */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG1, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if ((tmp[0] & FXOS8700_ACTIVE_MASK) != FXOS8700_ACTIVE_MASK)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\nfxos8700_status_t FXOS8700_ReadSensorData(fxos8700_handle_t *fxos8700_handle, fxos8700_data_t *sensorData)\n{\n    fxos8700_status_t status = FXOS8700_Status_Success;\n    uint8_t tmp_buff[6] = {0};\n    uint8_t i = 0;\n\n    if (!FXOS8700_ReadReg(fxos8700_handle, FXOS8700_OUT_X_MSB_REG, tmp_buff, 6) == FXOS8700_Status_Success)\n    {\n        status = FXOS8700_Status_Fail;\n    }\n\n    for (i = 0; i < 6; i++)\n    {\n        ((int8_t *)sensorData)[i] = tmp_buff[i];\n    }\n\n    if (!FXOS8700_ReadReg(fxos8700_handle, FXOS8700_M_OUT_X_MSB_REG, tmp_buff, 6) == FXOS8700_Status_Success)\n    {\n        status = FXOS8700_Status_Fail;\n    }\n\n    for (i = 0; i < 6; i++)\n    {\n        ((int8_t *)sensorData)[i + 6] = tmp_buff[i];\n    }\n\n    return status;\n}\n\nfxos8700_status_t FXOS8700_ReadReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t *val, uint8_t bytesNumber)\n{\n    /* Configure I2C xfer */\n    return handle->I2C_Read(&reg, 1, val, bytesNumber) == 0 ? FXOS8700_Status_Success : FXOS8700_Status_Fail;\n}\n\nfxos8700_status_t FXOS8700_WriteReg(fxos8700_handle_t *handle, uint8_t reg, uint8_t val)\n{\n    uint8_t buff[2];\n    buff[0] = reg;\n    buff[1] = val;\n    return handle->I2C_Write(buff, 2) == 0 ? FXOS8700_Status_Success : FXOS8700_Status_Fail;\n}\n\nfxos8700_status_t FXOS8700_MotionDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n\n    uint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable FFMT for motion detect for X and Y axes, latch enable.\n    If Z axis were included in this motion detect setup and the threshold is less than 1G, it will cause motion detect to be triggered.\n    (assuming Z-axis is experiencing gravity)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_CFG_REG, (FXOS8700_XEFE_MASK | FXOS8700_YEFE_MASK | FXOS8700_OAE_MASK|FXOS8700_ELE_MASK)) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set threshold to about 0.5g (0.5g/0.063 g/count = 8)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FT_MT_THS_REG, 0x08) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set debounce to zero */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_COUNT_REG, 0x00) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_FFMT_INTERRUPT\n    /*Enable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that FFMT Interrupt will go to INT2 pin. */\n    /* To route FFMT interrupt to INT1 pin define below */\n    #ifdef EN_FFMT_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    \n    return FXOS8700_Status_Success;\n\n}\n\nfxos8700_status_t FXOS8700_MotionDetectFreefall_DeInit(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1];\n    \n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Reset Freefall/Motion Config Register to 0. Disables FF and Motion Detection*/ \n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_CFG_REG, 0x0 != FXOS8700_Status_Success))\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n\n#ifdef EN_FFMT_INTERRUPT\n    /*Disable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] & (uint8_t)~FXOS8700_INT_EN_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    #ifdef EN_FFMT_INT1_PIN\n    /* Reset to default behavior */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|(uint8_t)~FXOS8700_INT_CFG_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif \n\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\n\n\nfxos8700_status_t FXOS8700_FreefallDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1] = {0};\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Freefall detect is triggered when combined X,Y,Z magnitude is less than the threshold. Latch also enabled. */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_CFG_REG, FXOS8700_ZEFE_MASK|FXOS8700_YEFE_MASK|FXOS8700_XEFE_MASK|FXOS8700_ELE_MASK)  != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set threshold to about 0.25g (0.25g/0.063 g/count = 4)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FT_MT_THS_REG, 0x04) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set debounce to zero */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_FF_MT_COUNT_REG, 0x00) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_FFMT_INTERRUPT\n    /*Enable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that FFMT Interrupt will go to INT2 pin. */\n    /* To route FFMT interrupt to INT1 pin define below */\n    #ifdef EN_FFMT_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_FF_MT_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif\n\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\n\n\nfxos8700_status_t FXOS8700_TapDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n\tuint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable PULSE_CFG for only single tap  */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, FXOS8700_PELE_MASK|FXOS8700_ZSPEFE_MASK|FXOS8700_YSPEFE_MASK|FXOS8700_XSPEFE_MASK ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable PULSE_CFG for only double tap  */\n    #if DOUBLE_TAP && !SINGLE_TAP\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, FXOS8700_PELE_MASK|FXOS8700_ZDPEFE_MASK|FXOS8700_YDPEFE_MASK|FXOS8700_XDPEFE_MASK ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    #endif \n\n\t#if DOUBLE_TAP && SINGLE_TAP\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, FXOS8700_PELE_MASK|FXOS8700_ZDPEFE_MASK|FXOS8700_ZSPEFE_MASK|FXOS8700_YDPEFE_MASK|FXOS8700_YSPEFE_MASK|FXOS8700_XDPEFE_MASK|FXOS8700_XSPEFE_MASK ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\t#endif\n\n    /* set PULSE_THSX to about 2g */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_THSX_REG, 0x20) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set PULSE_THSY to about 2g */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_THSY_REG, 0x20) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set PULSE_THSZ to about 3g */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_THSZ_REG, 0x0C) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set the Pulse Time Window (PULSE_TMLT) to 6 counts */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_TMLT_REG, 0x06) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set the Pulse Latency Timer to 40 counts */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_LTCY_REG, 0x28) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set the Second Pulse Time Window to 15 counts */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_WIND_REG, 0x0F) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_TAP_INTERRUPT\n\n    /*Enable Tap/Pulse Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that Pulse Interrupt will go to INT2 pin. */\n    /* To route Pulse interrupt to INT1 pin define below */\n    #ifdef EN_PULSE_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    #endif\n#endif\n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n   \n    return FXOS8700_Status_Success;\n}\n\n\n\nfxos8700_status_t FXOS8700_TapDetect_DeInit(fxos8700_handle_t *fxos8700_handle)\n{\n\n\tuint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable PULSE_CFG for only single tap  */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_PULSE_CFG_REG, 0x0 ) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n\n#ifdef EN_TAP_INTERRUPT\n\n    /*Disable Pulse Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] & (uint8_t)~FXOS8700_INT_EN_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that Pulse Interrupt will go to INT2 pin. */\n    /* To route Pulse interrupt to INT1 pin define below */\n    #ifdef EN_PULSE_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|(uint8_t)~FXOS8700_INT_CFG_PULSE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    \n    #endif\n#endif \n\n    /* Set Active Mode*/ \n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n   \n    return FXOS8700_Status_Success;\n}\n\n\nfxos8700_status_t FXOS8700_TransientDetect_Init(fxos8700_handle_t *fxos8700_handle)\n{\n    uint8_t tmp[1] = {0};\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* enable TRANSIENT CFG REG for Transient detect for X,Y,Z axis.latch enabled */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_CFG_REG, FXOS8700_TELE_MASK |FXOS8700_ZTEFE_MASK|FXOS8700_YTEFE_MASK|FXOS8700_XTEFE_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set threshold to about 0.25g (0.25g/0.063 g/count = 4)*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_THS_REG, 0x04) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set debounce to zero */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_COUNT_REG, 0x00) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* set High-Pass Filter to 2Hz (Sampling Rate = 200Hz, Oversample Mode = High Res) Check APP note AN4071 */\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_HP_FILTER_CUTOFF_REG, 0x03) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /*Enable Transient Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] | FXOS8700_INT_EN_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Default behavior for CTRL_REG5 is that FFMT Interrupt will go to INT2 pin. */\n    /* To route TRANS interrupt to INT1 pin define below */\n#ifdef EN_TRANS_INT1_PIN\n\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|FXOS8700_INT_CFG_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#endif\n\n    /* Set Active Mode*/\n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n\nfxos8700_status_t FXOS8700_TransientDetect_DeInit(fxos8700_handle_t *fxos8700_handle)\n{\n\n    uint8_t tmp[1];\n\n    /* go to standby */\n    if (FXOS8700_SetStandby(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /* Reset Transient Config Register to 0. Disables Transient Detection*/\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_TRANSIENT_CFG_REG, 0x0 != FXOS8700_Status_Success))\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    /*Disable Motion Detect Interrupt*/\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG4, tmp[0] & (uint8_t)~FXOS8700_INT_EN_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n#ifdef EN_TRANS_INT1_PIN\n    /* Reset to default behavior */\n    if(FXOS8700_ReadReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp, 1) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n    if(FXOS8700_WriteReg(fxos8700_handle, FXOS8700_CTRL_REG5, tmp[0]|(uint8_t)~FXOS8700_INT_CFG_TRANS_MASK) != FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n#endif\n\n    /* Set Active Mode*/\n    if (FXOS8700_SetActive(fxos8700_handle)!= FXOS8700_Status_Success)\n    {\n        return FXOS8700_Status_Fail;\n    }\n\n    return FXOS8700_Status_Success;\n}\n"
              }
            }
          },
          "md5": "36cf0fe3a90e560a67be2c20c6a2e17b"
        },
        "fxas21002": {
          "libName": "fxas21002",
          "manufacturer": "NXP Semiconductors",
          "description": "Gyroscope",
          "type": "Gyroscope",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/adafruit-industries-llc/3463/1528-2130-ND/7064490"
              },
              "cartData": {
                "part": " 1528-2130-ND",
                "partid": "3463",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c"
          ],
          "elements": [
            {
              "name": "FXAS21002Gyroscope",
              "type": "EmbeddedFXAS21002",
              "icon": "EmbeddedGyroscope.svg",
              "defaultAbility": "getSensorData",
              "defaultTrigger": "sensorDataRead",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/nxpfxas21002element.html",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "hidden": true,
                  "code": "\tATMO_FXAS21002_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.samplingRate = ATMO_PROPERTY(undefined, samplingRate);\n\tATMO_FXAS21002_Init(&config);\n\treturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_FXAS21002_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_FXAS21002_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_FXAS21002_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "getSensorData",
                  "triggers": [
                    "sensorDataRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\tATMO_3dFloatVector_t atmoVec;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tatmoVec.x = data.X;\n\tatmoVec.y = data.Y;\n\tatmoVec.z = data.Z;\n\n\tATMO_CreateValue3dVectorFloat(out, &atmoVec);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getDpsX",
                  "triggers": [
                    "dpsXRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.X);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getDpsY",
                  "triggers": [
                    "dpsYRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.Y);\n\treturn ATMO_Status_Success;\n"
                },
                {
                  "name": "getDpsZ",
                  "triggers": [
                    "dpsZRead"
                  ],
                  "code": "\tATMO_FXAS21002_SensorData_t data;\n\n\tif(ATMO_FXAS21002_GetSensorData(&data) != ATMO_FXAS21002_Status_Success)\n\t{\n\t\tATMO_CreateValueVoid(out);\n\t\treturn ATMO_Status_Fail;\n\t}\n\n\tATMO_CreateValueFloat(out, data.Z);\n\treturn ATMO_Status_Success;\n"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x20"
                },
                {
                  "name": "samplingRate",
                  "input": "select",
                  "inputOptions": [
                    "FXAS21002_CTRL_REG1_DR_12_5HZ",
                    "FXAS21002_CTRL_REG1_DR_25HZ",
                    "FXAS21002_CTRL_REG1_DR_50HZ",
                    "FXAS21002_CTRL_REG1_DR_100HZ",
                    "FXAS21002_CTRL_REG1_DR_200HZ",
                    "FXAS21002_CTRL_REG1_DR_400HZ",
                    "FXAS21002_CTRL_REG1_DR_800HZ"
                  ],
                  "value": "FXAS21002_CTRL_REG1_DR_12_5HZ"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedFXAS21002": "FXAS21002 Gyroscope",
                  "FXAS21002_CTRL_REG1_DR_12_5HZ": "12.5 Hz",
                  "FXAS21002_CTRL_REG1_DR_25HZ": "25 Hz",
                  "FXAS21002_CTRL_REG1_DR_50HZ": "50 Hz",
                  "FXAS21002_CTRL_REG1_DR_100HZ": "100 Hz",
                  "FXAS21002_CTRL_REG1_DR_200HZ": "200 Hz",
                  "FXAS21002_CTRL_REG1_DR_400HZ": "400 Hz",
                  "FXAS21002_CTRL_REG1_DR_800HZ": "800 Hz",
                  "samplingRate": "Sample Rate",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "getSensorData": "Get Sensor Data",
                  "sensorDataRead": "Sensor Data Read",
                  "getDpsX": "Get X Rotation Speed (DPS)",
                  "getDpsY": "Get Y Rotation Speed (DPS)",
                  "getDpsZ": "Get Z Rotation Speed (DPS)",
                  "dpsXRead": "Read X Rotation Speed (DPS)",
                  "dpsYRead": "Read Y Rotation Speed (DPS)",
                  "dpsZRead": "Read Z Rotation Speed (DPS)"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "fxas21002.h": "#ifndef _ATMO_FXAS21002_H_\n#define _ATMO_FXAS21002_H_\n\n#include \"../i2c/i2c.h\"\n#include \"fxas21002_internal.h\"\n\ntypedef enum {\n    ATMO_FXAS21002_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_FXAS21002_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_FXAS21002_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_FXAS21002_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_FXAS21002_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_FXAS21002_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    uint8_t samplingRate;\n} ATMO_FXAS21002_Config_t;\n\n// X Y Z values in DPS\ntypedef struct {\n\tfloat X;\n\tfloat Y;\n\tfloat Z;\n} ATMO_FXAS21002_SensorData_t;\n\n/**\n * Initialize FXAS21002 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_Init(ATMO_FXAS21002_Config_t *config);\n\n/**\n * Enable/Disable FXAS21002 Driver\n *\n * @param[in] enabled\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of FXAS21002 driver\n *\n * @param[out] enabled\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetConfiguration(const ATMO_FXAS21002_Config_t *config);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetConfiguration(ATMO_FXAS21002_Config_t *config);\n\n/**\n * Get XYZ data from sensor\n *\n * @param[out] data\n */\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetSensorData(ATMO_FXAS21002_SensorData_t *data);\n\n#endif\n",
                "fxas21002_internal.h": "/*\n * The Clear BSD License\n * Copyright (c) 2015, Freescale Semiconductor, Inc.\n * Copyright 2016-2017 NXP\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted (subject to the limitations in the disclaimer below) provided\n * that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS LICENSE.\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file fxas21002.h\n * @brief The fxas21002.h contains the fxas21002 sensor register definitions and its bit mask.\n*/\n\n#ifndef FXAS21002_H_\n#define FXAS21002_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/**\n **  FXAS21002 I2C Address\n */\n#define   FXAS21002_I2C_ADDRESS     0x20\n\n/**\n **\n ** @brief The FXAS21002 Sensor Register  Map.\n */\nenum {\n     FXAS21002_STATUS             = 0x00,\n     FXAS21002_OUT_X_MSB          = 0x01,\n     FXAS21002_OUT_X_LSB          = 0x02,\n     FXAS21002_OUT_Y_MSB          = 0x03,\n     FXAS21002_OUT_Y_LSB          = 0x04,\n     FXAS21002_OUT_Z_MSB          = 0x05,\n     FXAS21002_OUT_Z_LSB          = 0x06,\n     FXAS21002_DR_STATUS          = 0x07,\n     FXAS21002_F_STATUS           = 0x08,\n     FXAS21002_F_SETUP            = 0x09,\n     FXAS21002_F_EVENT            = 0x0A,\n     FXAS21002_INT_SRC_FLAG       = 0x0B,\n     FXAS21002_WHO_AM_I           = 0x0C,\n     FXAS21002_CTRL_REG0          = 0x0D,\n     FXAS21002_RT_CFG             = 0x0E,\n     FXAS21002_RT_SRC             = 0x0F,\n     FXAS21002_RT_THS             = 0x10,\n     FXAS21002_RT_COUNT           = 0x11,\n     FXAS21002_TEMP               = 0x12,\n     FXAS21002_CTRL_REG1          = 0x13,\n     FXAS21002_CTRL_REG2          = 0x14,\n     FXAS21002_CTRL_REG3          = 0x15,\n};\n\n\n/*--------------------------------\n** Register: STATUS\n** Enum: FXAS21002_STATUS\n** --\n** Offset : 0x00 - Alias for DR_STATUS or F_STATUS.\n** ------------------------------*/\ntypedef uint8_t FXAS21002_STATUS_t;\n\n\n\n/*--------------------------------\n** Register: OUT_X_MSB\n** Enum: FXAS21002_OUT_X_MSB\n** --\n** Offset : 0x01 - 8 MSBs of 16 bit X-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_X_MSB_t;\n\n\n/*--------------------------------\n** Register: OUT_X_LSB\n** Enum: FXAS21002_OUT_X_LSB\n** --\n** Offset : 0x02 - 8 LSBs of 16 bit X-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_X_LSB_t;\n\n\n\n/*--------------------------------\n** Register: OUT_Y_MSB\n** Enum: FXAS21002_OUT_Y_MSB\n** --\n** Offset : 0x03 - 8 MSBs of 16 bit Y-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Y_MSB_t;\n\n\n/*--------------------------------\n** Register: OUT_Y_LSB\n** Enum: FXAS21002_OUT_Y_LSB\n** --\n** Offset : 0x04 - 8 LSBs of 16 bit Y-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Y_LSB_t;\n\n\n\n/*--------------------------------\n** Register: OUT_Z_MSB\n** Enum: FXAS21002_OUT_Z_MSB\n** --\n** Offset : 0x05 - 8 MSBs of 16 bit Z-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Z_MSB_t;\n\n\n/*--------------------------------\n** Register: OUT_Z_LSB\n** Enum: FXAS21002_OUT_Z_LSB\n** --\n** Offset : 0x06 - 8 LSBs of 16 bit Z-axis data sample\n** ------------------------------*/\ntypedef uint8_t FXAS21002_OUT_Z_LSB_t;\n\n\n\n/*--------------------------------\n** Register: DR_STATUS\n** Enum: FXAS21002_DR_STATUS\n** --\n** Offset : 0x07 - Data-ready status information (FIFO disabled by setting F_SETUP :: F_MODE = 0)\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                   xdr : 1; /*  X-axis new data available.                                                 */\n\n        uint8_t                   ydr : 1; /*  Y-axis new data available.                                                 */\n\n        uint8_t                   zdr : 1; /*  Z-axis new data available.                                                 */\n\n        uint8_t                 zyxdr : 1; /*  X-, Y-, and Z-axis data available.                                         */\n\n        uint8_t                   xow : 1; /*  X-axis data overwrite.                                                     */\n\n        uint8_t                   yow : 1; /*  Y-axis data overwrite.                                                     */\n\n        uint8_t                   zow : 1; /*  Z-axis data overwrite.                                                     */\n\n        uint8_t                 zyxow : 1; /*  X-, Y-, Z-axis data overwrite.                                             */\n\n    } b;\n    uint8_t w;\n} FXAS21002_DR_STATUS_t;\n\n\n/*\n** DR_STATUS - Bit field mask definitions\n*/\n#define FXAS21002_DR_STATUS_XDR_MASK     ((uint8_t) 0x01)\n#define FXAS21002_DR_STATUS_XDR_SHIFT    ((uint8_t)    0)\n\n#define FXAS21002_DR_STATUS_YDR_MASK     ((uint8_t) 0x02)\n#define FXAS21002_DR_STATUS_YDR_SHIFT    ((uint8_t)    1)\n\n#define FXAS21002_DR_STATUS_ZDR_MASK     ((uint8_t) 0x04)\n#define FXAS21002_DR_STATUS_ZDR_SHIFT    ((uint8_t)    2)\n\n#define FXAS21002_DR_STATUS_ZYXDR_MASK   ((uint8_t) 0x08)\n#define FXAS21002_DR_STATUS_ZYXDR_SHIFT  ((uint8_t)    3)\n\n#define FXAS21002_DR_STATUS_XOW_MASK     ((uint8_t) 0x10)\n#define FXAS21002_DR_STATUS_XOW_SHIFT    ((uint8_t)    4)\n\n#define FXAS21002_DR_STATUS_YOW_MASK     ((uint8_t) 0x20)\n#define FXAS21002_DR_STATUS_YOW_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_DR_STATUS_ZOW_MASK     ((uint8_t) 0x40)\n#define FXAS21002_DR_STATUS_ZOW_SHIFT    ((uint8_t)    6)\n\n#define FXAS21002_DR_STATUS_ZYXOW_MASK   ((uint8_t) 0x80)\n#define FXAS21002_DR_STATUS_ZYXOW_SHIFT  ((uint8_t)    7)\n\n\n/*\n** DR_STATUS - Bit field value definitions\n*/\n#define FXAS21002_DR_STATUS_XDR_DRDY              ((uint8_t) 0x01)  /*  Set to 1 whenever a new X-axis data acquisition   */\n                                                                    /*  is completed. Cleared anytime the OUT_X_MSB       */\n                                                                    /*  register is read.                                 */\n#define FXAS21002_DR_STATUS_YDR_DRDY              ((uint8_t) 0x02)  /*  Set to 1 whenever a new Y-axis data acquisition   */\n                                                                    /*  is completed. Cleared anytime the OUT_Y_MSB       */\n                                                                    /*  register is read.                                 */\n#define FXAS21002_DR_STATUS_ZDR_DRDY              ((uint8_t) 0x04)  /*  Set to 1 whenever a new Z-axis data acquisition   */\n                                                                    /*  is completed. Cleared anytime the OUT_Z_MSB       */\n                                                                    /*  register is read.                                 */\n#define FXAS21002_DR_STATUS_ZYXDR_DRDY            ((uint8_t) 0x08)  /*  Cleared when the high-bytes of the acceleration   */\n                                                                    /*  data (OUT_X_MSB, OUT_Y_MSB, OUT_Z_MSB) are read.  */\n#define FXAS21002_DR_STATUS_XOW_OWR               ((uint8_t) 0x10)  /*  Asserted whenever a new X-axis acquisition is     */\n                                                                    /*  completed before the retrieval of the previous    */\n                                                                    /*  data.                                             */\n#define FXAS21002_DR_STATUS_YOW_OWR               ((uint8_t) 0x20)  /*  Asserted whenever a new Y-axis acquisition is     */\n                                                                    /*  completed before the retrieval of the previous    */\n                                                                    /*  data.                                             */\n#define FXAS21002_DR_STATUS_ZOW_OWR               ((uint8_t) 0x40)  /*  Asserted whenever a new Z-axis acquisition is     */\n                                                                    /*  completed before the retrieval of the previous    */\n                                                                    /*  data.                                             */\n#define FXAS21002_DR_STATUS_ZYXOW_OWR             ((uint8_t) 0x80)  /*  Asserted whenever new X-, Y-, and Z-axis data is  */\n                                                                    /*  acquired before completing the retrieval of the   */\n                                                                    /*  previous set.                                     */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: F_STATUS\n** Enum: FXAS21002_F_STATUS\n** --\n** Offset : 0x08 - FIFO status information (FIFO enabled by setting F_SETUP :: F_MODE > 0)\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                 f_cnt : 6; /*  FIFO sample counter; indicates the number of samples currently stored in   */\n                                           /*  the FIFO.                                                                  */\n\n        uint8_t                f_wmkf : 1; /*  FIFO sample count greater than or equal to the watermark count (F_SETUP :: */\n                                           /*  F_WMRK) has been detected.                                                 */\n\n        uint8_t                 f_ovf : 1; /*  FIFO overflow event, such as when F_CNT = 32 and a new sample arrives,     */\n                                           /*  asserts the F_OVF flag.                                                    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_F_STATUS_t;\n\n\n/*\n** F_STATUS - Bit field mask definitions\n*/\n#define FXAS21002_F_STATUS_F_CNT_MASK    ((uint8_t) 0x3F)\n#define FXAS21002_F_STATUS_F_CNT_SHIFT   ((uint8_t)    0)\n\n#define FXAS21002_F_STATUS_F_WMKF_MASK   ((uint8_t) 0x40)\n#define FXAS21002_F_STATUS_F_WMKF_SHIFT  ((uint8_t)    6)\n\n#define FXAS21002_F_STATUS_F_OVF_MASK    ((uint8_t) 0x80)\n#define FXAS21002_F_STATUS_F_OVF_SHIFT   ((uint8_t)    7)\n\n\n/*\n** F_STATUS - Bit field value definitions\n*/\n#define FXAS21002_F_STATUS_F_WMKF_DETECT         ((uint8_t) 0x40)  /*  FIFO Watermark event has been detected.            */\n#define FXAS21002_F_STATUS_F_OVF_DETECT          ((uint8_t) 0x80)  /*  FIFO Overflow event has been detected.             */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: F_SETUP\n** Enum: FXAS21002_F_SETUP\n** --\n** Offset : 0x09 - FIFO configuration\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                f_wmrk : 6; /*  FIFO operating mode selection.                                             */\n\n        uint8_t                f_mode : 2; /*  FIFO sample count watermark setting.                                       */\n\n    } b;\n    uint8_t w;\n} FXAS21002_F_SETUP_t;\n\n\n/*\n** F_SETUP - Bit field mask definitions\n*/\n#define FXAS21002_F_SETUP_F_WMRK_MASK   ((uint8_t) 0x3F)\n#define FXAS21002_F_SETUP_F_WMRK_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_F_SETUP_F_MODE_MASK   ((uint8_t) 0xC0)\n#define FXAS21002_F_SETUP_F_MODE_SHIFT  ((uint8_t)    6)\n\n\n/*\n** F_SETUP - Bit field value definitions\n*/\n#define FXAS21002_F_SETUP_F_MODE_FIFO_OFF       ((uint8_t) 0x00)  /*  FIFO is disabled.                                   */\n#define FXAS21002_F_SETUP_F_MODE_CIR_MODE       ((uint8_t) 0x40)  /*  FIFO is in Circular Buffer mode.                    */\n#define FXAS21002_F_SETUP_F_MODE_STOP_MODE      ((uint8_t) 0x80)  /*  FIFO is in Stop mode.                               */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: F_EVENT\n** Enum: FXAS21002_F_EVENT\n** --\n** Offset : 0x0A - FIFO event status\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t               fe_time : 5; /*  Number of ODR periods elapsed since F_EVENT was set.                       */\n\n        uint8_t               f_event : 1; /*  FIFO Event: Indicates if either F_WMKF or F_OVF flags are set (logical     */\n                                           /*  OR).                                                                       */\n\n    } b;\n    uint8_t w;\n} FXAS21002_F_EVENT_t;\n\n\n/*\n** F_EVENT - Bit field mask definitions\n*/\n#define FXAS21002_F_EVENT_FE_TIME_MASK   ((uint8_t) 0x1F)\n#define FXAS21002_F_EVENT_FE_TIME_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_F_EVENT_F_EVENT_MASK   ((uint8_t) 0x20)\n#define FXAS21002_F_EVENT_F_EVENT_SHIFT  ((uint8_t)    5)\n\n\n/*\n** F_EVENT - Bit field value definitions\n*/\n#define FXAS21002_F_EVENT_F_EVENT_DETECTED      ((uint8_t) 0x20)  /*  FIFO event was detected                             */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: INT_SRC_FLAG\n** Enum: FXAS21002_INT_SRC_FLAG\n** --\n** Offset : 0x0B - Interrupt source status\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t              src_drdy : 1; /*  Data ready event source flag.                                              */\n\n        uint8_t                src_rt : 1; /*  Rate threshold event source flag.                                          */\n\n        uint8_t              src_fifo : 1; /*  FIFO event source flag.                                                    */\n\n        uint8_t               bootend : 1; /*  Boot sequence complete event flag.                                         */\n\n    } b;\n    uint8_t w;\n} FXAS21002_INT_SRC_FLAG_t;\n\n\n/*\n** INT_SRC_FLAG - Bit field mask definitions\n*/\n#define FXAS21002_INT_SRC_FLAG_SRC_DRDY_MASK   ((uint8_t) 0x01)\n#define FXAS21002_INT_SRC_FLAG_SRC_DRDY_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_INT_SRC_FLAG_SRC_RT_MASK     ((uint8_t) 0x02)\n#define FXAS21002_INT_SRC_FLAG_SRC_RT_SHIFT    ((uint8_t)    1)\n\n#define FXAS21002_INT_SRC_FLAG_SRC_FIFO_MASK   ((uint8_t) 0x04)\n#define FXAS21002_INT_SRC_FLAG_SRC_FIFO_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_INT_SRC_FLAG_BOOTEND_MASK    ((uint8_t) 0x08)\n#define FXAS21002_INT_SRC_FLAG_BOOTEND_SHIFT   ((uint8_t)    3)\n\n\n/*\n** INT_SRC_FLAG - Bit field value definitions\n*/\n#define FXAS21002_INT_SRC_FLAG_SRC_DRDY_READY        ((uint8_t) 0x01)  /*  Asserted whenever a data-ready event triggers  */\n                                                                       /*  the interrupt.                                 */\n#define FXAS21002_INT_SRC_FLAG_SRC_RT_THRESH         ((uint8_t) 0x02)  /*  Indicates that the rate threshold event flag   */\n                                                                       /*  triggered the interrupt.                       */\n#define FXAS21002_INT_SRC_FLAG_SRC_FIFO_EVENT        ((uint8_t) 0x04)  /*  F_OVF or F_WMKF are set, provided the FIFO     */\n                                                                       /*  interrupt is enabled.                          */\n#define FXAS21002_INT_SRC_FLAG_BOOTEND_BOOT_DONE     ((uint8_t) 0x08)  /*  Boot sequence is complete.                     */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: WHO_AM_I\n** Enum: FXAS21002_WHO_AM_I\n** --\n** Offset : 0x0C - The WHO_AM_I register contains the device idenifier.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                whoami; /*  The WHO_AM_I register contains the device identifier which is factory          */\n                                       /*  programmed.                                                                    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_WHO_AM_I_t;\n\n\n/*\n** WHO_AM_I - Bit field mask definitions\n*/\n#define FXAS21002_WHO_AM_I_WHOAMI_MASK   ((uint8_t) 0xFF)\n#define FXAS21002_WHO_AM_I_WHOAMI_SHIFT  ((uint8_t)    0)\n\n\n/*\n** WHO_AM_I - Bit field value definitions\n*/\n#define FXAS21002_WHO_AM_I_WHOAMI_OLD_VALUE     ((uint8_t) 0xd1)  /*  FXAS21000                       */\n#define FXAS21002_WHO_AM_I_WHOAMI_PRE_VALUE     ((uint8_t) 0xd6)  /*  Engineering Samples             */\n#define FXAS21002_WHO_AM_I_WHOAMI_PROD_VALUE    ((uint8_t) 0xd7)  /*  FXAS21002 Rev 2.1 (production)  */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: CTRL_REG0\n** --\n** Offset : 0x0D - Used for general control and configuration.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                    fs : 2; /*  Full-scale range selection.                                                */\n\n        uint8_t                hpf_en : 1; /*  High-pass filter enable. The high-pass filter is initialized on operating  */\n                                           /*  mode and ODR change. When enabled, the HPF is applied to the angular rate  */\n                                           /*  data supplied to the output registers/FIFO and the embedded rate threshold */\n                                           /*  algorithm.                                                                 */\n\n        uint8_t                   sel : 2; /*  High-pass filter cutoff frequency selection.                               */\n\n        uint8_t                  spiw : 1; /*  SPI interface mode selection.                                              */\n\n        uint8_t                    bw : 2; /*  Bandwidth selects the cut-off frequency of the digital low-pass filter.    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG0_t;\n\n\n/*\n** CTRL_REG0 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG0_FS_MASK       ((uint8_t) 0x03)\n#define FXAS21002_CTRL_REG0_FS_SHIFT      ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG0_HPF_EN_MASK   ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG0_HPF_EN_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG0_SEL_MASK      ((uint8_t) 0x18)\n#define FXAS21002_CTRL_REG0_SEL_SHIFT     ((uint8_t)    3)\n\n#define FXAS21002_CTRL_REG0_SPIW_MASK     ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG0_SPIW_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_CTRL_REG0_BW_MASK       ((uint8_t) 0xC0)\n#define FXAS21002_CTRL_REG0_BW_SHIFT      ((uint8_t)    6)\n\n\n/*\n** CTRL_REG0 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG0_FS_DPS2000            ((uint8_t) 0x00)  /*  2000 degrees per second (4000 dps if CTRL_REG3 :  */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_FS_DPS1000            ((uint8_t) 0x01)  /*  1000 degrees per second (2000 dps if CTRL_REG3 :  */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_FS_DPS500             ((uint8_t) 0x02)  /*  500 degrees per second (1000 dps if CTRL_REG3 :   */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_FS_DPS250             ((uint8_t) 0x03)  /*  250 degrees per second (500 dps if CTRL_REG3 :    */\n                                                                    /*  FS_DOUBLE = 1).                                   */\n#define FXAS21002_CTRL_REG0_HPF_EN_ENABLE         ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG0_HPF_EN_DISABLE        ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG0_SPIW_4WIRE            ((uint8_t) 0x00)  /*  SPI 4-wire mode (default).                        */\n#define FXAS21002_CTRL_REG0_SPIW_3WIRE            ((uint8_t) 0x20)  /*  SPI 3-wire mode (MOSI pin is used for SPI input   */\n                                                                    /*  and output signals).                              */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_CFG\n** Enum: FXAS21002_RT_CFG\n** --\n** Offset : 0x0E - Used to enable the Rate Threshold interrupt generation.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                 xtefe : 1; /*  Event flag enable on X rate.                                               */\n\n        uint8_t                 ytefe : 1; /*  Event flag enable on Y rate.                                               */\n\n        uint8_t                 ztefe : 1; /*  Event flag enable on Z rate.                                               */\n\n        uint8_t                   ele : 1; /*  Event latch enable.                                                        */\n\n    } b;\n    uint8_t w;\n} FXAS21002_RT_CFG_t;\n\n\n/*\n** RT_CFG - Bit field mask definitions\n*/\n#define FXAS21002_RT_CFG_XTEFE_MASK   ((uint8_t) 0x01)\n#define FXAS21002_RT_CFG_XTEFE_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_RT_CFG_YTEFE_MASK   ((uint8_t) 0x02)\n#define FXAS21002_RT_CFG_YTEFE_SHIFT  ((uint8_t)    1)\n\n#define FXAS21002_RT_CFG_ZTEFE_MASK   ((uint8_t) 0x04)\n#define FXAS21002_RT_CFG_ZTEFE_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_RT_CFG_ELE_MASK     ((uint8_t) 0x08)\n#define FXAS21002_RT_CFG_ELE_SHIFT    ((uint8_t)    3)\n\n\n/*\n** RT_CFG - Bit field value definitions\n*/\n#define FXAS21002_RT_CFG_XTEFE_ENABLE          ((uint8_t) 0x01)  /*  X event detection enabled.                           */\n#define FXAS21002_RT_CFG_XTEFE_DISABLE         ((uint8_t) 0x00)  /*  X event detection disabled.                          */\n#define FXAS21002_RT_CFG_YTEFE_ENABLE          ((uint8_t) 0x02)  /*  Y event detection enabled.                           */\n#define FXAS21002_RT_CFG_YTEFE_DISABLE         ((uint8_t) 0x00)  /*  Y event detection disabled.                          */\n#define FXAS21002_RT_CFG_ZTEFE_ENABLE          ((uint8_t) 0x04)  /*  Z event detection enabled.                           */\n#define FXAS21002_RT_CFG_ZTEFE_DISABLE         ((uint8_t) 0x00)  /*  Z event detection disabled.                          */\n#define FXAS21002_RT_CFG_ELE_ENABLE            ((uint8_t) 0x08)  /*  Event flag latch enabled.                            */\n#define FXAS21002_RT_CFG_ELE_DISABLE           ((uint8_t) 0x00)  /*  Event flag latch disabled.                           */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_SRC\n** Enum: FXAS21002_RT_SRC\n** --\n** Offset : 0x0F - Indicates the source of the Rate Threshold event. It also clears the RT_SRC flag in the INT_SOURCE_FLAG register.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t              x_rt_pol : 1; /*  Polarity of X event.                                                       */\n\n        uint8_t                   xrt : 1; /*  X rate Event.                                                              */\n\n        uint8_t              y_rt_pol : 1; /*  Polarity of Y event.                                                       */\n\n        uint8_t                   yrt : 1; /*  Y rate event.                                                              */\n\n        uint8_t              z_rt_pol : 1; /*  Polarity of Z event.                                                       */\n\n        uint8_t                   zrt : 1; /*  Z rate event.                                                              */\n\n        uint8_t                    ea : 1; /*  Event active flag.                                                         */\n\n    } b;\n    uint8_t w;\n} FXAS21002_RT_SRC_t;\n\n\n/*\n** RT_SRC - Bit field mask definitions\n*/\n#define FXAS21002_RT_SRC_X_RT_POL_MASK   ((uint8_t) 0x01)\n#define FXAS21002_RT_SRC_X_RT_POL_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_RT_SRC_XRT_MASK        ((uint8_t) 0x02)\n#define FXAS21002_RT_SRC_XRT_SHIFT       ((uint8_t)    1)\n\n#define FXAS21002_RT_SRC_Y_RT_POL_MASK   ((uint8_t) 0x04)\n#define FXAS21002_RT_SRC_Y_RT_POL_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_RT_SRC_YRT_MASK        ((uint8_t) 0x08)\n#define FXAS21002_RT_SRC_YRT_SHIFT       ((uint8_t)    3)\n\n#define FXAS21002_RT_SRC_Z_RT_POL_MASK   ((uint8_t) 0x10)\n#define FXAS21002_RT_SRC_Z_RT_POL_SHIFT  ((uint8_t)    4)\n\n#define FXAS21002_RT_SRC_ZRT_MASK        ((uint8_t) 0x20)\n#define FXAS21002_RT_SRC_ZRT_SHIFT       ((uint8_t)    5)\n\n#define FXAS21002_RT_SRC_EA_MASK         ((uint8_t) 0x40)\n#define FXAS21002_RT_SRC_EA_SHIFT        ((uint8_t)    6)\n\n\n/*\n** RT_SRC - Bit field value definitions\n*/\n#define FXAS21002_RT_SRC_X_RT_POL_POS          ((uint8_t) 0x00)  /*  Rate Event was Positive.                             */\n#define FXAS21002_RT_SRC_X_RT_POL_NEG          ((uint8_t) 0x01)  /*  Rate Event was Negative.                             */\n#define FXAS21002_RT_SRC_XRT_LOWER             ((uint8_t) 0x00)  /*  Rate lower than RT_THS value.                        */\n#define FXAS21002_RT_SRC_XRT_GREATER           ((uint8_t) 0x02)  /*  Rate greater than RT_THS value. Event has occured.   */\n#define FXAS21002_RT_SRC_Y_RT_POL_POS          ((uint8_t) 0x00)  /*  Rate Event was Positive.                             */\n#define FXAS21002_RT_SRC_Y_RT_POL_NEG          ((uint8_t) 0x04)  /*  Rate Event was Negative.                             */\n#define FXAS21002_RT_SRC_YRT_LOWER             ((uint8_t) 0x00)  /*  Rate lower than RT_THS value.                        */\n#define FXAS21002_RT_SRC_YRT_GREATER           ((uint8_t) 0x08)  /*  Rate greater than RT_THS value. Event has occured.   */\n#define FXAS21002_RT_SRC_Z_RT_POL_POS          ((uint8_t) 0x00)  /*  Rate Event was Positive.                             */\n#define FXAS21002_RT_SRC_Z_RT_POL_NEG          ((uint8_t) 0x10)  /*  Rate Event was Negative.                             */\n#define FXAS21002_RT_SRC_ZRT_LOWER             ((uint8_t) 0x00)  /*  Rate lower than RT_THS value.                        */\n#define FXAS21002_RT_SRC_ZRT_GREATER           ((uint8_t) 0x20)  /*  Rate greater than RT_THS value. Event has occured.   */\n#define FXAS21002_RT_SRC_EA_NOEVENT            ((uint8_t) 0x00)  /*  No event flags have been asserted.                   */\n#define FXAS21002_RT_SRC_EA_EVENT              ((uint8_t) 0x40)  /*  One or more event flags have been asserted.          */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_THS\n** Enum: FXAS21002_RT_THS\n** --\n** Offset : 0x10 - The RT_THS register sets the threshold limit for the detection of the rate and the debounce counter mode.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                   ths : 7; /*  Unsigned 7-bit rate threshold value; The contents should only be modified  */\n                                           /*  when the device is in Standby mode; The internal state of the Rate         */\n                                           /*  Threshold function is reset when a transition from Standby to Active or    */\n                                           /*  Ready to Active modes occurs.                                              */\n\n        uint8_t                dbcntm : 1; /*  Debounce counter mode selection.                                           */\n\n    } b;\n    uint8_t w;\n} FXAS21002_RT_THS_t;\n\n\n/*\n** RT_THS - Bit field mask definitions\n*/\n#define FXAS21002_RT_THS_THS_MASK      ((uint8_t) 0x7F)\n#define FXAS21002_RT_THS_THS_SHIFT     ((uint8_t)    0)\n\n#define FXAS21002_RT_THS_DBCNTM_MASK   ((uint8_t) 0x80)\n#define FXAS21002_RT_THS_DBCNTM_SHIFT  ((uint8_t)    7)\n\n\n/*\n** RT_THS - Bit field value definitions\n*/\n#define FXAS21002_RT_THS_DBCNTM_CLEAR          ((uint8_t) 0x80)  /*  Clear counter when angular rate is below the         */\n                                                                 /*  threshold value.                                     */\n#define FXAS21002_RT_THS_DBCNTM_DECREMENT      ((uint8_t) 0x00)  /*  Decrement counter on every ODR cycle that the        */\n                                                                 /*  angular rate is below the threshold value.           */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: RT_COUNT\n** Enum: FXAS21002_RT_COUNT\n** --\n** Offset : 0x11 - Sets the number of debounce counts.\n** ------------------------------*/\ntypedef uint8_t FXAS21002_RT_COUNT_t;\n\n\n\n/*--------------------------------\n** Register: TEMP\n** Enum: FXAS21002_TEMP\n** --\n** Offset : 0x12 - The TEMP register contains an 8-bit 2's complement temperature value with a range of 128 C to +127 C and a scaling of 1 C/LSB.\n** ------------------------------*/\ntypedef uint8_t FXAS21002_TEMP_t;\n\n\n\n/*--------------------------------\n** Register: CTRL_REG1\n** Enum: FXAS21002_CTRL_REG1\n** --\n** Offset : 0x13 - The CTRL_REG1 register is used to configure the device ODR, set the operating mode, soft-reset the device, and exercise the Self-Test function.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                  mode : 2; /*  Operational Mode.                                                          */\n\n        uint8_t                    dr : 3; /*  Output Data Rate selection.                                                */\n\n        uint8_t                    st : 1; /*  Self-Test Enable.                                                          */\n\n        uint8_t                   rst : 1; /*  Software Reset.                                                            */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG1_t;\n\n\n/*\n** CTRL_REG1 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG1_MODE_MASK   ((uint8_t) 0x03)\n#define FXAS21002_CTRL_REG1_MODE_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG1_DR_MASK     ((uint8_t) 0x1C)\n#define FXAS21002_CTRL_REG1_DR_SHIFT    ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG1_ST_MASK     ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG1_ST_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_CTRL_REG1_RST_MASK    ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG1_RST_SHIFT   ((uint8_t)    6)\n\n\n/*\n** CTRL_REG1 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG1_MODE_STANDBY          ((uint8_t) 0x00)  /*  Standby Mode. Register setting allowed. Lowest    */\n                                                                    /*  power.                                            */\n#define FXAS21002_CTRL_REG1_MODE_READY            ((uint8_t) 0x01)  /*  Ready Mode. The device is ready to measure        */\n                                                                    /*  angular rate but no data acquisitions are being   */\n                                                                    /*  made. Register reads only. Reduced power.         */\n#define FXAS21002_CTRL_REG1_MODE_ACTIVE           ((uint8_t) 0x02)  /*  Active Mode. The device is fully functional.      */\n                                                                    /*  Register reads only. Maximum power.               */\n#define FXAS21002_CTRL_REG1_DR_800HZ              ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG1_DR_400HZ              ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG1_DR_200HZ              ((uint8_t) 0x08)\n#define FXAS21002_CTRL_REG1_DR_100HZ              ((uint8_t) 0x0c)\n#define FXAS21002_CTRL_REG1_DR_50HZ               ((uint8_t) 0x10)\n#define FXAS21002_CTRL_REG1_DR_25HZ               ((uint8_t) 0x14)\n#define FXAS21002_CTRL_REG1_DR_12_5HZ             ((uint8_t) 0x18)\n#define FXAS21002_CTRL_REG1_ST_ENABLE             ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG1_ST_DISABLE            ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG1_RST_TRIGGER           ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG1_RST_NOTTRIGGERED      ((uint8_t) 0x00)\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: CTRL_REG2\n** Enum: FXAS21002_CTRL_REG2\n** --\n** Offset : 0x14 - This register enables and assigns the output pin(s) and logic polarities for the various interrupt sources available on the device.\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t                 pp_od : 1; /*  INT1 and INT2 pin output driver configuration.                             */\n\n        uint8_t                  ipol : 1; /*  Interrupt logic polarity.                                                  */\n\n        uint8_t           int_en_drdy : 1; /*  Data ready interrupt enable.                                               */\n\n        uint8_t          int_cfg_drdy : 1; /*  Data-ready interrupt pin routing.                                          */\n\n        uint8_t             int_en_rt : 1; /*  Rate threshold interrupt enable.                                           */\n\n        uint8_t            int_cfg_rt : 1; /*  Rate threshold interrupt pin routing.                                      */\n\n        uint8_t           int_en_fifo : 1; /*  FIFO Interrupt Enable.                                                     */\n\n        uint8_t          int_cfg_fifo : 1; /*  FIFO interrupt pin routing.                                                */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG2_t;\n\n\n/*\n** CTRL_REG2 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG2_PP_OD_MASK          ((uint8_t) 0x01)\n#define FXAS21002_CTRL_REG2_PP_OD_SHIFT         ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG2_IPOL_MASK           ((uint8_t) 0x02)\n#define FXAS21002_CTRL_REG2_IPOL_SHIFT          ((uint8_t)    1)\n\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_MASK    ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_SHIFT   ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_MASK   ((uint8_t) 0x08)\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_SHIFT  ((uint8_t)    3)\n\n#define FXAS21002_CTRL_REG2_INT_EN_RT_MASK      ((uint8_t) 0x10)\n#define FXAS21002_CTRL_REG2_INT_EN_RT_SHIFT     ((uint8_t)    4)\n\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_MASK     ((uint8_t) 0x20)\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_SHIFT    ((uint8_t)    5)\n\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_MASK    ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_SHIFT   ((uint8_t)    6)\n\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_MASK   ((uint8_t) 0x80)\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_SHIFT  ((uint8_t)    7)\n\n\n/*\n** CTRL_REG2 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG2_PP_OD_PUSHPULL        ((uint8_t) 0x00)  /*  Push-pull output driver.                          */\n#define FXAS21002_CTRL_REG2_PP_OD_OPENDRAIN       ((uint8_t) 0x01)  /*  Open-drain output driver.                         */\n#define FXAS21002_CTRL_REG2_IPOL_ACTIVE_LOW       ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_IPOL_ACTIVE_HIGH      ((uint8_t) 0x02)\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_ENABLE    ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG2_INT_EN_DRDY_DISABLE   ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_INT2     ((uint8_t) 0x00)  /*  Interrupt is routed to INT2 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_CFG_DRDY_INT1     ((uint8_t) 0x08)  /*  Interrupt is routed to INT1 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_EN_RT_ENABLE      ((uint8_t) 0x10)\n#define FXAS21002_CTRL_REG2_INT_EN_RT_DISABLE     ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_INT2       ((uint8_t) 0x00)  /*  Interrupt is routed to INT2 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_CFG_RT_INT1       ((uint8_t) 0x20)  /*  Interrupt is routed to INT1 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_ENABLE    ((uint8_t) 0x40)\n#define FXAS21002_CTRL_REG2_INT_EN_FIFO_DISABLE   ((uint8_t) 0x00)\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_INT2     ((uint8_t) 0x00)  /*  Interrupt is routed to INT2 pin.                  */\n#define FXAS21002_CTRL_REG2_INT_CFG_FIFO_INT1     ((uint8_t) 0x80)  /*  Interrupt is routed to INT1 pin.                  */\n/*------------------------------*/\n\n\n\n/*--------------------------------\n** Register: CTRL_REG3\n** Enum: FXAS21002_CTRL_REG3\n** --\n** Offset : 0x15 - Auto-increment address configuration, external power control, Full Scale Range (FSR) expansion\n** ------------------------------*/\ntypedef union {\n    struct {\n        uint8_t             fs_double : 1; /*  Increases the dynamic range for each CTRL_REG0 : FS selection by a factor  */\n                                           /*  of two.                                                                    */\n\n        uint8_t _reserved_            : 1;\n        uint8_t             extctrlen : 1; /*  External power mode control input.                                         */\n\n        uint8_t             wraptoone : 1; /*  Auto-increment read address pointer roll-over behavior.                    */\n\n    } b;\n    uint8_t w;\n} FXAS21002_CTRL_REG3_t;\n\n\n/*\n** CTRL_REG3 - Bit field mask definitions\n*/\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_MASK   ((uint8_t) 0x01)\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_SHIFT  ((uint8_t)    0)\n\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_MASK   ((uint8_t) 0x04)\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_SHIFT  ((uint8_t)    2)\n\n#define FXAS21002_CTRL_REG3_WRAPTOONE_MASK   ((uint8_t) 0x08)\n#define FXAS21002_CTRL_REG3_WRAPTOONE_SHIFT  ((uint8_t)    3)\n\n\n/*\n** CTRL_REG3 - Bit field value definitions\n*/\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_ENABLE      ((uint8_t) 0x01)  /*  Maximum full-scale range selections are doubled   */\n                                                                    /*  (4000, 2000, 1000, 500 dps).                      */\n#define FXAS21002_CTRL_REG3_FS_DOUBLE_DISABLE     ((uint8_t) 0x00)  /*  Maximum full-scale range selections are as per    */\n                                                                    /*  selectable full-scale ranges (2000, 1000, 500,    */\n                                                                    /*  250 dps).                                         */\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_INT2        ((uint8_t) 0x00)  /*  INT2 pin is used as an interrupt output           */\n                                                                    /*  (default).                                        */\n#define FXAS21002_CTRL_REG3_EXTCTRLEN_POWER_CONTROL ((uint8_t) 0x04)  /*  INT2 pin becomes an input pin that may be used  */\n                                                                      /*  to control the power mode.                      */\n#define FXAS21002_CTRL_REG3_WRAPTOONE_ROLL_STATUS ((uint8_t) 0x00)  /*  The auto-increment read address pointer rolls     */\n                                                                    /*  over to address 0x00 (STATUS) after the Z-axis    */\n                                                                    /*  LSB is read (default).                            */\n#define FXAS21002_CTRL_REG3_WRAPTOONE_ROLL_DATA   ((uint8_t) 0x08)  /*  The auto-increment pointer rolls over to address  */\n                                                                    /*  0x01 (X-axis MSB) in order to facilitate the      */\n                                                                    /*  faster read out of the FIFO data in a single      */\n                                                                    /*  burst read operation.                             */\n/*------------------------------*/\n\n\n#endif /* FXAS21002_H_ */\n"
              },
              "objects": {
                "fxas21002.c": "#include \"fxas21002.h\"\n\ntypedef struct {\n    ATMO_FXAS21002_Config_t config;\n    bool configured;\n} ATMO_FXAS21002_Priv_Config;\n\nstatic ATMO_FXAS21002_Priv_Config _ATMO_FXAS21002_config = {0};\n\nstatic bool _ATMO_FXAS21002_Enabled = true;\n\nstatic ATMO_I2C_Status_t ATMO_FXAS21002_ReadReg(uint8_t regId, uint8_t *data, uint8_t len)\n{\n\treturn ATMO_I2C_MasterRead(_ATMO_FXAS21002_config.config.i2cDriverInstance, _ATMO_FXAS21002_config.config.address, &regId, 1, data, len, 1000);\n}\n\nstatic ATMO_I2C_Status_t ATMO_FXAS21002_WriteReg(uint8_t regId, uint8_t data, uint8_t mask)\n{\n\tuint8_t writeByte = data;\n\n\tif(mask)\n\t{\n\t\tif(ATMO_FXAS21002_ReadReg(regId, &writeByte, 1) != ATMO_I2C_Status_Success)\n\t\t{\n\t\t\treturn ATMO_I2C_Status_Fail;\n\t\t}\n\n\t\t// Zero out mask\n\t\twriteByte = (writeByte & (~mask)) | data;\n\t}\n\n\treturn ATMO_I2C_MasterWrite(_ATMO_FXAS21002_config.config.i2cDriverInstance, _ATMO_FXAS21002_config.config.address, &regId, 1, &writeByte, 1, 1000);\n}\n\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_Init(ATMO_FXAS21002_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_FXAS21002_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_FXAS21002_config.configured = false;\n    }\n\n\treturn ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetEnabled(bool enabled)\n{\n\t_ATMO_FXAS21002_Enabled = enabled;\n\treturn ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetEnabled(bool *enabled)\n{\n\t*enabled = _ATMO_FXAS21002_Enabled;\n\treturn ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_SetConfiguration(const ATMO_FXAS21002_Config_t *config)\n{\n    if( config == NULL || !_ATMO_FXAS21002_Enabled)\n    {\n        return ATMO_FXAS21002_Status_Fail;\n    }\n\n    memcpy( &_ATMO_FXAS21002_config.config, config, sizeof(ATMO_FXAS21002_Config_t) );\n    _ATMO_FXAS21002_config.configured = true;\n\n    // Check the whoami register\n    uint8_t whoAmI = 0;\n\n    if(ATMO_FXAS21002_ReadReg(FXAS21002_WHO_AM_I, &whoAmI, 1) != ATMO_I2C_Status_Success || whoAmI != FXAS21002_WHO_AM_I_WHOAMI_PROD_VALUE)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n    // Put into standby mode\n    if(ATMO_FXAS21002_WriteReg(FXAS21002_CTRL_REG1, FXAS21002_CTRL_REG1_MODE_STANDBY, FXAS21002_CTRL_REG1_MODE_MASK) != ATMO_I2C_Status_Success)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n\n    // Set to 12.5hz sampling rate\n    if(ATMO_FXAS21002_WriteReg(FXAS21002_CTRL_REG1, _ATMO_FXAS21002_config.config.samplingRate, FXAS21002_CTRL_REG1_DR_MASK) != ATMO_I2C_Status_Success)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n    // Put into active mode\n    if(ATMO_FXAS21002_WriteReg(FXAS21002_CTRL_REG1, FXAS21002_CTRL_REG1_MODE_ACTIVE, FXAS21002_CTRL_REG1_MODE_MASK) != ATMO_I2C_Status_Success)\n    {\n    \treturn ATMO_FXAS21002_Status_Fail;\n    }\n\n\n    return ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetConfiguration(ATMO_FXAS21002_Config_t *config)\n{\n    if( config == NULL || !_ATMO_FXAS21002_config.configured )\n    {\n        return ATMO_FXAS21002_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_FXAS21002_config.config, sizeof(ATMO_FXAS21002_Config_t));\n\n    return ATMO_FXAS21002_Status_Success;\n}\n\nATMO_FXAS21002_Status_t ATMO_FXAS21002_GetSensorData(ATMO_FXAS21002_SensorData_t *data)\n{\n    if( !_ATMO_FXAS21002_config.configured || !_ATMO_FXAS21002_Enabled)\n    {\n        return ATMO_FXAS21002_Status_Fail;\n    }\n\n\n\tuint8_t rawData[6] = {0};\n\n\tif(ATMO_FXAS21002_ReadReg(FXAS21002_OUT_X_MSB, rawData, 6) != ATMO_I2C_Status_Success)\n\t{\n\t\treturn ATMO_FXAS21002_Status_Fail;\n\t}\n\n\t// Get scale for conversion\n\tuint8_t fs = 0;\n\tif(ATMO_FXAS21002_ReadReg(FXAS21002_CTRL_REG0, &fs, 1) != ATMO_I2C_Status_Success)\n\t{\n\t\treturn ATMO_FXAS21002_Status_Fail;\n\t}\n\n\tfs &= FXAS21002_CTRL_REG0_FS_MASK;\n\n\t// Multiplier for dps/LSB\n\tfloat multiplier = 0.0;\n\n\tswitch(fs)\n\t{\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS2000:\n\t\t{\n\t\t\tmultiplier = .0625;\n\t\t\tbreak;\n\t\t}\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS1000:\n\t\t{\n\t\t\tmultiplier = .03125;\n\t\t\tbreak;\n\t\t}\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS500:\n\t\t{\n\t\t\tmultiplier = .015625;\n\t\t\tbreak;\n\t\t}\n\t\tcase FXAS21002_CTRL_REG0_FS_DPS250:\n\t\t{\n\t\t\tmultiplier = .0078125;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint16_t dataCounts[3] = {0};\n\tdataCounts[0] = ((int16_t)rawData[0] << 8) | rawData[1];\n\tdataCounts[1] = ((int16_t)rawData[2] << 8) | rawData[3];\n\tdataCounts[2] = ((int16_t)rawData[4] << 8) | rawData[5];\n\n\tdata->X = multiplier * dataCounts[0];\n\tdata->Y = multiplier * dataCounts[1];\n\tdata->Z = multiplier * dataCounts[2];\n\n\treturn ATMO_FXAS21002_Status_Success;\n}\n"
              }
            }
          },
          "md5": "dca9ca0fc7bfe522d8bb69f241b1bcf1"
        },
        "mpl3115": {
          "libName": "mpl3115",
          "description": "NXP MPL3115 Pressure and Altitude Sensor",
          "type": "Pressure + Altitute Sensor",
          "icon": "",
          "manufacturer": "NXP Semiconductors",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/product-detail/en/adafruit-industries-llc/1893/1528-1034-ND/4990783"
              },
              "cartData": {
                "part": "1528-1034-ND",
                "partid": "4990783",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "MPL3115Pressure",
              "type": "EmbeddedMPL3115",
              "icon": "EmbeddedPressure.svg",
              "defaultAbility": "readPressure",
              "defaultTrigger": "pressureRead",
              "hidden": false,
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/nxpmpl3115element.html",
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "\tATMO_MPL3115_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.MPLsettings.mode = MPL_MODE_PRESSURE;\n\tconfig.MPLsettings.oversample = MPL_OS_0;\t\t\t// oversampling = 1\n\tconfig.MPLsettings.autoAcquisitionTime = MPL_ST_0;\t// Auto acquisition time = 1s\n\tconfig.MPLsettings.pressureOffset = ATMO_PROPERTY(undefined, pressureOffset);\t// Offset pressure correction = 4*-128 = -512Pa (8 bits signed integer)\n\tconfig.MPLsettings.altitudeOffset = ATMO_PROPERTY(undefined, altitudeOffset);\t// Offset altitude correction = 128m (signed 8 bits integer)\n\tconfig.MPLsettings.tempOffset = ATMO_PROPERTY(undefined, tempOffset);\t\t\t// Offset temperature correction -8C (0.0625C/LSB)\n\tconfig.MPLsettings.fifoMode = FIFO_DISABLED;\t\t// FIFO mode disabled\n\tconfig.MPLsettings.fifoWatermark = 5;\t\t\t\t// 6 bits to set the number of FIFO samples required to trigger a watermark interrupt.\n\tconfig.MPLsettings.fifoINTpin = FIFO_INT1;\t\t\t// set pin INT1 as output for FIFO interrupt\n\n\treturn ( ATMO_MPL3115_Init(&config) == ATMO_MPL3115_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_MPL3115_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_MPL3115_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAltitude",
                  "triggers": [
                    "altitudeRead"
                  ],
                  "code": "    uint32_t altitudeMeters;\n    if(ATMO_MPL3115_GetAltitude(&altitudeMeters) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)altitudeMeters);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressure",
                  "triggers": [
                    "pressureRead"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)pressurePa);\n    return ATMO_Status_Success;"
                },
                {
                  "name": "readPressureKpa",
                  "triggers": [
                    "pressureReadKpa"
                  ],
                  "code": "    uint32_t pressurePa;\n    if(ATMO_MPL3115_GetPressure(&pressurePa) != ATMO_MPL3115_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)(pressurePa/1000));\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x60"
                },
                {
                  "name": "pressureOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "altitudeOffset",
                  "input": "number",
                  "value": "0"
                },
                {
                  "name": "tempOffset",
                  "input": "number",
                  "value": "0"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedMPL3115": "NXP MPL3115",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "readAltitude": "Read Altitude",
                  "readPressure": "Read Pressure",
                  "readPressureKpa": "Read Pressure (kPa)",
                  "pressureRead": "Pressure Read",
                  "altitudeRead": "Altitude Read",
                  "pressureReadKpa": "Pressure Read (kPa)",
                  "pressureOffset": "Pressure Offset",
                  "altitudeOffset": "Altitude Offset",
                  "tempOffset": "Temperature Offset"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "mpl3115.h": "#ifndef __ATMO_MPL3115_H_\n#define __ATMO_MPL3115_H_\n\n#include \"mpl3115_internal.h\"\n#include \"../i2c/i2c.h\"\n\ntypedef enum {\n    ATMO_MPL3115_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_MPL3115_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_MPL3115_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_MPL3115_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_MPL3115_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_MPL3115_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n\tsettingsMPL_t MPLsettings;\n} ATMO_MPL3115_Config_t;\n\n\n/**\n * Initialize MPL3115 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config);\n\n/**\n * Enable/Disable MPL3115 Driver\n *\n * @param[in] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled);\n\n/**\n * Get enabled/disabled status of MPL3115 driver\n *\n * @param[out] enabled\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config);\n\n/**\n * Get device configuration\n * \n * @param[out] config\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config);\n\n/**\n * Get Barometeric Pressure in Pascals\n * \n * @param[out] pressurePascals\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals);\n\n/**\n * Get Temperature in degrees celsius\n * \n * @param[out] temperature\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius);\n\n/**\n * Get Altitude in meters\n * \n * @param[out] altitudeMeters\n */\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters);\n\n#endif\n",
                "mpl3115_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the header file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#ifndef MPL3115_H_\n#define MPL3115_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n\n/*!\n * @addtogroup mpl3115 MPL3115 atmospheric pressure sensor\n * This module provides the API to operate the MPL3115 atmospheric pressure sensor through an I2C interface.\n *\n * The MPL3115A2 is a compact, piezoresistive, absolute pressure sensor with an I2C\n * digital interface. MPL3115A2 has a wide operating range of 20 kPa to 110 kPa, a range\n * that covers all surface elevations on earth. The MEMS is temperature compensated\n * utilizing an on-chip temperature sensor. The pressure and temperature data is fed into\n * a high resolution ADC to provide fully compensated and digitized outputs for pressure\n * in Pascals and temperature in C.\n *\n * Usage\n *-----------------------------------------------------------------------------------------------------------\n *\n * Initialization:\n * @code\n *\n *  #include \"mpl3115.h\"\n *\n *  mpl3115_IoFunc_t MPL3115_sensor;\n *  MPL3115_sensor.I2C_Read = App_I2C1_Read;\n *  MPL3115_sensor.I2C_Write = App_I2C1_Write;\n *  MPL3115_sensor.WaitMsec = App_WaitMsec;\n *\n *  MPL3115_Init_Driver(&MPL3115_sensor);\n *  MPL3115_Init_Hw();\n * @endcode\n *\n * Basic Operation:\n * @code\n *\n *  int32_t data;\n *\n *  if (MPL_ReadRawData (MPL_MODE_PRESSURE, &data) == 0)\n *  {\n *        data /= 400; // in HPa (LSB = 0.25Pa)\n *  }\n *\n * @endcode\n *\n * @{\n */\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _mpl3115_IoFunc_t\n{\n    uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);     /*!< Function pointer to I2C Read function. */\n    uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);                                         /*!< Function pointer to I2C Write function. */\n    void      (*WaitMsec)(uint32_t millisec);                                                                                   /*!< Function pointer to waitMsec function  */\n} mpl3115_IoFunc_t, *pmpl3115_IoFunc_t;\n\ntypedef int16_t mE_t;\n\n/*! @brief Status return codes. */\ntypedef enum\n{\n    MPL_SUCCESS,            /*!< Function ran successfully. */\n    MPL_ERROR,              /*!< Error in running function. */\n    MPL_PROTOCOL_ERROR,     /*!< Protocol error has occurred. */\n    MPL_INIT_ERROR,         /*!< Initialization error has occurred. */\n    MPL_TIMEOUT,            /*!< MPL function has timed out */\n    MPL_NOT_SUPPORTED       /*!< Not Supported */\n} mpl_status_t;\n\n/*! @brief Oversampling factor */\ntypedef enum {\n    MPL_OS_0,               /*!< Oversample Ratio = 1    */\n    MPL_OS_1,               /*!< Oversample Ratio = 2    */\n    MPL_OS_2,               /*!< Oversample Ratio = 4    */\n    MPL_OS_3,               /*!< Oversample Ratio = 8    */\n    MPL_OS_4,               /*!< Oversample Ratio = 16   */\n    MPL_OS_5,               /*!< Oversample Ratio = 32   */\n    MPL_OS_6,               /*!< Oversample Ratio = 64   */\n    MPL_OS_7                /*!< Oversample Ratio = 128  */\n} overSampleMPL_t;\n\n/*! @brief Auto acquisition time step : power(2; MPL_ST_X) */\ntypedef enum {\n    MPL_ST_0,               /*!< Auto acquistion time step = 1 second       */\n    MPL_ST_1,               /*!< Auto acquistion time step = 2 seconds      */\n    MPL_ST_2,               /*!< Auto acquistion time step = 4 seconds      */\n    MPL_ST_3,               /*!< Auto acquistion time step = 8 seconds      */\n    MPL_ST_4,               /*!< Auto acquistion time step = 16 seconds     */\n    MPL_ST_5,               /*!< Auto acquistion time step = 32 seconds     */\n    MPL_ST_6,               /*!< Auto acquistion time step = 64 seconds     */\n    MPL_ST_7,               /*!< Auto acquistion time step = 128 seconds    */\n    MPL_ST_8,               /*!< Auto acquistion time step = 256 seconds    */\n    MPL_ST_9,               /*!< Auto acquistion time step = 512 seconds    */\n    MPL_ST_10,              /*!< Auto acquistion time step = 1024 seconds   */\n    MPL_ST_11,              /*!< Auto acquistion time step = 2048 seconds   */\n    MPL_ST_12,              /*!< Auto acquistion time step = 4096 seconds   */\n    MPL_ST_13,              /*!< Auto acquistion time step = 8192 seconds   */\n    MPL_ST_14,              /*!< Auto acquistion time step = 16384 seconds  */\n    MPL_ST_15               /*!< Auto acquistion time step = 32768 seconds  */\n} autoAcquisitionTime_t;\n\n/*! @brief Device Mode */\ntypedef enum {\n    MPL_MODE_PRESSURE    = 0,   /*!< Device is in barometer mode. It reports an absolute pressure.  */\n    MPL_MODE_ALTITUDE    = 1,   /*!< Device is in altimeter mode. The pressure data is converted to equivalent altitude based on US standard atmosphere */\n    MPL_MODE_TEMPERATURE = 2,   /*!< This mode provides temperature from a high resolution temperature sensor. */\n    MPL_MODE_CURRENT     = 0xFF\n} modeMPL_t;\n\n/*! @brief Fifo Mode */\ntypedef enum {\n    FIFO_DISABLED,        /*!< FIFO is disabled (reset value) */\n    FIFO_CIRCULAR,        /*!< FIFO contains the most recent samples when overflowed (circular buffer). Oldest sample is discarded to be replaced by new sample*/\n    FIFO_STOP_OVERFLOW    /*!< FIFO stops accepting new samples when overflowed */\n} modeFIFO_t;\n\n/*! @brief Pin to route FIFO interrupt */\ntypedef enum {\n    FIFO_INT1    = 1,   /*!< FIFO Interrupt routed to INT1 pin */\n    FIFO_INT2    = 0    /*!< FIFO Interrupt routed to INT2 pin */\n} pinINT_t;\n\n/* structure that contains MPL settings */\ntypedef struct {\n    modeMPL_t                 mode;                    /*!< device mode, altimeter or barometer */\n    overSampleMPL_t           oversample;              /*!< oversampling ratio */\n    autoAcquisitionTime_t     autoAcquisitionTime;     /*!< Auto acquisition time step */\n    int8_t                    pressureOffset;          /*!< Offset pressure correction (signed: 4 Pa/LSB) */\n    int8_t                    altitudeOffset;          /*!< Offset altitude correction (signed: 1m/LSB) */\n    int8_t                    tempOffset;              /*!< Offset temperature correction -8C (signed: 0.0625C/LSB) */\n    modeFIFO_t                fifoMode;                /*!< FIFO mode */\n    uint8_t                   fifoWatermark;           /*!< These (6) bits set the number of FIFO samples required to trigger a watermark interrupt. */\n    pinINT_t                  fifoINTpin;              /*!< Pin to route FIFO interrupt */\n} settingsMPL_t;\n\n/* MPL3115 I2C slave address */\n#define MPL3115_I2C_SLAVE_ADDRESS                (uint8_t)0x60\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize MPL3115 driver.\n * @note  Wrap the low level functions (I2C write, I2C read, WaitMsec).\n * @param pIoFunc  Pointer to a structure with external functions\n */\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc);\n\n/*!\n * @brief De-initialize MPL3115 driver.\n *\n */\nvoid MPL3115_Deinit_Driver();\n\n/*!\n * @brief Initialize MPL3115 hardware.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings);\n\n/*!\n * @brief Soft reset.\n * @note\n * The reset mechanism can be enabled in standby and active mode.\\n\n * When this bit is enabled, the reset mechanism resets all functional block\n * registers and loads the respective internal registers with default values\n * If the system was already in standby mode, the reboot process will\\n\n * immediately begin; else if the system was in active mode, the boot mechanism\n * will automatically transition the system from active mode to standby mode,\n * and only then can the reboot process begin.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SoftReset();\n\n/*!\n * @brief Toggle the OST bit.\n * @note Clears then sets the OST bit which causes the sensor to immediately\n * take another reading, necessary to sample faster than 1Hz.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ToggleOneShot();\n\n/*!\n * @brief Read the chip ID.\n *\n * @param sensorID Chip ID value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetID(uint8_t* sensorID);\n\n/*!\n * @brief Set the device mode (barometer or altimeter).\n *\n * @param mode 1 - barometer\n *             0 - altimeter\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetMode (modeMPL_t mode);\n\n/*!\n * @brief Put the sensor in stand-by mode.\n * @note It is needed to modify major control registers.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GotoStandby ();\n\n/*!\n * @brief Put the sensor in active mode.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetActive();\n\n/*!\n * @brief Set the over-sample rate.\n * @note\n * Datasheet calls for 128, but you can set it from 1 to 128 samples.\n * The higher the oversample rate, the greater the time between data samples.\n *\n * @param sampleRate Over-sample rate value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate);\n\n/*!\n * @brief Set the auto-acquisition time step.\n * @note\n * Reset value = 0.\\n\n * Step is power(2; sampleTime).\n *\n * @param sampleTime Sample time value\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetAutoAcquisitionTime (uint8_t sampleTime);\n\n/*!\n * @brief Enable pressure and temperature measurement event flags.\n * @note This is recommended in datasheet during setup.\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_EnableEventFlags();\n\n/*!\n * @brief Set the offset pressure correction.\n * @note\n * Pressure user accessible offset trim value number.\\n\n * The user offset registers may be adjusted to enhance accuracy and optimize\n * the system performance.\\n\n * Range is from 512 to +508 Pa, 4 Pa/LSB.\n *\n * @param pressOffset Pressure offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset);\n\n/*!\n * @brief Set the offset altitude correction.\n * @note\n * Altitude user accessible offset trim value number.\\n\n * The user offset register provides user adjustment to the vertical height of\n * the altitude output.\\n\n * The range of values are from 128 to +127 meters.\n *\n * @param altitudeOffset Altitude offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset);\n\n/*!\n * @brief Set the offset temperature correction.\n * @note\n * Temperature user accessible offset trim value number.\\n\n * The range of values is from 8 to +7.9375 C, 0.0625 C/LSB.\n *\n * @param temperatureOffset Temperature offset correction value.\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset);\n\n/*!\n * @brief Set the FIFO mode\n * @note\n * It can be configured in either circular buffer or in overflow mode.\\n\n * In circular buffer mode, a watermark can be set to trigger a flag event.\n * Exceeding the watermark, count does not stop the FIFO from accepting new\n * data, the oldest data is overwritten.\n *\n * @param fMode FIFO mode\n * @param fWmrk Watermark\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk);\n\n/*!\n * @brief Setup the FIFO interrupt and route it to pin INT1 or INT2\n *\n * @param pinINT Interrupt pin selection (INT1 or INT2)\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT);\n\n/*!\n * @brief Disable the FIFO interrupt\n *\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_DisableFifoInterrupt();\n\n/*!\n * @brief Read the FIFO status register.\n *\n * @param fifoStatus Pointer to FIFO status\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus);\n\n/*!\n * @brief Read sensor raw data\n *\n * @param  mode Sensor mode (pressure, altitude...)\n * @param  sensorData Pointer to the sensor data\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData);\n\n/*!\n * @brief Read all the chip registers\n *\n * @param  sensorReg Pointer to the register dump\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Dump(uint8_t* sensorReg);\n\n/*! @}*/\n\n#endif /* MPL3115_H_ */\n"
              },
              "objects": {
                "mpl3115.c": "#include \"mpl3115.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_MPL3115_Config_t config;\n    bool configured;\n} ATMO_MPL3115_Priv_Config;\n\nstatic ATMO_MPL3115_Priv_Config _ATMO_MPL3115_config;\n\nstatic ATMO_I2C_Peripheral_t _ATMO_MPL3115_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic bool mpl3115Enabled = true;\n\nstatic uint8_t ATMO_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\n\nstatic uint8_t ATMO_MPL3115_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_MPL3115_config.config.i2cDriverInstance, _ATMO_MPL3115_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? MPL_SUCCESS : MPL_ERROR;\n}\nATMO_MPL3115_Status_t ATMO_MPL3115_Init(ATMO_MPL3115_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_MPL3115_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_MPL3115_config.configured = false;\n    }\n\n    mpl3115_IoFunc_t io;\n    io.I2C_Read = ATMO_I2CRead_Simple;\n    io.I2C_Write = ATMO_MPL3115_I2CWrite_Simple;\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\n    MPL3115_Init_Driver(&io);\n    MPL3115_Init_Hw(&config->MPLsettings);\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetEnabled(bool enabled)\n{\n    mpl3115Enabled = enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetEnabled(bool *enabled)\n{\n    *enabled = mpl3115Enabled;\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_SetConfiguration(const ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_MPL3115_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy( &_ATMO_MPL3115_config.config, config, sizeof(ATMO_MPL3115_Config_t) );\n    _ATMO_MPL3115_config.configured = true;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetConfiguration(ATMO_MPL3115_Config_t *config)\n{\n    if( config == NULL || !_ATMO_MPL3115_config.configured )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_MPL3115_config.config, sizeof(ATMO_MPL3115_Config_t));\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetPressure(uint32_t *pressurePascals)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)pressurePascals) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *pressurePascals = (*pressurePascals) / 4;\n\n    return ATMO_MPL3115_Status_Success;\n        \n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetTemperature(int32_t *temperatureCelsius)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_TEMPERATURE, (int32_t *)temperatureCelsius) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *temperatureCelsius = (*temperatureCelsius) / 16;\n\n    return ATMO_MPL3115_Status_Success;\n}\n\nATMO_MPL3115_Status_t ATMO_MPL3115_GetAltitude(uint32_t *altitudeMeters)\n{\n    if(!mpl3115Enabled)\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n    \n    if( MPL_ToggleOneShot() != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    if( MPL_ReadRawData(MPL_MODE_PRESSURE, (int32_t *)altitudeMeters) != MPL_SUCCESS )\n    {\n        return ATMO_MPL3115_Status_Fail;\n    }\n\n    *altitudeMeters = (*altitudeMeters) / 16;\n\n    return ATMO_MPL3115_Status_Success; \n}\n\n\n\n\n",
                "mpl3115_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file\n * This is the source file for the atmospheric pressure sensor MPL3115 driver.\n */\n\n#include \"mpl3115_internal.h\"\n#include <string.h>\n#include <assert.h>\n\n/* unshifted 7-bit I2C address */\n#define MPL_I2C_ADDRESS  (0x60)\n\n#define REG_STATUS      (0x00)\n#define OUT_P_MSB       (0x01)\n#define OUT_P_CSB       (0x02)\n#define OUT_P_LSB       (0x03)\n#define OUT_T_MSB       (0x04)\n#define OUT_T_LSB       (0x05)\n#define DR_STATUS       (0x06)\n#define OUT_P_DELTA_MSB (0x07)\n#define OUT_P_DELTA_CSB (0x08)\n#define OUT_P_DELTA_LSB (0x09)\n#define OUT_T_DELTA_MSB (0x0A)\n#define OUT_T_DELTA_LSB (0x0B)\n#define WHO_AM_I        (0x0C)\n#define F_STATUS        (0x0D)\n#define F_DATA          (0x0E)\n#define F_SETUP         (0x0F)\n#define TIME_DLY        (0x10)\n#define SYSMOD          (0x11)\n#define INT_SOURCE      (0x12)\n#define PT_DATA_CFG     (0x13)\n#define BAR_IN_MSB      (0x14)\n#define BAR_IN_LSB      (0x15)\n#define P_TGT_MSB       (0x16)\n#define P_TGT_LSB       (0x17)\n#define T_TGT           (0x18)\n#define P_WND_MSB       (0x19)\n#define P_WND_LSB       (0x1A)\n#define T_WND           (0x1B)\n#define P_MIN_MSB       (0x1C)\n#define P_MIN_CSB       (0x1D)\n#define P_MIN_LSB       (0x1E)\n#define T_MIN_MSB       (0x1F)\n#define T_MIN_LSB       (0x20)\n#define P_MAX_MSB       (0x21)\n#define P_MAX_CSB       (0x22)\n#define P_MAX_LSB       (0x23)\n#define T_MAX_MSB       (0x24)\n#define T_MAX_LSB       (0x25)\n#define MPL_CTRL_REG1   (0x26)\n#define MPL_CTRL_REG2   (0x27)\n#define MPL_CTRL_REG3   (0x28)\n#define MPL_CTRL_REG4   (0x29)\n#define MPL_CTRL_REG5   (0x2A)\n#define OFF_P           (0x2B)\n#define OFF_T           (0x2C)\n#define OFF_H           (0x2D)\n\n// SHIFTS\n#define MPL_OS_SHIFT    (3)\n\n#define MPL_TDR_SHIFT   (1)\n#define MPL_PDR_SHIFT   (2)\n#define MPL_PTDR_SHIFT  (3)\n\n#define MPL_SBYB_SHIFT  (0)\n#define MPL_OST_SHIFT   (1)\n#define MPL_RST_SHIFT   (2)\n\n#define INT_EN_FIFO_SHIFT   (6)\n#define INT_CFG_FIFO_SHIFT  (6)\n\n// MASKS\n#define MPL_OS_MASK         (0x7 << MPL_OS_SHIFT)\n#define MPL_F_WMRKK_MASK    0xF\n\n/* MPL3115 CTRL_REG1 register */\n#define MPL_RST             (1 << 2)\n#define MPL_OST             (1 << 1)\n#define MPL_SBYB            (1 << 0)\n\n/***********************************************************************************/\n/* variables                                                                       */\n/***********************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic mpl3115_IoFunc_t sIoFunc;\n\n/* variable which denotes the sensor working as altimeter/barometer */\nstatic modeMPL_t selectedMode = MPL_MODE_PRESSURE;\n\nstatic uint16_t\nselectedSampleRate  = 0xA5A5,\nselectedDelay       = 0xA5A5;\n\n/* oversample factor */\nstatic uint16_t overSampleFactors[] = { 1,  2,  4,  8, 16,  32,  64, 128 };\n/* min. time between data samples in [ms] */\nstatic uint16_t overSampleDelays[]  = { 6, 10, 18, 34, 66, 130, 258, 512 };\n\nstatic settingsMPL_t settings;\n\n\n/*****************************************************************************\n * Static functions\n ****************************************************************************/\n\n/*\n * @brief Initialize the internal structures.\n *\n * @param mplSettings Pointer to the internal settings structure\n * @return Status value (0 for success)\n */\nmpl_status_t MPL_Init(const settingsMPL_t* mplSettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    memcpy( (void*)&settings, (void*)mplSettings, sizeof(settings) );\n\n    // reset all registers to POR values\n    if (MPL_SoftReset()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set the mode\n    else if (MPL_SetMode(settings.mode)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // set over-sampling\n    else if (MPL_SetOversampleRate(settings.oversample)!=MPL_SUCCESS) status =  MPL_INIT_ERROR;\n\n    // enable the flags\n    else if (MPL_EnableEventFlags()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set auto acquisition time step\n    else if (MPL_SetAutoAcquisitionTime(settings.autoAcquisitionTime)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset pressure correction\n    else if (MPL_SetOffsetPressure(settings.pressureOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset altitude correction\n    else if (MPL_SetOffsetAltitude(settings.altitudeOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set offset temperature correction\n    else if (MPL_SetOffsetTemperature(settings.tempOffset)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // setup FIFO register mode and event count to trigger interrupt\n    else if (MPL_SetFifoMode(settings.fifoMode, settings.fifoWatermark)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // set FIFO interrupt and output pin (INT1 or INT2)\n    else if (MPL_SetFifoInterrupt(settings.fifoINTpin)!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    // goto active state\n    else if (MPL_SetActive()!=MPL_SUCCESS) status = MPL_INIT_ERROR;\n\n    return status;\n}\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid MPL3115_Init_Driver(mpl3115_IoFunc_t* pIoFunc)\n{\n    assert((pIoFunc != NULL) &&\n            (pIoFunc->I2C_Read != NULL) &&\n            (pIoFunc->I2C_Write != NULL) &&\n            (pIoFunc->WaitMsec != NULL));\n    sIoFunc = *pIoFunc;\n    initDriverDone = true;\n}\n\nvoid MPL3115_Deinit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        MPL_GotoStandby(); /* skip error management */\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nmpl_status_t MPL3115_Init_Hw(settingsMPL_t *MPLsettings)\n{\n    mpl_status_t status = MPL_SUCCESS;\n\n    if (!initDriverDone) return MPL_INIT_ERROR;\n\n    /* trick to allow calling internal public functions */\n    initHwDone = true;\n\n    /* initialize the sensor */\n    status = MPL_Init(MPLsettings);\n    if (status != MPL_SUCCESS) initHwDone = false;\n    return status;\n\n}\n\nmpl_status_t MPL_SoftReset()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1, MPL_RST};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // Reset all registers to POR value\n    if (sIoFunc.I2C_Write(wBuf, 2)!= MPL_SUCCESS) return MPL_ERROR;\n    else\n    {\n        // by the end of the boot process the RST bit should be de-asserted to 0 => need to wait before next operation\n        sIoFunc.WaitMsec(10); // 10ms delay\n        return MPL_SUCCESS;\n    }\n}\n\nmpl_status_t MPL_ToggleOneShot()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear OST bit and write it back\n    wBuf[1] = rBuf & ~(MPL_OST);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read again settings, just to be safe\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set OST bit and write it back\n    wBuf[1] = rBuf | MPL_OST;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetID(uint8_t* sensorID)\n{\n    uint8_t wBuf[1] = {WHO_AM_I};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorID != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, sensorID, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetMode (modeMPL_t mode)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set/clear ALT bit\n    switch (mode)\n    {\n    case MPL_MODE_PRESSURE: {\n        wBuf[1] = rBuf & ~( 1 << 7 ); // Clear ALT bit\n        break;\n    }\n    case MPL_MODE_ALTITUDE: {\n        wBuf[1] = rBuf | ( 1 << 7 ); // Set ALT bit\n        break;\n    }\n    case MPL_MODE_TEMPERATURE: {\n        break;\n    }\n    default:\n        return MPL_NOT_SUPPORTED;\n    }\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n    // update the static variable\n    selectedMode = mode;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GotoStandby()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear SBYB bit for entering stand-by mode\n    wBuf[1] = rBuf & ~MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetActive()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // set SBYB bit for entering active mode\n    wBuf[1] = rBuf | MPL_SBYB;\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOversampleRate (uint8_t sampleRate)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG1};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // rate cannot be larger than 7\n    if (sampleRate > 7) sampleRate = 7;\n\n    selectedSampleRate = overSampleFactors[sampleRate];\n    selectedDelay      = overSampleDelays[sampleRate];\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // clear out old OS bits\n    wBuf[1] = rBuf & ~MPL_OS_MASK;\n    // mask in new OS bits\n    wBuf[1] |= ( sampleRate << MPL_OS_SHIFT );\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t  MPL_SetAutoAcquisitionTime (uint8_t sampleTime)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG2};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read current settings\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // mask in new ST bits. sampleTime cannot be larger than 15 Giving a range of 1s to 9.1 hours\n    wBuf[1] |= (sampleTime > 15) ? 15 : sampleTime;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_EnableEventFlags()\n{\n    uint8_t wBuf[] = {PT_DATA_CFG, 0x07};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetPressure (int8_t pressOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_P, pressOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetAltitude (int8_t altitudeOffset)\n{\n    uint8_t wBuf[] = {OFF_H, altitudeOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetOffsetTemperature (int8_t temperatureOffset)\n{\n    // Convert input to 2's complement number\n    uint8_t wBuf[] = {OFF_T, temperatureOffset};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // write settings\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoMode (modeFIFO_t fMode, uint8_t fWmrk)\n{\n    uint8_t wBuf[2] = {F_SETUP};\n    wBuf[1] = (fMode << 6) | (fWmrk & MPL_F_WMRKK_MASK);\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_SetFifoInterrupt (pinINT_t pinINT)\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & set INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf | (1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // read CTRL5 register & Route interrupt to either INT1 or INT2 pin\n    wBuf[0] = MPL_CTRL_REG5;\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    wBuf[1] = (pinINT == FIFO_INT1) ? rBuf | (1 << INT_CFG_FIFO_SHIFT) : rBuf &~(1 << INT_CFG_FIFO_SHIFT);\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_DisableFifoInterrupt ()\n{\n    uint8_t wBuf[2] = {MPL_CTRL_REG4};\n    uint8_t rBuf;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n\n    // read CTRL4 register & disable INT_EN_FIFO\n    if (sIoFunc.I2C_Read(wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    wBuf[1] = rBuf & ~(1 << INT_EN_FIFO_SHIFT);\n\n    if (sIoFunc.I2C_Write(wBuf, 2)!=MPL_SUCCESS) return MPL_ERROR;\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_GetFifoStatus(uint8_t* fifoStatus)\n{\n    uint8_t wBuf[1] = {F_STATUS};\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(fifoStatus != NULL);\n\n    // read device ID = WHO_AM_I register (address 0x0C)\n    if (sIoFunc.I2C_Read(wBuf, 1, fifoStatus, 1)!=MPL_SUCCESS) return MPL_ERROR;\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_ReadRawData (modeMPL_t mode, int32_t* sensorData)\n{\n    uint8_t wBuf[2] = {REG_STATUS};\n    uint8_t rBuf[5];\n    uint8_t dataReadyFlag,\n    dataReadyRegAddr,\n    bytesToRead = 0;\n    int16_t counter = 0;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorData != NULL);\n\n    /* set the new working mode, if given one */\n\n    if  (( mode > MPL_MODE_TEMPERATURE ) && ( mode < MPL_MODE_CURRENT )) return MPL_INIT_ERROR;\n    else if (( MPL_MODE_CURRENT != mode ) && ( selectedMode != mode ))\n    {\n        // goto standby\n        if (MPL_GotoStandby()!=MPL_SUCCESS) return MPL_ERROR;\n        // set the mode\n        if (MPL_SetMode(mode)!=MPL_SUCCESS) return MPL_ERROR;\n        // goto active state\n        if (MPL_SetActive()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    /* prepare for reading data */\n\n    switch (selectedMode)\n    {\n    case MPL_MODE_PRESSURE:\n    case MPL_MODE_ALTITUDE: {\n        dataReadyFlag     = 1 << MPL_PDR_SHIFT;\n        dataReadyRegAddr  = OUT_P_MSB;\n        bytesToRead       = 3;\n        break;\n    }\n\n    case MPL_MODE_TEMPERATURE: {\n        dataReadyFlag     = 1 << MPL_TDR_SHIFT;\n        dataReadyRegAddr  = OUT_T_MSB;\n        bytesToRead       = 2;\n        break;\n    }\n\n    default:  {}\n    }\n\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n\n    // check PDR/PTR bit; if it's not set, toggle OST\n    if (0 == (rBuf[0] & dataReadyFlag))\n    {\n        // toggle the OST bit, causing the sensor to immediately take another reading\n        if (MPL_ToggleOneShot()!=MPL_SUCCESS) return MPL_ERROR;\n        sIoFunc.WaitMsec(10);   // Wait 10ms\n    }\n\n    // wait for PDR/PTR bit, which indicates that we have new data\n    while (1)\n    {\n        if (sIoFunc.I2C_Read(wBuf, 1, rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        if ((0==(rBuf[0] & dataReadyFlag)) & ( ++counter > 5 )) return MPL_TIMEOUT;\n        else break;\n        sIoFunc.WaitMsec(100);  // Wait 100ms\n    }\n\n    /* read sensor data */\n\n    wBuf[0] = dataReadyRegAddr;\n    if (sIoFunc.I2C_Read(wBuf, 1, rBuf, bytesToRead)!=MPL_SUCCESS) return MPL_ERROR;\n\n    switch ( selectedMode )\n    {\n    // pressure value is a Q18.2 right-aligned number in [Pa]\n    case MPL_MODE_PRESSURE:\n        // altitude value is a Q16.4 right-aligned number in [m]\n    case MPL_MODE_ALTITUDE:     {\n        *sensorData = (int32_t) ((rBuf[0] << 16) | (rBuf[1] << 8) | rBuf[2]) >> 4;\n        break;\n    }\n\n    // temperature value is a Q8.4 right-aligned number in [C]\n    case MPL_MODE_TEMPERATURE:  {\n        *sensorData = (int32_t) (((rBuf[0] << 8) | rBuf[1]) >> 4);\n        break;\n    }\n    default:  {}\n    }\n\n    return MPL_SUCCESS;\n}\n\nmpl_status_t MPL_Dump(uint8_t *sensorReg)\n{\n    uint8_t wBuf= 0;\n    uint8_t rBuf;\n    uint8_t i;\n\n    if (!initHwDone) return MPL_INIT_ERROR;\n    assert(sensorReg != NULL);\n\n    // read all registers\n    for (i=0; i<45; i++)\n    {\n        if (sIoFunc.I2C_Read(&wBuf, 1, &rBuf, 1)!=MPL_SUCCESS) return MPL_ERROR;\n        *sensorReg = rBuf;\n        wBuf++;\n        sensorReg++;\n    }\n    return MPL_SUCCESS;\n}\n"
              }
            }
          },
          "md5": "b084c10744d9ba148b8fa2bde7491e93"
        },
        "sx9500": {
          "libName": "sx9500",
          "manufacturer": "Semtech",
          "description": "Proximity Sensor Evaluation Board",
          "type": "Touch Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/short/j21827"
              },
              "cartData": {
                "part": "SX9500EVKA-ND",
                "partid": "4569959",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "gpio"
          ],
          "elements": [
            {
              "name": "SX9500Touch",
              "type": "EmbeddedSX9500",
              "icon": "EmbeddedTouch.svg",
              "defaultAbility": "getTouchData",
              "defaultTrigger": "touchDataRead",
              "hidden": false,
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/semtechsx9500element.html",
              "abilities": [
                {
                  "name": "setup",
                  "triggers": [],
                  "hidden": true,
                  "code": "\tATMO_SX9500_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\tconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioInstance);\n\tconfig.interruptEnabled = ATMO_PROPERTY(undefined, interruptEnabled);\n\tconfig.interruptPin = ATMO_PROPERTY(undefined, interruptGpio);\n\tATMO_SX9500_Init(&config);\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Up, ATMO_ABILITY(undefined, pressUp));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Down, ATMO_ABILITY(undefined, pressDown));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Left, ATMO_ABILITY(undefined, pressLeft));\n\tATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_Touched_Right, ATMO_ABILITY(undefined, pressRight));\n\treturn ATMO_Status_Success;"
                },
                {
                  "name": "getTouchData",
                  "triggers": [
                    "touchDataRead"
                  ],
                  "code": ""
                },
                {
                  "name": "pressUp",
                  "triggers": [
                    "upPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressDown",
                  "triggers": [
                    "downPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressLeft",
                  "triggers": [
                    "leftPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "pressRight",
                  "triggers": [
                    "rightPressed",
                    "touchDataRead"
                  ],
                  "code": "SX9500_TouchState_t touchState;\nATMO_GetBinary(in, &touchState, sizeof(touchState));\nATMO_CreateValueBinary(out, &touchState, sizeof(touchState));\nreturn ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "gpioInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "interruptEnabled",
                  "input": "checkbox",
                  "value": true
                },
                {
                  "name": "interruptGpio",
                  "input": "number",
                  "value": "ATMO_DEFAULT_GPIO"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x28"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedSX9500": "Semtech SX9500",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "interruptGpio": "Interrupt GPIO Pin",
                  "interruptEnabled": "Touch Interrupt Enabled",
                  "gpioInstance": "GPIO Driver Instance",
                  "operatingMode": "Operating Mode",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "getTouchData": "Get Touch Data",
                  "touchDataRead": "Touch Data Read",
                  "pressUp": "Press Up",
                  "upPressed": "Up Pressed",
                  "pressDown": "Press Down",
                  "downPressed": "Down Pressed",
                  "pressLeft": "Press Left",
                  "leftPressed": "Left Pressed",
                  "pressRight": "Press Right",
                  "rightPressed": "Right Pressed"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "sx9500.h": "#ifndef __ATMO_SX9500_H_\n#define __ATMO_SX9500_H_\n\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../i2c/i2c.h\"\n#include \"../gpio/gpio.h\"\n\ntypedef enum {\n    ATMO_SX9500_Status_Success              = 0x00u,  // Common - Operation was successful\n    ATMO_SX9500_Status_Fail                 = 0x01u,  // Common - Operation failed\n    ATMO_SX9500_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\n    ATMO_SX9500_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\n    ATMO_SX9500_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\n} ATMO_SX9500_Status_t;\n\ntypedef struct {\n    uint16_t address;\n    bool interruptEnabled;\n    ATMO_GPIO_Device_Pin_t interruptPin;\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\n    ATMO_DriverInstanceHandle_t gpioDriverInstance;\n} ATMO_SX9500_Config_t;\n\ntypedef struct {\n\tbool downPressed;\n\tbool upPressed;\n\tbool leftPressed;\n\tbool rightPressed;\n} SX9500_TouchState_t;\n\ntypedef enum {\n\tSX9500_Touched_Any = 0,\n\tSX9500_Touched_Down,\n\tSX9500_Touched_Right,\n\tSX9500_Touched_Up,\n\tSX9500_Touched_Left,\n\tSX9500_Touched_NumEvents,\n} SX9500_TouchEvent_t;\n\n\n/**\n * Initialize SX9500 Driver\n *\n * @param[in] config - Device configuration (optional)\n */\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config);\n\n/**\n * Set basic device configuration\n *\n * @param[in] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config);\n\n/**\n * Get device configuration\n *\n * @param[out] config\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config);\n\n/**\n * Get current touch sensor state\n *\n * @param[out] touchState\n */\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState);\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle);\n\n\n/**\n * Register ability handle for touched event\n *\n * @param[in] abilityHandle\n */\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb);\n\n\n#endif\n\n",
                "sx9500_internal.h": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.h\n * This is the header file for the SX9500 touch controller driver.\n */\n\n#ifndef SX9500_INTERNAL_H_\n#define SX9500_INTERNAL_H_\n\n/*!\n * @addtogroup sx9500 SX9500 touch controller API\n * @{\n */\n\n#include \"../app_src/atmosphere_platform.h\"\n\n\n#define SX9500_I2C_ADDRESS                          0x28\n\n#define SX9500_REG_IRQSRC                           0x00\n#define SX9500_REG_STAT                             0x01\n#define SX9500_REG_IRQMSK                           0x03\n#define SX9500_REG_PROXCTRL0                        0x06\n#define SX9500_REG_PROXCTRL1                        0x07\n#define SX9500_REG_PROXCTRL2                        0x08\n#define SX9500_REG_PROXCTRL3                        0x09\n#define SX9500_REG_PROXCTRL4                        0x0A\n#define SX9500_REG_PROXCTRL5                        0x0B\n#define SX9500_REG_PROXCTRL6                        0x0C\n#define SX9500_REG_PROXCTRL7                        0x0D\n#define SX9500_REG_PROXCTRL8                        0x0E\n#define SX9500_REG_SENSORSEL                        0x20\n#define SX9500_REG_USEMSB                           0x21\n#define SX9500_REG_USELSB                           0x22\n#define SX9500_REG_AVGMSB                           0x23\n#define SX9500_REG_AVGLSB                           0x24\n#define SX9500_REG_DIFFMSB                          0x25\n#define SX9500_REG_DIFFLSB                          0x26\n#define SX9500_REG_OFFSETMSB                        0x27\n#define SX9500_REG_OFFSETLSB                        0x28\n#define SX9500_REG_RESET                            0x7F\n \n#define SX9500_RESET_CMD                            0xDE\n \n/*! @brief Status return codes. */\ntypedef enum\n{\n    SX9500_SUCCESS,\n    SX9500_I2C_ERROR,\n    SX9500_INTERNAL_ERROR,\n\tSX9500_NOINIT_ERROR\n} SX9500_status;\n\ntypedef union {\n    struct {    // sx9500 register 0x00\n        uint8_t txen_stat   : 1;    // 0\n        uint8_t reserved    : 2;    // 1,2\n        uint8_t conv_done   : 1;    // 3\n        uint8_t comp_done   : 1;    // 4\n        uint8_t far         : 1;    // 5\n        uint8_t close       : 1;    // 6\n        uint8_t reset       : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegIrqSrc_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x01\n        uint8_t compstat         : 4;    // 0,1,2,3\n        uint8_t proxstat0        : 1;    // 4\n        uint8_t proxstat1        : 1;    // 5\n        uint8_t proxstat2        : 1;    // 6\n        uint8_t proxstat3        : 1;    // 7\n   } bits;\n    uint8_t octet;\n} RegStat_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x06\n        uint8_t sensor_en   : 4;    // 0,1,2,3\n        uint8_t scan_period : 3;    // 4,5,6\n        uint8_t reserved    : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl0_t;\n \ntypedef union {\n    struct {    // sx9500 register 0x09\n        uint8_t raw_filt    : 2;    // 0,1\n        uint8_t reserved    : 2;    // 2,3\n        uint8_t doze_period : 2;    // 4,5\n        uint8_t doze_en     : 1;    // 6\n        uint8_t res7        : 1;    // 7\n    } bits;\n    uint8_t octet;\n} RegProxCtrl3_t;\n\n/*! @brief Structure of external functions or values. */\ntypedef struct _sx9500_fct_t\n{\n\t/** Read hardware function */\n    uint8_t (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\n    /** Write hardware register, 8bit aligned function */\n    uint8_t (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\n    /** Wait function **/\n    void (*WaitMs)(uint32_t tms);\n} sx9500_fct_t, *ptsx9500_fct_t;\n\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\n/*!\n * @brief Initialize SX9500 driver.\n *\n * @param FCT Pointer to a structure with external functions\n */\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT);\n\n/*!\n * @brief De-initialize SX9500 driver.\n *\n */\nvoid SX9500_Deinit_Driver();\n\n/*!\n * @brief Initialize SX9500 hardware.\n *\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_Init_Hw();\n\n/*!\n * @brief Get information for selected sensor.\n *\n * @param  CSn Selected sensor (0-3)\n * @param  buf Pointer to an array with PROXUSEFUL/PROXAVG/PROXDIFF values\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf);\n\n/*!\n * @brief Get power mode.\n *\n * @return Power mode: active (true/1) or low power (false/0)\n */\nbool SX9500_get_active();\n\n/*!\n * @brief Set power mode.\n *\n * @param  bool Power mode: active (true/1) or low power (false/0)\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_set_active(bool);\n\n/*!\n * @brief Function returning the triggered capacitive sensing interface.\n * @note Returns 0xFF if no interface has been triggered.\n *\n * @param  CSi Pointer to sensing interface index\n * @return Status value (0 for success)\n */\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi);\n\n/*!\n * @brief Read IRQ Source\n * @note  Used to clear interrupts on SX9500\n *\n * @param irqReg Pointer to store value from IRQ register\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg);\n\n/*!\n * @brief Read Proximity Sensors\n *\n * @param data Pointer to store data from proximity sensor data\n *\n * @return Status value (0 for success)\n *\n */\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data);\n\n/*! @}*/\n\n#endif\n"
              },
              "objects": {
                "sx9500.c": "#include \"sx9500.h\"\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\ntypedef struct {\n    ATMO_SX9500_Config_t config;\n    unsigned int abilityHandle[SX9500_Touched_NumEvents];\n\tbool abilityHandleRegistered[SX9500_Touched_NumEvents];\n    ATMO_Callback_t callback[SX9500_Touched_NumEvents];\n    bool configured;\n} ATMO_SX9500_Priv_Config;\n\nstatic ATMO_SX9500_Priv_Config _ATMO_SX9500_config = {0};\n\nstatic ATMO_I2C_Peripheral_t _ATMO_SX9500_i2cConfig = {\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\n};\n\nstatic uint8_t _ATMO_SX9500_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic uint8_t _ATMO_SX9500_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\n{\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_SX9500_config.config.i2cDriverInstance, _ATMO_SX9500_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\n}\n\nstatic bool ATMO_SX9500_TouchStateToIndex(SX9500_TouchState_t *touchState, uint32_t *index)\n{\n\tbool anyPressed = false;\n\n\tif(touchState->downPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Down;\n\t}\n\tif(touchState->upPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Up;\n\t}\n\tif(touchState->rightPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Right;\n\t}\n\tif(touchState->leftPressed)\n\t{\n\t\tanyPressed = true;\n\t\t*index = SX9500_Touched_Left;\n\t}\n\n\treturn anyPressed;\n}\n\nstatic void ATMO_SX9500_Callback(void *data)\n{\n    RegIrqSrc_t irq;\n    if (SX9500_Read_Irq(&irq.octet) == SX9500_SUCCESS)\n    {\n        if (irq.bits.close || irq.bits.far)\n        {\n        \tSX9500_TouchState_t touchState;\n        \tif(ATMO_SX9500_GetTouchState(&touchState) == ATMO_SX9500_Status_Success)\n        \t{\n        \t\tuint32_t index = 0;\n        \t\tif(ATMO_SX9500_TouchStateToIndex(&touchState, &index))\n        \t\t{\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[SX9500_Touched_Any] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[SX9500_Touched_Any], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.abilityHandleRegistered[index] )\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\tATMO_AddAbilityExecute(_ATMO_SX9500_config.abilityHandle[index], &val);\n        \t\t\t}\n\n        \t\t\tif(_ATMO_SX9500_config.callback[SX9500_Touched_Any] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[SX9500_Touched_Any](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t\tif(_ATMO_SX9500_config.callback[index] != NULL)\n        \t\t\t{\n        \t\t\t\tATMO_Value_t val;\n        \t\t\t\tATMO_InitValue(&val);\n        \t\t\t\tATMO_CreateValueBinary(&val, &touchState, sizeof(touchState));\n        \t\t\t\t_ATMO_SX9500_config.callback[index](&val);\n        \t\t\t\tATMO_FreeValue(&val);\n        \t\t\t}\n        \t\t}\n        \t}\n        \telse\n        \t{\n        \t\treturn ATMO_SX9500_Status_Fail;\n        \t}\n        }\n    }\n    else\n    {\n    \treturn ATMO_SX9500_Status_Fail;\n    }\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_Init(ATMO_SX9500_Config_t *config)\n{\n    // Did the user supply a configuration?\n    if( config )\n    {\n        ATMO_SX9500_SetConfiguration(config);\n    }\n    else\n    {\n    \t_ATMO_SX9500_config.configured = false;\n    }\n\n\tsx9500_fct_t fct;\n\tfct.I2C_Read = _ATMO_SX9500_I2CRead_Simple;\n\tfct.I2C_Write = _ATMO_SX9500_I2CWrite_Simple;\n\tfct.WaitMs = ATMO_PLATFORM_DelayMilliseconds;\n\tSX9500_Init_Driver(&fct);\n\tSX9500_Init_Hw();\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_SetConfiguration(const ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_SX9500_i2cConfig) != ATMO_I2C_Status_Success )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    // Register interrupt\n    if(config->interruptEnabled)\n    {\n    \tATMO_GPIO_RegisterInterruptCallback(config->gpioDriverInstance, config->interruptPin, ATMO_GPIO_InterruptTrigger_FallingEdge, ATMO_SX9500_Callback);\n    }\n\n    memcpy( &_ATMO_SX9500_config.config, config, sizeof(ATMO_SX9500_Config_t) );\n    _ATMO_SX9500_config.configured = true;\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetConfiguration(ATMO_SX9500_Config_t *config)\n{\n    if( config == NULL || !_ATMO_SX9500_config.configured )\n    {\n        return ATMO_SX9500_Status_Fail;\n    }\n\n    memcpy(config, &_ATMO_SX9500_config.config, sizeof(ATMO_SX9500_Config_t));\n\n    return ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_GetTouchState(SX9500_TouchState_t *touchState)\n{\n\tmemset(touchState, 0, sizeof(SX9500_TouchState_t));\n\n\tRegStat_t dir;\n\tif( SX9500_Read_Proximity_Sensors(&dir.octet) != SX9500_SUCCESS )\n\t{\n\t\treturn ATMO_SX9500_Status_Fail;\n\t}\n\n\tif(dir.octet > 0)\n\t{\n\t\tif(dir.bits.proxstat0)\n\t\t{\n\t\t\ttouchState->downPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat1)\n\t\t{\n\t\t\ttouchState->rightPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat2)\n\t\t{\n\t\t\ttouchState->upPressed = true;\n\t\t}\n\t\tif(dir.bits.proxstat3)\n\t\t{\n\t\t\ttouchState->leftPressed = true;\n\t\t}\n\t}\n\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedAbilityHandle(SX9500_TouchEvent_t event, unsigned int abilityHandle)\n{\n\t_ATMO_SX9500_config.abilityHandle[event] = abilityHandle;\n\t_ATMO_SX9500_config.abilityHandleRegistered[event] = true;\n\treturn ATMO_SX9500_Status_Success;\n}\n\nATMO_SX9500_Status_t ATMO_SX9500_RegisterTouchedCallback(SX9500_TouchEvent_t event, ATMO_Callback_t cb)\n{\n\t_ATMO_SX9500_config.callback[event] = cb;\n\treturn ATMO_SX9500_Status_Success;\n}\n\n\n",
                "sx9500_internal.c": "/*\n * Copyright (c) 2018 NXP\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * o Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * o Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * o Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*!\n * @file sx9500.c\n * This is the source file for the SX9500 touch controller driver.\n */\n\n#include \"sx9500_internal.h\"\n#include \"../app_src/atmosphere_platform.h\"\n\n/*****************************************************************************\n * Variables\n ****************************************************************************/\nstatic bool initDriverDone = false;\nstatic bool initHwDone = false;\nstatic sx9500_fct_t FCT_SX9500;\nstatic bool m_txen;\n\n/* Define registers that need to be initialized to values different than\n * default\n */\ntypedef struct smtc_reg_data {\n    unsigned char reg;\n    unsigned char val;\n}smtc_reg_data_t;\nstatic smtc_reg_data_t sx9500_i2c_reg_setup[] = {\n    {\n        .reg = SX9500_REG_IRQMSK,\n        .val = 0x60,  /* CLOSEIRQEN[6]=1 (close interrupt is on),            */\n                      /* FARIRQEN[5]=1 (far interrupt is on),                */\n                      /* COMPDONEIRQEN[4]=0 (compensation interrupt is off), */\n                      /* CONVDONEIRQEN[3]=0 (conversion interrupt is off)    */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL1,\n        .val = 0x03,  /* SHIELDEN[7:6]=0 (no shield),              */\n                      /* RANGE[1:0]=3 (small, +/-2.5pF Full Scale) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL2,\n        .val = 0x27,  /* GAIN[6:5]=1 (digital gain x2),          */\n                      /* FREQ[4:3]=0 (83kHz sampling frequency), */\n                      /* RESOLUTION[2:0]=0 (finest resolution)   */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL3,\n        .val = 0x41,  /* DOZEEN[6]=1 (enables doze mode),   */\n                      /* DOZEPERIOD[5:4]=0 (2*scan period), */\n                      /* RAWFILT[1:0]=1 (Low)               */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL4,\n        .val = 0x80,  /* AVGTHRESH[7:0]=0x80 (threshold triggering compensation = +/-128*value (typ between 16384 and 24576) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL5,\n        .val = 0x0F,  /* AVGDEB[7:6]=0 (debounce=off),               */\n                      /* AVGNEGFILT[5:3]=1 (lowest negative filter), */\n                      /* AVGPOSFILT[2:0]=7 (highest positive filter) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL6,\n        .val = 0x06,  /* PROXTHRESH[4:0]=6 (sensitivity=120) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL7,\n        .val = 0x00,  /* AVGCOMPDIS[7]=0 (compensation enabled),      */\n                      /* COMPMETHOD[6]=0 (separate CSx compensation), */\n                      /* HYST[5:4]=0 (hysteresis=32),                 */\n                      /* CLOSEDEB[3:2]=0 (close debouncer=off),       */\n                      /* FARDEB[1:0]=0 (far debouncer=off)            */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL8,\n        .val = 0x08,  /* STUCK[7:4]=0 (stuck timeout=off),                          */\n                      /* COMPPRD[3:0]=8 (periodic compensation every 8*128 samples) */\n    },\n    {\n        .reg = SX9500_REG_PROXCTRL0,\n        .val = 0x0F,  /* SCANPERIOD[6:4]=0 (scan every 30ms),  */\n                      /* SENSOREN[3:0]=15 (enable all sensors) */\n    },\n};\n\n/*****************************************************************************\n * Private functions\n ****************************************************************************/\n\nstatic SX9500_status SX9500_write(uint8_t addr, uint8_t data)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    cmd[1] = data;\n\n    return (SX9500_status)FCT_SX9500.I2C_Write(cmd, 2);\n}\n\nstatic SX9500_status SX9500_read(uint8_t addr, uint8_t *dst_buf, uint32_t length)\n{\n    uint8_t cmd[2];\n\n    cmd[0] = addr;\n    return (SX9500_status)FCT_SX9500.I2C_Read(cmd, 1, dst_buf, length);\n}\n\nstatic SX9500_status SX9500_read_single(uint8_t addr, uint8_t* val)\n{\n    return (SX9500_status)FCT_SX9500.I2C_Read(&addr, 1, val, 1);\n}\n\n/*****************************************************************************\n * Public functions\n ****************************************************************************/\n\nvoid SX9500_Init_Driver(ptsx9500_fct_t  FCT)\n{\n    assert((FCT != NULL) &&\n            (FCT->I2C_Read != NULL) &&\n            (FCT->I2C_Write != NULL) &&\n            (FCT->WaitMs != NULL));\n    FCT_SX9500 = *FCT;\n    initDriverDone = true;\n}\n\nvoid SX9500_Denit_Driver()\n{\n    if (initHwDone)\n    {\n        /* Deinit HW */\n        SX9500_set_active(false); // skip error management\n    }\n\n    /* Deinit driver */\n    initDriverDone = false;\n    initHwDone = false;\n}\n\nSX9500_status SX9500_Init_Hw()\n{\n    int i = 0;\n    uint8_t val;\n    SX9500_status status;\n\n    if (!initDriverDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    // perform a soft reset\n    status = SX9500_write(SX9500_REG_RESET, SX9500_RESET_CMD);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    FCT_SX9500.WaitMs(300); // wait until the reset has finished\n\n    // read IRQSRC to release NIRQ pin\n    status = SX9500_read(SX9500_REG_IRQSRC, &val,1);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    // init I2C registers\n    int lenRegTable = sizeof(sx9500_i2c_reg_setup) / sizeof(smtc_reg_data_t);\n    while (i < lenRegTable)\n    {\n        /* Write all registers/values contained in i2c_reg */\n        status = SX9500_write(sx9500_i2c_reg_setup[i].reg, sx9500_i2c_reg_setup[i].val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        /* Read back value from register and verify write */\n        status = SX9500_read_single(sx9500_i2c_reg_setup[i].reg, &val);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n\n        if (val != sx9500_i2c_reg_setup[i].val)\n        {\n            return SX9500_INTERNAL_ERROR;\n        }\n\n        i++;\n    }\n\n    initHwDone = true;\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_GetInfo_sensor(char CSn, uint8_t* buf)\n{\n    SX9500_status status;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(buf != NULL);\n\n    status = SX9500_write(SX9500_REG_SENSORSEL, CSn);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_USEMSB, buf, 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_AVGMSB, &buf[2], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read(SX9500_REG_DIFFMSB, &buf[4], 2);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    return SX9500_SUCCESS;\n}\n\n// get power mode (active or low power)\nbool SX9500_get_active()\n{\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    return m_txen;\n}\n\n// set active mode or low power mode\nSX9500_status SX9500_set_active(bool en)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    m_txen = en;\n\n    uint8_t val = en ? sx9500_i2c_reg_setup[10].val : 0x00U;\n\n    status = SX9500_write(SX9500_REG_PROXCTRL0, val);\n\n    return status;\n}\n\n// returns the triggered capacitive sensing interface (CS0..CS3)\nSX9500_status SX9500_CSi_Detected(uint8_t* CSi)\n{\n    SX9500_status status = SX9500_SUCCESS;\n    RegIrqSrc_t regirq;\n    RegStat_t prox;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n    assert(CSi != NULL);\n\n    *CSi = 0xFF;\n\n    status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n    if (status != SX9500_SUCCESS)\n    {\n        return status;\n    }\n\n    if (regirq.bits.close)\n    {\n        if (prox.bits.proxstat0)\n        {\n            *CSi = 0;\n        }\n        else if (prox.bits.proxstat1)\n        {\n            *CSi = 1;\n        }\n        else if (prox.bits.proxstat2)\n        {\n            *CSi = 2;\n        }\n        else if (prox.bits.proxstat3)\n        {\n            *CSi = 3;\n        }\n    }\n    return SX9500_SUCCESS;\n}\n\nSX9500_status SX9500_Read_Irq(uint8_t* irqReg)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != irqReg)\n    {\n        RegIrqSrc_t regirq;\n        status = SX9500_read_single(SX9500_REG_IRQSRC, &regirq.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            return status;\n        }\n        else\n        {\n            *irqReg = regirq.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\nSX9500_status SX9500_Read_Proximity_Sensors(uint8_t* data)\n{\n    SX9500_status status = SX9500_SUCCESS;\n\n    if (!initHwDone)\n    {\n        return SX9500_NOINIT_ERROR;\n    }\n\n    if (NULL != data)\n    {\n        RegStat_t prox;\n        status = SX9500_read_single(SX9500_REG_STAT, &prox.octet);\n        if (status != SX9500_SUCCESS)\n        {\n            *data = 0xFF;\n            return status;\n        }\n        else\n        {\n            *data = prox.octet;\n            return SX9500_SUCCESS;\n        }\n    }\n    else\n    {\n        return SX9500_INTERNAL_ERROR;\n    }\n}\n\n"
              }
            }
          },
          "md5": "19572d01734555056cd3db903fbf46dd"
        },
        "tsl2572": {
          "libName": "tsl2572",
          "manufacturer": "AMS",
          "description": "Ambient Light Sensor",
          "type": "Ambient Light Sensor",
          "icon": "",
          "image": "",
          "version": "",
          "eelVersion": "3",
          "shoppingCartLinks": {
            "digikey": {
              "links": {
                "info": "https://www.digikey.com/short/j218d3"
              },
              "cartData": {
                "part": "TSL2572EVM-ND",
                "partid": "3737697",
                "source": "dkstudio",
                "qty": "1"
              }
            }
          },
          "requires": [
            "embedded",
            "i2c",
            "fpmath"
          ],
          "elements": [
            {
              "name": "TSL2572AmbientLight",
              "type": "EmbeddedTSL2572",
              "icon": "EmbeddedAmbientLight.svg",
              "helpPageHref": "https://developer.atmosphereiot.com/documents/elements/amstsl2572element.html",
              "defaultAbility": "readAmbientLight",
              "defaultTrigger": "ambientLightRead",
              "hidden": false,
              "abilities": [
                {
                  "name": "setup",
                  "hidden": true,
                  "code": "\tATMO_TSL2572_Config_t config;\n\tconfig.address = ATMO_PROPERTY(undefined, i2cAddress);\n\tconfig.i2cDriverInstance = ATMO_PROPERTY(undefined, i2cInstance);\n\n\treturn ( ATMO_TSL2572_Init(&config) == ATMO_TSL2572_Status_Success ) ? ATMO_Status_Success : ATMO_Status_Fail;\n"
                },
                {
                  "name": "setEnabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(true);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setDisabled",
                  "triggers": [],
                  "code": "ATMO_TSL2572_SetEnabled(false);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "setEnabledDisabled",
                  "triggers": [],
                  "code": "bool enabled = false;\nATMO_GetBool(in, &enabled);\nATMO_TSL2572_SetEnabled(enabled);\nreturn ATMO_Status_Success;"
                },
                {
                  "name": "readAmbientLight",
                  "triggers": [
                    "ambientLightRead"
                  ],
                  "code": "    float lightLux;\n    if(ATMO_TSL2572_GetAmbientLight(&lightLux) != ATMO_TSL2572_Status_Success)\n    {\n        ATMO_CreateValueVoid(out);\n        return ATMO_Status_Fail;\n    }\n    ATMO_CreateValueInt(out, (int)lightLux);\n    return ATMO_Status_Success;"
                }
              ],
              "properties": [
                {
                  "name": "i2cInstance",
                  "input": "number",
                  "value": "ATMO_DEFAULT_I2C"
                },
                {
                  "name": "i2cAddress",
                  "input": "number",
                  "value": "0x39"
                }
              ],
              "triggers": [],
              "variables": [],
              "language": {
                "en-US": {
                  "EmbeddedTSL2572": "AMS TSL2572",
                  "i2cInstance": "I2C Driver Instance",
                  "i2cAddress": "I2C Address",
                  "setEnabled": "Set Enabled",
                  "setDisabled": "Set Disabled",
                  "setEnabledDisabled": "Set Enabled State",
                  "readAmbientLight": "Read Ambient Light (lux)",
                  "ambientLightRead": "Ambient Light Read"
                }
              }
            }
          ],
          "files": {
            "common": {
              "headers": {
                "tsl2572.h": "#ifndef __ATMO_TSL2572_H_\r\n#define __ATMO_TSL2572_H_\r\n\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n#include \"../i2c/i2c.h\"\r\n\r\ntypedef enum {\r\n    ATMO_TSL2572_Status_Success              = 0x00u,  // Common - Operation was successful\r\n    ATMO_TSL2572_Status_Fail                 = 0x01u,  // Common - Operation failed\r\n    ATMO_TSL2572_Status_Initialized          = 0x02u,  // Common - Peripheral already initialized\r\n    ATMO_TSL2572_Status_Invalid              = 0x03u,  // Common - Invalid operation or result\r\n    ATMO_TSL2572_Status_NotSupported         = 0x04u,  // Common - Feature not supported by platform\r\n} ATMO_TSL2572_Status_t;\r\n\r\ntypedef struct {\r\n    uint16_t address;\r\n    ATMO_DriverInstanceHandle_t i2cDriverInstance;\r\n} ATMO_TSL2572_Config_t;\r\n\r\n\r\n/**\r\n * Initialize TSL2572 Driver\r\n *\r\n * @param[in] config - Device configuration (optional)\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Enable/Disable TSL2572 Driver\r\n *\r\n * @param[in] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled);\r\n\r\n/**\r\n * Get enabled/disabled status of TSL2572 driver\r\n *\r\n * @param[out] enabled\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled);\r\n\r\n/**\r\n * Set basic device configuration\r\n *\r\n * @param[in] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get device configuration\r\n *\r\n * @param[out] config\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config);\r\n\r\n/**\r\n * Get ambient light intensity in lux\r\n *\r\n * @param[out] lightLux\r\n */\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux);\r\n\r\n\r\n#endif\r\n",
                "tsl2572_internal.h": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#ifndef TSL2572_H_\r\n#define TSL2572_H_\r\n\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\n//enum tsl2572_status {\r\n//    sensor_success = 0,\r\n//    sensor_I2C_error = 1,\r\n//    sensor_invalid_ID = 2,\r\n//    sensor_wrong_parameter = 3\r\n//};\r\n\r\ntypedef struct _tsl2572_IoFunc_t\r\n{\r\n  uint8_t   (*I2C_Read)(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize);\r\n  uint8_t   (*I2C_Write)(uint8_t *writeBuf, uint32_t writeSize);\r\n  void         (*WaitMsec)(uint32_t millisec);\r\n} tsl2572_IoFunc_t, *ptsl2572_IoFunc_t;\r\n\r\n/**\r\n * struct tsl2x7x_default_settings - power on defaults unless\r\n *                                   overridden by platform data.\r\n *  @als_time:              ALS Integration time - multiple of 50mS\r\n *  @als_gain:              Index into the ALS gain table.\r\n *  @als_gain_level:        ALS gain level (When asserted, the 1 and 8 ALS gain (AGAIN) modes are scaled by 0.16)\r\n *  @wait_time:             Time between PRX and ALS cycles\r\n *                          in 2.7 periods\r\n *  @wlong:                 When asserted, the wait cycles are increased by a factor 12 from that programmed in the WTIME register\r\n *  @interrupts_enable:     Enable/Disable als interrupts\r\n *  @persistence:           H/W Filters, Number of 'out of limits'\r\n *                          ADC readings ALS.\r\n *  @als_thresh_low:        CH0 'low' count to trigger interrupt.\r\n *  @als_thresh_high:       CH0 'high' count to trigger interrupt.\r\n *  @als_enable:            This bit actives the two channel ADC\r\n *  @wait_enable:           This bit activates the wait feature.\r\n *  @power_on:              This bit activates the internal oscillator to permit the timers and ADC channels to operate\r\n *  @glass_attenuation:     scaling factor referred to as glass attenuation (GA) can be used to compensate for attenuation\r\n */\r\nstruct tsl2x7x_settings {\r\n    uint8_t als_time;\r\n    uint8_t als_gain;\r\n    bool als_gain_level;\r\n    uint8_t wait_time;\r\n    bool wlong;\r\n    bool  interrupts_enable;\r\n    uint8_t  persistence;\r\n    uint16_t als_thresh_low;\r\n    uint16_t als_thresh_high;\r\n    bool als_enable;\r\n    bool wait_enable;\r\n    bool power_on;\r\n    float glass_attenuation;\r\n};\r\n\r\n/****************************************************************************\r\n * Function Prototypes\r\n ****************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc);\r\nuint8_t TSL2572_Init_HW(void);\r\nuint8_t TSL2572_ReadAmbientLight(float *lux);\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold);\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN);\r\nuint8_t TSL2572_ClearALSInterrupt(void);\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS);\r\nuint8_t TSL2572_Enable_ALS(bool AEN);\r\nuint8_t TSL2572_Power_ON(bool PON);\r\nuint8_t TSL2572_Enable_Wait(bool WEN);\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData);\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData);\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG);\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL);\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME);\r\n\r\n#endif /* TSL2572_H_ */\r\n"
              },
              "objects": {
                "tsl2572.c": "#include \"tsl2572.h\"\r\n#include \"tsl2572_internal.h\"\r\n#include \"../app_src/atmosphere_platform.h\"\r\n\r\ntypedef struct {\r\n    ATMO_TSL2572_Config_t config;\r\n    bool configured;\r\n} ATMO_TSL2572_Priv_Config;\r\n\r\nstatic ATMO_TSL2572_Priv_Config _ATMO_TSL2572_config;\r\n\r\nstatic ATMO_I2C_Peripheral_t _ATMO_TSL2572_i2cConfig = {\r\n    .operatingMode = ATMO_I2C_OperatingMode_Master,\r\n    .baudRate = ATMO_I2C_BaudRate_Standard_Mode\r\n};\r\n\r\nstatic bool tsl2572Enabled = true;\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CRead_Simple(uint8_t *writeBuf, uint32_t writeSize, uint8_t *readBuf, uint32_t readSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterRead(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, writeBuf, writeSize, readBuf, readSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\n\r\nstatic uint8_t _ATMO_TSL2572_I2CWrite_Simple(uint8_t *writeBuf, uint32_t writeSize)\r\n{\r\n\tATMO_I2C_Status_t status = ATMO_I2C_MasterWrite(_ATMO_TSL2572_config.config.i2cDriverInstance, _ATMO_TSL2572_config.config.address, NULL, 0, writeBuf, writeSize, 1000);\r\n\treturn (status == ATMO_I2C_Status_Success) ? 0 : 1;\r\n}\r\nATMO_TSL2572_Status_t ATMO_TSL2572_Init(ATMO_TSL2572_Config_t *config)\r\n{\r\n    // Did the user supply a configuration?\r\n    if( config )\r\n    {\r\n        ATMO_TSL2572_SetConfiguration(config);\r\n    }\r\n    else\r\n    {\r\n    \t_ATMO_TSL2572_config.configured = false;\r\n    }\r\n\r\n    tsl2572_IoFunc_t io;\r\n    io.I2C_Read = _ATMO_TSL2572_I2CRead_Simple;\r\n    io.I2C_Write = _ATMO_TSL2572_I2CWrite_Simple;\r\n    io.WaitMsec = ATMO_PLATFORM_DelayMilliseconds;\r\n    TSL2572_Init_Driver(&io);\r\n    TSL2572_Init_HW();\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetEnabled(bool enabled)\r\n{\r\n    tsl2572Enabled = enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetEnabled(bool *enabled)\r\n{\r\n    *enabled = tsl2572Enabled;\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_SetConfiguration(const ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    if( ATMO_I2C_SetConfiguration(config->i2cDriverInstance, &_ATMO_TSL2572_i2cConfig) != ATMO_I2C_Status_Success )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy( &_ATMO_TSL2572_config.config, config, sizeof(ATMO_TSL2572_Config_t) );\r\n    _ATMO_TSL2572_config.configured = true;\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetConfiguration(ATMO_TSL2572_Config_t *config)\r\n{\r\n    if( config == NULL || !_ATMO_TSL2572_config.configured )\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n\r\n    memcpy(config, &_ATMO_TSL2572_config.config, sizeof(ATMO_TSL2572_Config_t));\r\n\r\n    return ATMO_TSL2572_Status_Success;\r\n}\r\n\r\nATMO_TSL2572_Status_t ATMO_TSL2572_GetAmbientLight(float *lightLux)\r\n{\r\n    if(!tsl2572Enabled)\r\n    {\r\n        return ATMO_TSL2572_Status_Fail;\r\n    }\r\n    \r\n\tif( TSL2572_ReadAmbientLight(lightLux) != 0 )\r\n\t{\r\n\t\treturn ATMO_TSL2572_Status_Fail;\r\n\t}\r\n\r\n\treturn ATMO_TSL2572_Status_Success;\r\n}\r\n\r\n\r\n\r\n",
                "tsl2572_internal.c": "/*\r\n * Copyright (c) 2018 NXP\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * o Redistributions of source code must retain the above copyright notice, this list\r\n *   of conditions and the following disclaimer.\r\n *\r\n * o Redistributions in binary form must reproduce the above copyright notice, this\r\n *   list of conditions and the following disclaimer in the documentation and/or\r\n *   other materials provided with the distribution.\r\n *\r\n * o Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from this\r\n *   software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n#include \"tsl2572_internal.h\"\r\n\r\n/* TSL2572 Register definitions */\r\n#define TSL2572_I2C_SLAVE_ADDRESS        0x39\r\n#define TSL2572_DEVICE_ID                0x34    // TSL25721\r\n#define TSL2572_REG_ENABLE               0x00\r\n#define TSL2572_REG_ATIME                0x01\r\n#define TSL2572_REG_WTIME                0x03\r\n#define TSL2572_REG_AILTL                0x04\r\n#define TSL2572_REG_AILTH                0x05\r\n#define TSL2572_REG_AIHTL                0x06\r\n#define TSL2572_REG_AIHTH                0x07\r\n#define TSL2572_REG_PERS                 0x0C\r\n#define TSL2572_REG_CONFIG               0x0D\r\n#define TSL2572_REG_CONTROL              0x0F\r\n#define TSL2572_REG_ID                   0x12\r\n#define TSL2572_REG_STATUS               0x13\r\n#define TSL2572_REG_C0DATA               0x14\r\n#define TSL2572_REG_C0DATAH              0x15\r\n#define TSL2572_REG_C1DATA               0x16\r\n#define TSL2572_REG_C1DATAH              0x17\r\n\r\n/* tsl2572 COMMAND register masks */\r\n#define TSL2572_COMMAND_MSK              0x80\r\n#define TSL2572_TYPE_REPEAT_MSK          0x00\r\n#define TSL2572_TYPE_AUTO_INC_MSK        0x20\r\n#define TSL2572_TYPE_SPL_FN_MSK          0x60\r\n#define TSL2572_ADD_ALS_INT_CLR_MSK      0x06\r\n\r\n/* tsl2572 CONTROL register masks */\r\n#define TSL2572_AGAIN_MASK               0x03\r\n\r\n/* tsl2572 CONFIG register masks */\r\n#define TSL2572_AGL_MSK                  0x04\r\n#define TSL2572_WLONG_MSK                0x02\r\n\r\n/* tsl2572 PERS register masks */\r\n#define TSL2572_APERS_MSK                0x0F\r\n\r\n/* tsl2572 ENABLE register masks */\r\n#define TSL2572_AIEN_MSK                 0x10\r\n#define TSL2572_AEN_MSK                  0x02\r\n#define TSL2572_WEN_MSK                  0x08\r\n#define TSL2572_PON_MSK                  0x01\r\n\r\nenum tsl2572_status {\r\n    TSL2572_sensor_success = 0,\r\n    TSL2572_sensor_I2C_error = 1,\r\n    TSL2572_sensor_invalid_ID = 2,\r\n    TSL2572_sensor_wrong_parameter = 3\r\n};\r\n\r\nstatic const struct tsl2x7x_settings tsl2x7x_default_settings = {\r\n        0xDB,\r\n        0,\r\n        true,\r\n        74,\r\n        false,\r\n        true,\r\n        1,\r\n        100,\r\n        300,\r\n        true,\r\n        true,\r\n        true,\r\n        1\r\n};\r\n\r\n/***********************************************************************************/\r\n/* variables                                                                       */\r\n/***********************************************************************************/\r\nstatic tsl2572_IoFunc_t sTSL2572_Func;\r\nuint8_t gain_val = 0;\r\n\r\n/*****************************************************************************\r\n * Public functions\r\n ****************************************************************************/\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_Driver                                                          */\r\n/* wrap the low level function (I2C write, I2C read, WaitMsec)                  */\r\n/* required by TSL2572 driver                                                   */\r\n/* Note : this function does not initialize the HW                              */\r\n/********************************************************************************/\r\nvoid TSL2572_Init_Driver(tsl2572_IoFunc_t* pIoFunc){\r\n    sTSL2572_Func = *pIoFunc;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Init_HW                                                              */\r\n/* initialize the HW                                                            */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Init_HW(void){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* check device ID */\r\n    wBuf[0] = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    if (rBuf != TSL2572_DEVICE_ID){\r\n        return TSL2572_sensor_invalid_ID;\r\n    }\r\n\r\n    /* Set ALS gain */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSGain(tsl2x7x_default_settings.als_gain,tsl2x7x_default_settings.als_gain_level)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Set ALS time */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSTime(tsl2x7x_default_settings.als_time)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* configure the wait time */\r\n    if (TSL2572_sensor_success != TSL2572_SetWaitTime(tsl2x7x_default_settings.wait_time,tsl2x7x_default_settings.wlong)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt thresholds */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSThresholds(tsl2x7x_default_settings.als_thresh_low,tsl2x7x_default_settings.als_thresh_high)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* set the ALS interrupt persistence */\r\n    if (TSL2572_sensor_success != TSL2572_SetALSPersistence(tsl2x7x_default_settings.persistence)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* ALS Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_ALS(tsl2x7x_default_settings.als_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Wait Enable */\r\n    if (TSL2572_sensor_success != TSL2572_Enable_Wait(tsl2x7x_default_settings.wait_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* Power ON  */\r\n    if (TSL2572_sensor_success != TSL2572_Power_ON(tsl2x7x_default_settings.power_on)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* clear the sensor IRQ status */\r\n    if (TSL2572_sensor_success != TSL2572_ClearALSInterrupt()){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if (TSL2572_sensor_success != TSL2572_EnableALSInterrupts(tsl2x7x_default_settings.interrupts_enable)){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAmbientLight                                                     */\r\n/* sample CH0 and CH1 photo_diodes and compute the human eye response to        */\r\n/* light intensity (in lux)                                                     */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAmbientLight(float *lux){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n    int c0,c1;\r\n    float lux1,lux2,cpl;\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    c0 = rBuf[1]<<8 | rBuf[0];\r\n    c1 = rBuf[3]<<8 | rBuf[2];\r\n\r\n    //see TSL2572 datasheet\r\n    cpl = (2.73 * (256-tsl2x7x_default_settings.als_time)) * gain_val / (tsl2x7x_default_settings.glass_attenuation * 60);\r\n    if (tsl2x7x_default_settings.als_gain_level){\r\n        cpl /= 6;\r\n    }\r\n    lux1 = ((float)c0 - (1.87 * (float)c1)) / cpl;\r\n    lux2 = ((0.63 * (float)c0) - (float)c1) / cpl;\r\n    cpl = lux1 >= lux2 ? lux1 : lux2; //max(lux1, lux2);\r\n    *lux = ((cpl >= 0.0) ? cpl : 0.0); //max(cpl, 0.0);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSGain                                                           */\r\n/* AGAIN = 0     ALS Gain value = 1 * gain                                      */\r\n/* AGAIN = 1     ALS Gain value = 8 * gain                                      */\r\n/* AGAIN = 2     ALS Gain value = 16 * gain                                     */\r\n/* AGAIN = 3     ALS Gain value = 120 * gain                                    */\r\n/* AGL = 0       AGAIN = 0 or 1 or 2 or 3     -> scaling by 1                   */\r\n/* AGL = 1       AGAIN = 0 or 1               -> scaling by 0.16                */\r\n/* Do not use AGL = 1 with AGAIN = 2 or 3                                       */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSGain(uint8_t AGAIN, bool AGL){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    if ((AGAIN > 1) && (AGL)){\r\n        return TSL2572_sensor_wrong_parameter;\r\n    }\r\n\r\n    wBuf[0] = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = AGAIN & TSL2572_AGAIN_MASK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AGL bit */\r\n    if (AGL){\r\n        wBuf[1] = rBuf | TSL2572_AGL_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AGL_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    if ((AGAIN & TSL2572_AGAIN_MASK) == 0) gain_val = 1;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 1) gain_val = 8;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 2) gain_val = 16;\r\n    else if ((AGAIN & TSL2572_AGAIN_MASK) == 3) gain_val = 120;\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSTime                                                           */\r\n/* set ALS Time = the ALS ADC integration time                                  */\r\n/* ATIME = 0xFF     ALS integration cycles = 1,   time = 2.73ms                 */\r\n/* ATIME = 0xF6     ALS integration cycles = 10,  time = 27.3ms                 */\r\n/* ATIME = 0xDB     ALS integration cycles = 37,  time = 101ms                  */\r\n/* ATIME = 0xC0     ALS integration cycles = 64,  time = 175ms                  */\r\n/* ATIME = 0x00     ALS integration cycles = 256, time = 699ms                  */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSTime(uint8_t ATIME){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = ATIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* set ALS interrupt threshold low and threshold high                             */\r\n/* the thresholds refer to C0 photo_diode only                                     */\r\n/* (C1 is not used to trigger interrupts)                                        */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSThresholds(uint16_t ALS_interrupt_Low_Threshold, uint16_t ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[5];\r\n\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = (uint8_t)(ALS_interrupt_Low_Threshold & 0x00FF);\r\n    wBuf[2] = (uint8_t)((ALS_interrupt_Low_Threshold & 0xFF00) >> 8);\r\n    wBuf[3] = (uint8_t)(ALS_interrupt_High_Threshold & 0x00FF);\r\n    wBuf[4] = (uint8_t)((ALS_interrupt_High_Threshold & 0xFF00) >> 8);\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSThresholds                                                        */\r\n/* get ALS interrupt threshold low and threshold high                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_GetALSThresholds(uint16_t *ALS_interrupt_Low_Threshold, uint16_t *ALS_interrupt_High_Threshold){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf[4];\r\n\r\n    /* Read CH0 low data register, CH0 high data register, CH1 low data register and CH1 high data register */\r\n    wBuf[0] = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf[0], sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    *ALS_interrupt_Low_Threshold = (uint16_t) (rBuf[1]<<8 | rBuf[0]);\r\n    *ALS_interrupt_High_Threshold = (uint16_t) (rBuf[3]<<8 | rBuf[2]);\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetALSPersistence                                                    */\r\n/* set ALS interrupt persistence filter                                            */\r\n/* APERS = 0     every ALS cycle generates an interrupt                           */\r\n/* APERS = 1     1 value outside of threshold range generates an interrupt        */\r\n/* APERS = 2     2 consecutive values out of range generates an interrupt         */\r\n/* APERS = 3     3 consecutive values out of range generates an interrupt         */\r\n/* APERS = 4     5 consecutive values out of range generates an interrupt         */\r\n/* APERS = 5     10 consecutive values out of range generates an interrupt         */\r\n/* APERS = 6     15 consecutive values out of range generates an interrupt         */\r\n/* APERS = 7     20 consecutive values out of range generates an interrupt         */\r\n/* APERS = 8     25 consecutive values out of range generates an interrupt         */\r\n/* APERS = 9     30 consecutive values out of range generates an interrupt         */\r\n/* APERS = 10    35 consecutive values out of range generates an interrupt         */\r\n/* APERS = 11    40 consecutive values out of range generates an interrupt         */\r\n/* APERS = 12    45 consecutive values out of range generates an interrupt         */\r\n/* APERS = 13    50 consecutive values out of range generates an interrupt         */\r\n/* APERS = 14    55 consecutive values out of range generates an interrupt         */\r\n/* APERS = 15    60 consecutive values out of range generates an interrupt         */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetALSPersistence(uint8_t APERS){\r\n    uint8_t wBuf[2];\r\n\r\n    wBuf[0] = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = APERS & TSL2572_APERS_MSK;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_SetWaitTime                                                             */\r\n/* WTIME = 0xFF     Wait time = 2.73ms (WLONG = 0), 0.033s (WLONG = 1)           */\r\n/* WTIME = 0xB6     Wait time = 202ms (WLONG = 0), 2.4s (WLONG = 1)               */\r\n/* WTIME = 0x00     Wait time = 699ms (WLONG = 0), 8.4s (WLONG = 1)               */\r\n/* The Wait time register should be configured before TSL2572_Enable_ALS(true)    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_SetWaitTime(uint8_t WTIME, bool WLONG){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    wBuf[0] = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    wBuf[1] = WTIME;\r\n\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* read CONFIG register */\r\n    wBuf[0] = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WLONG bit */\r\n    if (WLONG){\r\n        wBuf[1] = rBuf | TSL2572_WLONG_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WLONG_MSK);\r\n    }\r\n\r\n    /* write CONFIG register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_EnableALSInterrupts(bool AIEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AIEN bit */\r\n    if (AIEN){\r\n        wBuf[1] = rBuf | TSL2572_AIEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AIEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\nuint8_t TSL2572_ClearALSInterrupt(void){\r\n    uint8_t wBuf;\r\n\r\n    wBuf = TSL2572_COMMAND_MSK | TSL2572_TYPE_SPL_FN_MSK | TSL2572_ADD_ALS_INT_CLR_MSK;\r\n    if (sTSL2572_Func.I2C_Write(&wBuf, sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_ALS                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_ALS(bool AEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask AEN bit */\r\n    if (AEN){\r\n        wBuf[1] = rBuf | TSL2572_AEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_AEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Enable_Wait                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Enable_Wait(bool WEN){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask WEN bit */\r\n    if (WEN){\r\n        wBuf[1] = rBuf | TSL2572_WEN_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_WEN_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_Power_ON                                                             */\r\n/********************************************************************************/\r\nuint8_t TSL2572_Power_ON(bool PON){\r\n    uint8_t wBuf[2];\r\n    uint8_t rBuf;\r\n\r\n    /* read ENABLE register */\r\n    wBuf[0] = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf[0], 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n\r\n    /* mask PON bit */\r\n    if (PON){\r\n        wBuf[1] = rBuf | TSL2572_PON_MSK;\r\n    }\r\n    else {\r\n        wBuf[1] = rBuf & ~(TSL2572_PON_MSK);\r\n    }\r\n\r\n    /* write ENABLE register */\r\n    if (sTSL2572_Func.I2C_Write(&wBuf[0], sizeof (wBuf) )){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadAllRegisters                                                        */\r\n/* RegData contains 16 * uint8_t                                                */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadAllRegisters(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read ENABLE register */\r\n    wBuf = TSL2572_REG_ENABLE | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ATIME register */\r\n    wBuf = TSL2572_REG_ATIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read WTIME register */\r\n    wBuf = TSL2572_REG_WTIME | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTL register */\r\n    wBuf = TSL2572_REG_AILTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AILTH register */\r\n    wBuf = TSL2572_REG_AILTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTL register */\r\n    wBuf = TSL2572_REG_AIHTL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read AIHTH register */\r\n    wBuf = TSL2572_REG_AIHTH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read PERS register */\r\n    wBuf = TSL2572_REG_PERS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONFIG register */\r\n    wBuf = TSL2572_REG_CONFIG | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read CONTROL register */\r\n    wBuf = TSL2572_REG_CONTROL | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read ID register */\r\n    wBuf = TSL2572_REG_ID | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read STATUS register */\r\n    wBuf = TSL2572_REG_STATUS | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATA register */\r\n    wBuf = TSL2572_REG_C1DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C1DATAH register */\r\n    wBuf = TSL2572_REG_C1DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n\r\n/********************************************************************************/\r\n/* TSL2572_ReadCH0                                                                 */\r\n/* RegData contains 2 * uint8_t                                                    */\r\n/********************************************************************************/\r\nuint8_t TSL2572_ReadCH0(uint8_t *RegData){\r\n    uint8_t wBuf;\r\n    uint8_t rBuf;\r\n\r\n    /* Read C0DATA register */\r\n    wBuf = TSL2572_REG_C0DATA | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    /* Read C0DATAH register */\r\n    wBuf = TSL2572_REG_C0DATAH | TSL2572_COMMAND_MSK | TSL2572_TYPE_AUTO_INC_MSK;\r\n    if (sTSL2572_Func.I2C_Read(&wBuf, 1, &rBuf, sizeof (rBuf))){\r\n        return TSL2572_sensor_I2C_error;\r\n    }\r\n    RegData++;\r\n    *RegData = (uint8_t)(rBuf);\r\n\r\n    return TSL2572_sensor_success;\r\n}\r\n"
              }
            }
          },
          "md5": "93c49b5c233b7365cd33c9b200725e69"
        }
      },
      "drivers": {
        "adc": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_ADC_ADC1"
          }
        ],
        "ble": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLE_BLE1"
          }
        ],
        "block": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_BLOCK_BLOCK1"
          }
        ],
        "datetime": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_DATETIME_DATETIME1"
          }
        ],
        "filesytem": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_FILESYSTEM_FILESYSTEM1"
          }
        ],
        "gpio": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_GPIO_GPIO1"
          }
        ],
        "http": [],
        "i2c": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_I2C_I2C1",
            "primary": true
          },
          {
            "id": 1,
            "name": "ATMO_DRIVERINSTANCE_I2C_I2C2"
          }
        ],
        "interval": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_INTERVAL_INTERVAL1"
          }
        ],
        "nfc": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_NFC_NFC1"
          }
        ],
        "pwm": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_PWM_PWM1"
          }
        ],
        "spi": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_SPI_SPI1"
          }
        ],
        "uart": [
          {
            "id": 0,
            "name": "ATMO_DRIVERINSTANCE_UART_UART1"
          },
          {
            "id": 1,
            "name": "ATMO_DRIVERINSTANCE_UART_UART2"
          },
          {
            "id": 2,
            "name": "ATMO_DRIVERINSTANCE_UART_UART3"
          },
          {
            "id": 3,
            "name": "ATMO_DRIVERINSTANCE_UART_UART4",
            "primary": true
          }
        ],
        "wifi": []
      },
      "static": {
        "header": "",
        "footer": "",
        "functions": {
          "ATMO_Setup": {
            "returnType": "void",
            "code": "\tATMO_THREAD_VOLANSYS_SetEnabled(false);\n\tDisconnect_NTAG_A1006();\n",
            "arguments": []
          }
        }
      }
    },
    "App View": {
      "type": "app",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {
        "appViewLayouts": {
          "320": {
            "560": true
          }
        }
      },
      "elements": [
        {
          "name": "BLE_TVOC",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\t&ATMO_VARIABLE(BLE_TVOC, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_TVOC, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_TVOC, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_TVOC, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_TVOC, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_TVOC, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_TVOC, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_TVOC, writeDataType), ATMO_PROPERTY(BLE_TVOC, readDataType), ATMO_PROPERTY(BLE_TVOC, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\t&ATMO_VARIABLE(BLE_TVOC, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_TVOC, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_TVOC, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\tATMO_VARIABLE(BLE_TVOC, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_TVOC, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_TVOC, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_TVOC, instance),\n\t\tATMO_VARIABLE(BLE_TVOC, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_TVOC, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f9",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 100,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_TVOC",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_CO2",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\t&ATMO_VARIABLE(BLE_CO2, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_CO2, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_CO2, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_CO2, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_CO2, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_CO2, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_CO2, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_CO2, writeDataType), ATMO_PROPERTY(BLE_CO2, readDataType), ATMO_PROPERTY(BLE_CO2, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\t&ATMO_VARIABLE(BLE_CO2, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_CO2, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_CO2, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\tATMO_VARIABLE(BLE_CO2, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_CO2, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_CO2, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_CO2, instance),\n\t\tATMO_VARIABLE(BLE_CO2, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_CO2, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fa",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 200,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_CO2",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_Pressure",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\t&ATMO_VARIABLE(BLE_Pressure, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Pressure, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Pressure, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Pressure, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Pressure, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Pressure, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Pressure, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Pressure, writeDataType), ATMO_PROPERTY(BLE_Pressure, readDataType), ATMO_PROPERTY(BLE_Pressure, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\t&ATMO_VARIABLE(BLE_Pressure, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Pressure, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Pressure, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\tATMO_VARIABLE(BLE_Pressure, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Pressure, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Pressure, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Pressure, instance),\n\t\tATMO_VARIABLE(BLE_Pressure, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Pressure, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fc",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 500,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_Pressure",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_Temperature",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\t&ATMO_VARIABLE(BLE_Temperature, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Temperature, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Temperature, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Temperature, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Temperature, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Temperature, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Temperature, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Temperature, writeDataType), ATMO_PROPERTY(BLE_Temperature, readDataType), ATMO_PROPERTY(BLE_Temperature, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\t&ATMO_VARIABLE(BLE_Temperature, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Temperature, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Temperature, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\tATMO_VARIABLE(BLE_Temperature, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Temperature, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Temperature, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Temperature, instance),\n\t\tATMO_VARIABLE(BLE_Temperature, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Temperature, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fb",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 600,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_Temperature",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_Humidity",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\t&ATMO_VARIABLE(BLE_Humidity, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Humidity, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Humidity, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Humidity, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Humidity, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Humidity, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Humidity, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Humidity, writeDataType), ATMO_PROPERTY(BLE_Humidity, readDataType), ATMO_PROPERTY(BLE_Humidity, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\t&ATMO_VARIABLE(BLE_Humidity, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Humidity, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Humidity, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\tATMO_VARIABLE(BLE_Humidity, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Humidity, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Humidity, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Humidity, instance),\n\t\tATMO_VARIABLE(BLE_Humidity, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Humidity, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fd",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 700,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_Humidity",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_Light",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\t&ATMO_VARIABLE(BLE_Light, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Light, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Light, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Light, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Light, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Light, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Light, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Light, writeDataType), ATMO_PROPERTY(BLE_Light, readDataType), ATMO_PROPERTY(BLE_Light, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\t&ATMO_VARIABLE(BLE_Light, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Light, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Light, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\tATMO_VARIABLE(BLE_Light, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Light, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Light, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Light, instance),\n\t\tATMO_VARIABLE(BLE_Light, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Light, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336fe",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 800,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_Light",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_Battery",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\t&ATMO_VARIABLE(BLE_Battery, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Battery, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Battery, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Battery, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Battery, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Battery, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Battery, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Battery, writeDataType), ATMO_PROPERTY(BLE_Battery, readDataType), ATMO_PROPERTY(BLE_Battery, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\t&ATMO_VARIABLE(BLE_Battery, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Battery, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Battery, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\tATMO_VARIABLE(BLE_Battery, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Battery, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Battery, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Battery, instance),\n\t\tATMO_VARIABLE(BLE_Battery, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Battery, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336ff",
            "read": true,
            "write": false,
            "notify": true,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 1000,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_Battery",
          "coupledElementPlaneName": "NXP Rapid IoT"
        },
        {
          "name": "BLE_Altitude",
          "type": "AppBLECharacteristicCustom",
          "variants": [
            "app",
            "ble"
          ],
          "properties": {
            "errorData": {},
            "readData": null,
            "code": {
              "trigger": "\treturn ATMO_Status_Success;",
              "setup": "\n\tATMO_BLE_GATTSAddService(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\t&ATMO_VARIABLE(BLE_Altitude, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Altitude, bleServiceUuid));\n\t\n\tuint8_t property = 0;\n\tuint8_t permission = 0;\n\t\n\tproperty |= ATMO_PROPERTY(BLE_Altitude, read) ? ATMO_BLE_Property_Read : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Altitude, write) ? ATMO_BLE_Property_Write : 0;\n\tproperty |= ATMO_PROPERTY(BLE_Altitude, notify) ? ATMO_BLE_Property_Notify : 0;\n\n\tpermission |= ATMO_PROPERTY(BLE_Altitude, read) ? ATMO_BLE_Permission_Read : 0;\n\tpermission |= ATMO_PROPERTY(BLE_Altitude, write) ? ATMO_BLE_Permission_Write : 0;\n\n\tATMO_DATATYPE types[3] = {ATMO_PROPERTY(BLE_Altitude, writeDataType), ATMO_PROPERTY(BLE_Altitude, readDataType), ATMO_PROPERTY(BLE_Altitude, notifyDataType)};\n\t\n\tATMO_BLE_GATTSAddCharacteristic(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\t&ATMO_VARIABLE(BLE_Altitude, bleCharacteristicHandle), \n\t\tATMO_VARIABLE(BLE_Altitude, bleServiceHandle), \n\t\tATMO_PROPERTY(BLE_Altitude, bleCharacteristicUuid), \n\t\tproperty, permission, ATMO_GetMaxValueSize(3, 64, types));\n\t\n\tATMO_BLE_GATTSRegisterCharacteristicAbilityHandle(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\tATMO_VARIABLE(BLE_Altitude, bleCharacteristicHandle), \n\t\tATMO_BLE_Characteristic_Written, \n\t\tATMO_ABILITY(BLE_Altitude, written));\n\t\n\treturn ATMO_Status_Success;\n\t",
              "setValue": "\n\t\n\t// Convert to the desired write data type\n\tATMO_Value_t convertedValue;\n\tATMO_InitValue(&convertedValue);\n\tATMO_CreateValueConverted(&convertedValue, ATMO_PROPERTY(BLE_Altitude, readDataType), in);\n\n\tATMO_BLE_GATTSSetCharacteristic(\n\t\tATMO_PROPERTY(BLE_Altitude, instance),\n\t\tATMO_VARIABLE(BLE_Altitude, bleCharacteristicHandle),\n\t\tconvertedValue.size, \n\t\t(uint8_t *)convertedValue.data,\n\t\tNULL);\n\t\n\tATMO_FreeValue(&convertedValue);\n\t\t\n\treturn ATMO_Status_Success;\n\t",
              "written": "\n\tATMO_CreateValueConverted(out, ATMO_PROPERTY(BLE_Altitude, writeDataType), in);\n\treturn ATMO_Status_Success;\n\t",
              "subscibed": "\treturn ATMO_Status_Success;",
              "unsubscribed": "\treturn ATMO_Status_Success;"
            },
            "variables": {
              "bleServiceHandle": {
                "type": "ATMO_BLE_Handle_t"
              },
              "bleCharacteristicHandle": {
                "type": "ATMO_BLE_Handle_t"
              }
            },
            "embeddedPropertyConversions": {
              "bleServiceUuid": "string",
              "bleCharacteristicUuid": "string"
            },
            "codeUserChanged": {
              "setup": false,
              "setValue": false,
              "written": false,
              "subscibed": false,
              "unsubscribed": false
            },
            "instance": "ATMO_DRIVERINSTANCE_BLE_BLE1",
            "bleServiceUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f8",
            "bleCharacteristicUuid": "08d41e61-ac11-40a2-a95a-e0e0fb5336f7",
            "read": true,
            "write": false,
            "notify": false,
            "readDataType": "ATMO_DATATYPE_STRING",
            "writeDataType": "ATMO_DATATYPE_STRING",
            "notifyDataType": "ATMO_DATATYPE_STRING"
          },
          "meta": {
            "editorX": 1100,
            "editorY": 0,
            "lastTrigger": "read"
          },
          "triggers": {
            "triggered": [],
            "read": [],
            "written": [],
            "notification": [],
            "indication": [],
            "subscribed": [],
            "unsubscribed": []
          },
          "coupledElementName": "BLE_Altitude",
          "coupledElementPlaneName": "NXP Rapid IoT"
        }
      ]
    },
    "Cloud": {
      "type": "cloud",
      "compilerVersion": "latest",
      "variants": [],
      "meta": {},
      "elements": [],
      "layout": {
        "height": 1000,
        "width": 1000,
        "zIndexOrder": []
      }
    }
  }
}